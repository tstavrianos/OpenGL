using System;
using System.Text;
using System.Runtime.InteropServices;
using System.Collections.Generic;

namespace OpenGL {
    public unsafe static partial class Wrappers {
        private static string PtrToStringUTF8(IntPtr ptr) {
            if (ptr == IntPtr.Zero) return null;
            var buff = new List<byte>();
            var offset = 0;
            for (; ; offset++) {
                var currentByte = Marshal.ReadByte(ptr, offset);
                if (currentByte == 0) break;
                buff.Add(currentByte);
            }
            return Encoding.UTF8.GetString(buff.ToArray());
        }
        
        /// <summary>
        /// operate on the accumulation buffer
        /// <para>
        /// The accumulation buffer is an extended-range color buffer. Images are not rendered into it. Rather,
        /// images rendered into one of the color buffers are added to the contents of the accumulation buffer
        /// after rendering. Effects such as antialiasing (of points, lines, and polygons), motion blur, and
        /// depth of field can be created by accumulating images generated with different transformation
        /// matrices
        /// </para>
        /// </summary>
        /// <param name="op">
        /// Specifies the accumulation buffer operation. Symbolic constants GL_ACCUM, GL_LOAD, GL_ADD, GL_MULT,
        /// and GL_RETURN are accepted.
        /// </param>
        /// <param name="value">
        /// Specifies a floating-point value used in the accumulation buffer operation. op determines how value
        /// is used.
        /// </param>
        public static void glAccum(int op, float value) {
            Pointers.glAccum(op, value);
        }
        
        public static void glAccumxOES(int op, IntPtr value) {
            Pointers.glAccumxOES(op, value);
        }
        
        public static void glActiveProgramEXT(uint program) {
            Pointers.glActiveProgramEXT(program);
        }
        
        /// <summary>
        /// set the active program object for a program pipeline object
        /// <para>
        /// glActiveShaderProgram sets the linked program named by program to be the active program for the
        /// program pipeline object pipeline. The active program in the active program pipeline object is the
        /// target of calls to glUniform when no program has been made current through a call to glUseProgram
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the program pipeline object to set the active program object for.
        /// </param>
        /// <param name="program">
        /// Specifies the program object to set as the active program pipeline object pipeline.
        /// </param>
        public static void glActiveShaderProgram(uint pipeline, uint program) {
            Pointers.glActiveShaderProgram(pipeline, program);
        }
        
        public static void glActiveShaderProgramEXT(uint pipeline, uint program) {
            Pointers.glActiveShaderProgramEXT(pipeline, program);
        }
        
        public static void glActiveStencilFaceEXT(int face) {
            Pointers.glActiveStencilFaceEXT(face);
        }
        
        /// <summary>
        /// select active texture unit
        /// <para>
        /// glActiveTexture selects which texture unit subsequent texture state calls will affect. The number of
        /// texture units an implementation supports is implementation dependent, but must be at least 80
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies which texture unit to make active. The number of texture units is implementation
        /// dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to
        /// the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0.
        /// </param>
        public static void glActiveTexture(int texture) {
            Pointers.glActiveTexture(texture);
        }
        
        /// <summary>
        /// select active texture unit
        /// <para>
        /// glActiveTexture selects which texture unit subsequent texture state calls will affect. The number of
        /// texture units an implementation supports is implementation dependent, but must be at least 80
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies which texture unit to make active. The number of texture units is implementation
        /// dependent, but must be at least 80. texture must be one of GL_TEXTUREi, where i ranges from zero to
        /// the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS minus one. The initial value is GL_TEXTURE0.
        /// </param>
        public static void glActiveTextureARB(int texture) {
            Pointers.glActiveTextureARB(texture);
        }
        
        public static void glActiveVaryingNV(uint program, string name) {
            Pointers.glActiveVaryingNV(program, name);
        }
        
        public static void glAlphaFragmentOp1ATI(int op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) {
            Pointers.glAlphaFragmentOp1ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod);
        }
        
        public static void glAlphaFragmentOp2ATI(int op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) {
            Pointers.glAlphaFragmentOp2ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
        }
        
        public static void glAlphaFragmentOp3ATI(int op, uint dst, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) {
            Pointers.glAlphaFragmentOp3ATI(op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
        }
        
        /// <summary>
        /// specify the alpha test function
        /// <para>
        /// The alpha test discards fragments depending on the outcome of a comparison between an incoming
        /// fragment's alpha value and a constant reference value. glAlphaFunc specifies the reference value and
        /// the comparison function. The comparison is performed only if alpha testing is enabled. By default,
        /// it is not enabled. (See glEnable and glDisable of GL_ALPHA_TEST.)
        /// </para>
        /// </summary>
        /// <param name="func">
        /// Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL,
        /// GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_ALWAYS.
        /// </param>
        /// <param name="_ref">
        /// Specifies the reference value that incoming alpha values are compared to. This value is clamped to
        /// the range 0 1 , where 0 represents the lowest possible alpha value and 1 the highest possible value.
        /// The initial reference value is 0.
        /// </param>
        public static void glAlphaFunc(int func, float _ref) {
            Pointers.glAlphaFunc(func, _ref);
        }
        
        public static void glAlphaFuncQCOM(int func, float _ref) {
            Pointers.glAlphaFuncQCOM(func, _ref);
        }
        
        public static void glAlphaFuncx(int func, IntPtr _ref) {
            Pointers.glAlphaFuncx(func, _ref);
        }
        
        public static void glAlphaFuncxOES(int func, IntPtr _ref) {
            Pointers.glAlphaFuncxOES(func, _ref);
        }
        
        public static void glAlphaToCoverageDitherControlNV(int mode) {
            Pointers.glAlphaToCoverageDitherControlNV(mode);
        }
        
        public static void glApplyFramebufferAttachmentCMAAINTEL() {
            Pointers.glApplyFramebufferAttachmentCMAAINTEL();
        }
        
        public static void glApplyTextureEXT(int mode) {
            Pointers.glApplyTextureEXT(mode);
        }
        
        public static bool glAcquireKeyedMutexWin32EXT(uint memory, ulong key, uint timeout) {
            return Pointers.glAcquireKeyedMutexWin32EXT(memory, key, timeout);
        }
        
        public static bool glAreProgramsResidentNV(int n, uint* programs, bool* residences) {
            return Pointers.glAreProgramsResidentNV(n, programs, residences);
        }
        
        public static bool glAreProgramsResidentNV(int n, uint* programs, bool[] residences) {
            fixed(bool* residences_ = &residences[0])
                return Pointers.glAreProgramsResidentNV(n, programs, residences_);
        }
        
        public static bool glAreProgramsResidentNV(int n, uint[] programs, bool* residences) {
            fixed(uint* programs_ = &programs[0])
                return Pointers.glAreProgramsResidentNV(n, programs_, residences);
        }
        
        public static bool glAreProgramsResidentNV(int n, uint[] programs, bool[] residences) {
            fixed(uint* programs_ = &programs[0])
            fixed(bool* residences_ = &residences[0])
                return Pointers.glAreProgramsResidentNV(n, programs_, residences_);
        }
        
        /// <summary>
        /// determine if textures are loaded in texture memory
        /// <para>
        /// GL establishes a ``working set'' of textures that are resident in texture memory. These textures can
        /// be bound to a texture target much more efficiently than textures that are not resident
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be queried.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be queried.
        /// </param>
        /// <param name="residences">
        /// Specifies an array in which the texture residence status is returned. The residence status of a
        /// texture named by an element of textures is returned in the corresponding element of residences.
        /// </param>
        public static bool glAreTexturesResident(int n, uint* textures, bool* residences) {
            return Pointers.glAreTexturesResident(n, textures, residences);
        }
        
        /// <summary>
        /// determine if textures are loaded in texture memory
        /// <para>
        /// GL establishes a ``working set'' of textures that are resident in texture memory. These textures can
        /// be bound to a texture target much more efficiently than textures that are not resident
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be queried.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be queried.
        /// </param>
        /// <param name="residences">
        /// Specifies an array in which the texture residence status is returned. The residence status of a
        /// texture named by an element of textures is returned in the corresponding element of residences.
        /// </param>
        public static bool glAreTexturesResident(int n, uint* textures, bool[] residences) {
            fixed(bool* residences_ = &residences[0])
                return Pointers.glAreTexturesResident(n, textures, residences_);
        }
        
        /// <summary>
        /// determine if textures are loaded in texture memory
        /// <para>
        /// GL establishes a ``working set'' of textures that are resident in texture memory. These textures can
        /// be bound to a texture target much more efficiently than textures that are not resident
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be queried.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be queried.
        /// </param>
        /// <param name="residences">
        /// Specifies an array in which the texture residence status is returned. The residence status of a
        /// texture named by an element of textures is returned in the corresponding element of residences.
        /// </param>
        public static bool glAreTexturesResident(int n, uint[] textures, bool* residences) {
            fixed(uint* textures_ = &textures[0])
                return Pointers.glAreTexturesResident(n, textures_, residences);
        }
        
        /// <summary>
        /// determine if textures are loaded in texture memory
        /// <para>
        /// GL establishes a ``working set'' of textures that are resident in texture memory. These textures can
        /// be bound to a texture target much more efficiently than textures that are not resident
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be queried.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be queried.
        /// </param>
        /// <param name="residences">
        /// Specifies an array in which the texture residence status is returned. The residence status of a
        /// texture named by an element of textures is returned in the corresponding element of residences.
        /// </param>
        public static bool glAreTexturesResident(int n, uint[] textures, bool[] residences) {
            fixed(uint* textures_ = &textures[0])
            fixed(bool* residences_ = &residences[0])
                return Pointers.glAreTexturesResident(n, textures_, residences_);
        }
        
        public static bool glAreTexturesResidentEXT(int n, uint* textures, bool* residences) {
            return Pointers.glAreTexturesResidentEXT(n, textures, residences);
        }
        
        public static bool glAreTexturesResidentEXT(int n, uint* textures, bool[] residences) {
            fixed(bool* residences_ = &residences[0])
                return Pointers.glAreTexturesResidentEXT(n, textures, residences_);
        }
        
        public static bool glAreTexturesResidentEXT(int n, uint[] textures, bool* residences) {
            fixed(uint* textures_ = &textures[0])
                return Pointers.glAreTexturesResidentEXT(n, textures_, residences);
        }
        
        public static bool glAreTexturesResidentEXT(int n, uint[] textures, bool[] residences) {
            fixed(uint* textures_ = &textures[0])
            fixed(bool* residences_ = &residences[0])
                return Pointers.glAreTexturesResidentEXT(n, textures_, residences_);
        }
        
        /// <summary>
        /// render a vertex using the specified vertex array element
        /// <para>
        /// glArrayElement commands are used within glBegin/glEnd pairs to specify vertex and attribute data for
        /// point, line, and polygon primitives. If GL_VERTEX_ARRAY is enabled when glArrayElement is called, a
        /// single vertex is drawn, using vertex and attribute data taken from location i of the enabled arrays.
        /// If GL_VERTEX_ARRAY is not enabled, no drawing occurs but the attributes corresponding to the enabled
        /// arrays are modified
        /// </para>
        /// </summary>
        /// <param name="i">
        /// Specifies an index into the enabled vertex data arrays.
        /// </param>
        public static void glArrayElement(int i) {
            Pointers.glArrayElement(i);
        }
        
        /// <summary>
        /// render a vertex using the specified vertex array element
        /// <para>
        /// glArrayElement commands are used within glBegin/glEnd pairs to specify vertex and attribute data for
        /// point, line, and polygon primitives. If GL_VERTEX_ARRAY is enabled when glArrayElement is called, a
        /// single vertex is drawn, using vertex and attribute data taken from location i of the enabled arrays.
        /// If GL_VERTEX_ARRAY is not enabled, no drawing occurs but the attributes corresponding to the enabled
        /// arrays are modified
        /// </para>
        /// </summary>
        /// <param name="i">
        /// Specifies an index into the enabled vertex data arrays.
        /// </param>
        public static void glArrayElementEXT(int i) {
            Pointers.glArrayElementEXT(i);
        }
        
        public static void glArrayObjectATI(int array, int size, int type, int stride, uint buffer, uint offset) {
            Pointers.glArrayObjectATI(array, size, type, stride, buffer, offset);
        }
        
        public static void glAsyncMarkerSGIX(uint marker) {
            Pointers.glAsyncMarkerSGIX(marker);
        }
        
        /// <summary>
        /// Attaches a shader object to a program object
        /// <para>
        /// In order to create a complete shader program, there must be a way to specify the list of things that
        /// will be linked together. Program objects provide this mechanism. Shaders that are to be linked
        /// together in a program object must first be attached to that program object. glAttachShader attaches
        /// the shader object specified by shader to the program object specified by program. This indicates
        /// that shader will be included in link operations that will be performed on program
        /// </para>
        /// </summary>
        /// <param name="containerObj">
        /// Specifies the program object to which a shader object will be attached.
        /// </param>
        /// <param name="obj">
        /// Specifies the shader object that is to be attached.
        /// </param>
        public static void glAttachObjectARB(uint containerObj, uint obj) {
            Pointers.glAttachObjectARB(containerObj, obj);
        }
        
        /// <summary>
        /// Attaches a shader object to a program object
        /// <para>
        /// In order to create a complete shader program, there must be a way to specify the list of things that
        /// will be linked together. Program objects provide this mechanism. Shaders that are to be linked
        /// together in a program object must first be attached to that program object. glAttachShader attaches
        /// the shader object specified by shader to the program object specified by program. This indicates
        /// that shader will be included in link operations that will be performed on program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to which a shader object will be attached.
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object that is to be attached.
        /// </param>
        public static void glAttachShader(uint program, uint shader) {
            Pointers.glAttachShader(program, shader);
        }
        
        /// <summary>
        /// delimit the vertices of a primitive or a group of like primitives
        /// <para>
        /// glBegin and glEnd delimit the vertices that define a primitive or a group of like primitives.
        /// glBegin accepts a single argument that specifies in which of ten ways the vertices are interpreted.
        /// Taking n as an integer count starting at one, and N as the total number of vertices specified, the
        /// interpretations are as follows:
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies the primitive or primitives that will be created from vertices presented between glBegin
        /// and the subsequent glEnd. Ten symbolic constants are accepted: GL_POINTS, GL_LINES, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUADS, GL_QUAD_STRIP, and
        /// GL_POLYGON.
        /// </param>
        public static void glBegin(int mode) {
            Pointers.glBegin(mode);
        }
        
        /// <summary>
        /// start conditional rendering
        /// <para>
        /// Conditional rendering is started using glBeginConditionalRender and ended using
        /// glEndConditionalRender. During conditional rendering, all vertex array commands, as well as glClear
        /// and glClearBuffer have no effect if the (GL_SAMPLES_PASSED) result of the query object id is zero,
        /// or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE. The results of commands setting the current
        /// vertex state, such as glVertexAttrib are undefined. If the (GL_SAMPLES_PASSED) result is non-zero or
        /// if the (GL_ANY_SAMPLES_PASSED) result is GL_TRUE, such commands are not discarded. The id parameter
        /// to glBeginConditionalRender must be the name of a query object previously returned from a call to
        /// glGenQueries. mode specifies how the results of the query object are to be interpreted. If mode is
        /// GL_QUERY_WAIT, the GL waits for the results of the query to be available and then uses the results
        /// to determine if subsequent rendering commands are discarded. If mode is GL_QUERY_NO_WAIT, the GL may
        /// choose to unconditionally execute the subsequent rendering commands without waiting for the query to
        /// complete
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of an occlusion query object whose results are used to determine if the rendering
        /// commands are discarded.
        /// </param>
        /// <param name="mode">
        /// Specifies how glBeginConditionalRender interprets the results of the occlusion query.
        /// </param>
        public static void glBeginConditionalRender(uint id, int mode) {
            Pointers.glBeginConditionalRender(id, mode);
        }
        
        /// <summary>
        /// start conditional rendering
        /// <para>
        /// Conditional rendering is started using glBeginConditionalRender and ended using
        /// glEndConditionalRender. During conditional rendering, all vertex array commands, as well as glClear
        /// and glClearBuffer have no effect if the (GL_SAMPLES_PASSED) result of the query object id is zero,
        /// or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE. The results of commands setting the current
        /// vertex state, such as glVertexAttrib are undefined. If the (GL_SAMPLES_PASSED) result is non-zero or
        /// if the (GL_ANY_SAMPLES_PASSED) result is GL_TRUE, such commands are not discarded. The id parameter
        /// to glBeginConditionalRender must be the name of a query object previously returned from a call to
        /// glGenQueries. mode specifies how the results of the query object are to be interpreted. If mode is
        /// GL_QUERY_WAIT, the GL waits for the results of the query to be available and then uses the results
        /// to determine if subsequent rendering commands are discarded. If mode is GL_QUERY_NO_WAIT, the GL may
        /// choose to unconditionally execute the subsequent rendering commands without waiting for the query to
        /// complete
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of an occlusion query object whose results are used to determine if the rendering
        /// commands are discarded.
        /// </param>
        /// <param name="mode">
        /// Specifies how glBeginConditionalRender interprets the results of the occlusion query.
        /// </param>
        public static void glBeginConditionalRenderNV(uint id, int mode) {
            Pointers.glBeginConditionalRenderNV(id, mode);
        }
        
        public static void glBeginConditionalRenderNVX(uint id) {
            Pointers.glBeginConditionalRenderNVX(id);
        }
        
        public static void glBeginFragmentShaderATI() {
            Pointers.glBeginFragmentShaderATI();
        }
        
        public static void glBeginOcclusionQueryNV(uint id) {
            Pointers.glBeginOcclusionQueryNV(id);
        }
        
        public static void glBeginPerfMonitorAMD(uint monitor) {
            Pointers.glBeginPerfMonitorAMD(monitor);
        }
        
        public static void glBeginPerfQueryINTEL(uint queryHandle) {
            Pointers.glBeginPerfQueryINTEL(queryHandle);
        }
        
        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>
        /// glBeginQuery and glEndQuery delimit the boundaries of a query object. query must be a name
        /// previously returned from a call to glGenQueries. If a query object with name id does not yet exist
        /// it is created with the type determined by target. target must be one of GL_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
        /// GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQuery and the subsequent
        /// glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        public static void glBeginQuery(int target, uint id) {
            Pointers.glBeginQuery(target, id);
        }
        
        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>
        /// glBeginQuery and glEndQuery delimit the boundaries of a query object. query must be a name
        /// previously returned from a call to glGenQueries. If a query object with name id does not yet exist
        /// it is created with the type determined by target. target must be one of GL_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
        /// GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQuery and the subsequent
        /// glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        public static void glBeginQueryARB(int target, uint id) {
            Pointers.glBeginQueryARB(target, id);
        }
        
        public static void glBeginQueryEXT(int target, uint id) {
            Pointers.glBeginQueryEXT(target, id);
        }
        
        /// <summary>
        /// delimit the boundaries of a query object on an indexed target
        /// <para>
        /// glBeginQueryIndexed and glEndQueryIndexed delimit the boundaries of a query object. query must be a
        /// name previously returned from a call to glGenQueries. If a query object with name id does not yet
        /// exist it is created with the type determined by target. target must be one of GL_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
        /// GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQueryIndexed and the subsequent
        /// glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the query target upon which to begin the query.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        public static void glBeginQueryIndexed(int target, uint index, uint id) {
            Pointers.glBeginQueryIndexed(target, index, id);
        }
        
        /// <summary>
        /// start transform feedback operation
        /// <para>
        /// Transform feedback mode captures the values of varying variables written by the vertex shader (or,
        /// if active, the geometry shader). Transform feedback is said to be active after a call to
        /// glBeginTransformFeedback until a subsequent call to glEndTransformFeedback. Transform feedback
        /// commands must be paired
        /// </para>
        /// </summary>
        /// <param name="primitiveMode">
        /// Specify the output type of the primitives that will be recorded into the buffer objects that are
        /// bound for transform feedback.
        /// </param>
        public static void glBeginTransformFeedback(int primitiveMode) {
            Pointers.glBeginTransformFeedback(primitiveMode);
        }
        
        /// <summary>
        /// start transform feedback operation
        /// <para>
        /// Transform feedback mode captures the values of varying variables written by the vertex shader (or,
        /// if active, the geometry shader). Transform feedback is said to be active after a call to
        /// glBeginTransformFeedback until a subsequent call to glEndTransformFeedback. Transform feedback
        /// commands must be paired
        /// </para>
        /// </summary>
        /// <param name="primitiveMode">
        /// Specify the output type of the primitives that will be recorded into the buffer objects that are
        /// bound for transform feedback.
        /// </param>
        public static void glBeginTransformFeedbackEXT(int primitiveMode) {
            Pointers.glBeginTransformFeedbackEXT(primitiveMode);
        }
        
        /// <summary>
        /// start transform feedback operation
        /// <para>
        /// Transform feedback mode captures the values of varying variables written by the vertex shader (or,
        /// if active, the geometry shader). Transform feedback is said to be active after a call to
        /// glBeginTransformFeedback until a subsequent call to glEndTransformFeedback. Transform feedback
        /// commands must be paired
        /// </para>
        /// </summary>
        /// <param name="primitiveMode">
        /// Specify the output type of the primitives that will be recorded into the buffer objects that are
        /// bound for transform feedback.
        /// </param>
        public static void glBeginTransformFeedbackNV(int primitiveMode) {
            Pointers.glBeginTransformFeedbackNV(primitiveMode);
        }
        
        public static void glBeginVertexShaderEXT() {
            Pointers.glBeginVertexShaderEXT();
        }
        
        public static void glBeginVideoCaptureNV(uint video_capture_slot) {
            Pointers.glBeginVideoCaptureNV(video_capture_slot);
        }
        
        /// <summary>
        /// Associates a generic vertex attribute index with a named attribute variable
        /// <para>
        /// glBindAttribLocation is used to associate a user-defined attribute variable in the program object
        /// specified by program with a generic vertex attribute index. The name of the user-defined attribute
        /// variable is passed as a null terminated string in name. The generic vertex attribute index to be
        /// bound to this variable is specified by index. When program is made part of current state, values
        /// provided via the generic vertex attribute index will modify the value of the user-defined attribute
        /// variable specified by name
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object in which the association is to be made.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be bound.
        /// </param>
        /// <param name="name">
        /// Specifies a null terminated string containing the name of the vertex shader attribute variable to
        /// which index is to be bound.
        /// </param>
        public static void glBindAttribLocation(uint program, uint index, string name) {
            Pointers.glBindAttribLocation(program, index, name);
        }
        
        /// <summary>
        /// Associates a generic vertex attribute index with a named attribute variable
        /// <para>
        /// glBindAttribLocation is used to associate a user-defined attribute variable in the program object
        /// specified by program with a generic vertex attribute index. The name of the user-defined attribute
        /// variable is passed as a null terminated string in name. The generic vertex attribute index to be
        /// bound to this variable is specified by index. When program is made part of current state, values
        /// provided via the generic vertex attribute index will modify the value of the user-defined attribute
        /// variable specified by name
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the handle of the program object in which the association is to be made.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be bound.
        /// </param>
        /// <param name="name">
        /// Specifies a null terminated string containing the name of the vertex shader attribute variable to
        /// which index is to be bound.
        /// </param>
        public static void glBindAttribLocationARB(uint programObj, uint index, string name) {
            Pointers.glBindAttribLocationARB(programObj, index, name);
        }
        
        /// <summary>
        /// bind a named buffer object
        /// <para>
        /// glBindBuffer binds a buffer object to the specified buffer binding point. Calling glBindBuffer with
        /// target set to one of the accepted symbolic constants and buffer set to the name of a buffer object
        /// binds that buffer object name to the target. If no buffer object with name buffer exists, one is
        /// created with that name. When a buffer object is bound to a target, the previous binding for that
        /// target is automatically broken
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound, which must be one of the buffer binding
        /// targets in the following table:
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        public static void glBindBuffer(int target, uint buffer) {
            Pointers.glBindBuffer(target, buffer);
        }
        
        /// <summary>
        /// bind a named buffer object
        /// <para>
        /// glBindBuffer binds a buffer object to the specified buffer binding point. Calling glBindBuffer with
        /// target set to one of the accepted symbolic constants and buffer set to the name of a buffer object
        /// binds that buffer object name to the target. If no buffer object with name buffer exists, one is
        /// created with that name. When a buffer object is bound to a target, the previous binding for that
        /// target is automatically broken
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound, which must be one of the buffer binding
        /// targets in the following table:
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of a buffer object.
        /// </param>
        public static void glBindBufferARB(int target, uint buffer) {
            Pointers.glBindBufferARB(target, buffer);
        }
        
        /// <summary>
        /// bind a buffer object to an indexed buffer target
        /// <para>
        /// glBindBufferBase binds the buffer object buffer to the binding point at index index of the array of
        /// targets specified by target. Each target represents an indexed array of buffer binding points, as
        /// well as a single general binding point that can be used by other buffer manipulation functions such
        /// as glBindBuffer or glMapBuffer. In addition to binding buffer to the indexed buffer binding target,
        /// glBindBufferBase also binds buffer to the generic buffer binding point specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        public static void glBindBufferBase(int target, uint index, uint buffer) {
            Pointers.glBindBufferBase(target, index, buffer);
        }
        
        /// <summary>
        /// bind a buffer object to an indexed buffer target
        /// <para>
        /// glBindBufferBase binds the buffer object buffer to the binding point at index index of the array of
        /// targets specified by target. Each target represents an indexed array of buffer binding points, as
        /// well as a single general binding point that can be used by other buffer manipulation functions such
        /// as glBindBuffer or glMapBuffer. In addition to binding buffer to the indexed buffer binding target,
        /// glBindBufferBase also binds buffer to the generic buffer binding point specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        public static void glBindBufferBaseEXT(int target, uint index, uint buffer) {
            Pointers.glBindBufferBaseEXT(target, index, buffer);
        }
        
        /// <summary>
        /// bind a buffer object to an indexed buffer target
        /// <para>
        /// glBindBufferBase binds the buffer object buffer to the binding point at index index of the array of
        /// targets specified by target. Each target represents an indexed array of buffer binding points, as
        /// well as a single general binding point that can be used by other buffer manipulation functions such
        /// as glBindBuffer or glMapBuffer. In addition to binding buffer to the indexed buffer binding target,
        /// glBindBufferBase also binds buffer to the generic buffer binding point specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        public static void glBindBufferBaseNV(int target, uint index, uint buffer) {
            Pointers.glBindBufferBaseNV(target, index, buffer);
        }
        
        public static void glBindBufferOffsetEXT(int target, uint index, uint buffer, uint offset) {
            Pointers.glBindBufferOffsetEXT(target, index, buffer, offset);
        }
        
        public static void glBindBufferOffsetNV(int target, uint index, uint buffer, uint offset) {
            Pointers.glBindBufferOffsetNV(target, index, buffer, offset);
        }
        
        /// <summary>
        /// bind a range within a buffer object to an indexed buffer target
        /// <para>
        /// glBindBufferRange binds a range the buffer object buffer represented by offset and size to the
        /// binding point at index index of the array of targets specified by target. Each target represents an
        /// indexed array of buffer binding points, as well as a single general binding point that can be used
        /// by other buffer manipulation functions such as glBindBuffer or glMapBuffer. In addition to binding a
        /// range of buffer to the indexed buffer binding target, glBindBufferRange also binds the range to the
        /// generic buffer binding point specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </param>
        /// <param name="size">
        /// The amount of data in machine units that can be read from the buffer object while used as an indexed
        /// target.
        /// </param>
        public static void glBindBufferRange(int target, uint index, uint buffer, uint offset, uint size) {
            Pointers.glBindBufferRange(target, index, buffer, offset, size);
        }
        
        /// <summary>
        /// bind a range within a buffer object to an indexed buffer target
        /// <para>
        /// glBindBufferRange binds a range the buffer object buffer represented by offset and size to the
        /// binding point at index index of the array of targets specified by target. Each target represents an
        /// indexed array of buffer binding points, as well as a single general binding point that can be used
        /// by other buffer manipulation functions such as glBindBuffer or glMapBuffer. In addition to binding a
        /// range of buffer to the indexed buffer binding target, glBindBufferRange also binds the range to the
        /// generic buffer binding point specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </param>
        /// <param name="size">
        /// The amount of data in machine units that can be read from the buffer object while used as an indexed
        /// target.
        /// </param>
        public static void glBindBufferRangeEXT(int target, uint index, uint buffer, uint offset, uint size) {
            Pointers.glBindBufferRangeEXT(target, index, buffer, offset, size);
        }
        
        /// <summary>
        /// bind a range within a buffer object to an indexed buffer target
        /// <para>
        /// glBindBufferRange binds a range the buffer object buffer represented by offset and size to the
        /// binding point at index index of the array of targets specified by target. Each target represents an
        /// indexed array of buffer binding points, as well as a single general binding point that can be used
        /// by other buffer manipulation functions such as glBindBuffer or glMapBuffer. In addition to binding a
        /// range of buffer to the indexed buffer binding target, glBindBufferRange also binds the range to the
        /// generic buffer binding point specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER, or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="index">
        /// Specify the index of the binding point within the array specified by target.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object buffer.
        /// </param>
        /// <param name="size">
        /// The amount of data in machine units that can be read from the buffer object while used as an indexed
        /// target.
        /// </param>
        public static void glBindBufferRangeNV(int target, uint index, uint buffer, uint offset, uint size) {
            Pointers.glBindBufferRangeNV(target, index, buffer, offset, size);
        }
        
        /// <summary>
        /// bind one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersBase binds a set of count buffer objects whose names are given in the array buffers to
        /// the count consecutive binding points starting from index index of the array of targets specified by
        /// target. If buffers is NULL then glBindBuffersBase unbinds any buffers that are currently bound to
        /// the referenced binding points. Assuming no errors are generated, it is equivalent to the following
        /// pseudo-code, which calls glBindBufferBase, with the exception that the non-indexed target is not
        /// changed by glBindBuffersBase:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        public static void glBindBuffersBase(int target, uint first, int count, uint* buffers) {
            Pointers.glBindBuffersBase(target, first, count, buffers);
        }
        
        /// <summary>
        /// bind one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersBase binds a set of count buffer objects whose names are given in the array buffers to
        /// the count consecutive binding points starting from index index of the array of targets specified by
        /// target. If buffers is NULL then glBindBuffersBase unbinds any buffers that are currently bound to
        /// the referenced binding points. Assuming no errors are generated, it is equivalent to the following
        /// pseudo-code, which calls glBindBufferBase, with the exception that the non-indexed target is not
        /// changed by glBindBuffersBase:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        public static void glBindBuffersBase(int target, uint first, int count, uint[] buffers) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glBindBuffersBase(target, first, count, buffers_);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint* buffers, uint* offsets, uint* sizes) {
            Pointers.glBindBuffersRange(target, first, count, buffers, offsets, sizes);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint* buffers, uint* offsets, uint[] sizes) {
            fixed(uint* sizes_ = &sizes[0])
                Pointers.glBindBuffersRange(target, first, count, buffers, offsets, sizes_);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint* buffers, uint[] offsets, uint* sizes) {
            fixed(uint* offsets_ = &offsets[0])
                Pointers.glBindBuffersRange(target, first, count, buffers, offsets_, sizes);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint* buffers, uint[] offsets, uint[] sizes) {
            fixed(uint* offsets_ = &offsets[0])
            fixed(uint* sizes_ = &sizes[0])
                Pointers.glBindBuffersRange(target, first, count, buffers, offsets_, sizes_);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint[] buffers, uint* offsets, uint* sizes) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glBindBuffersRange(target, first, count, buffers_, offsets, sizes);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint[] buffers, uint* offsets, uint[] sizes) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* sizes_ = &sizes[0])
                Pointers.glBindBuffersRange(target, first, count, buffers_, offsets, sizes_);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint[] buffers, uint[] offsets, uint* sizes) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* offsets_ = &offsets[0])
                Pointers.glBindBuffersRange(target, first, count, buffers_, offsets_, sizes);
        }
        
        /// <summary>
        /// bind ranges of one or more buffer objects to a sequence of indexed buffer targets
        /// <para>
        /// glBindBuffersRange binds a set of count ranges from buffer objects whose names are given in the
        /// array buffers to the count consecutive binding points starting from index index of the array of
        /// targets specified by target. offsets specifies the address of an array containing count starting
        /// offsets within the buffers, and sizes specifies the address of an array of count sizes of the
        /// ranges. If buffers is NULL then offsets and sizes are ignored and glBindBuffersRange unbinds any
        /// buffers that are currently bound to the referenced binding points. Assuming no errors are generated,
        /// it is equivalent to the following pseudo-code, which calls glBindBufferRange, with the exception
        /// that the non-indexed target is not changed by glBindBuffersRange:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target of the bind operation. target must be one of GL_ATOMIC_COUNTER_BUFFER,
        /// GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER.
        /// </param>
        /// <param name="first"> </param>
        /// <param name="count">
        /// Specify the number of contiguous binding points to which to bind buffers.
        /// </param>
        /// <param name="buffers">
        /// A pointer to an array of names of buffer objects to bind to the targets on the specified binding
        /// point, or NULL.
        /// </param>
        /// <param name="offsets">
        /// A pointer to an array of offsets into the corresponding buffer in buffers to bind, or NULL if
        /// buffers is NULL.
        /// </param>
        /// <param name="sizes">
        /// A pointer to an array of sizes of the corresponding buffer in buffers to bind, or NULL if buffers is
        /// NULL.
        /// </param>
        public static void glBindBuffersRange(int target, uint first, int count, uint[] buffers, uint[] offsets, uint[] sizes) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* offsets_ = &offsets[0])
            fixed(uint* sizes_ = &sizes[0])
                Pointers.glBindBuffersRange(target, first, count, buffers_, offsets_, sizes_);
        }
        
        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number
        /// <para>
        /// glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable
        /// name to fragment shader color number colorNumber for program program. If name was bound previously,
        /// its assigned binding is replaced with colorNumber. name must be a null-terminated string.
        /// colorNumber must be less than GL_MAX_DRAW_BUFFERS
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to modify
        /// </param>
        /// <param name="color">
        /// The color number to bind the user-defined varying out variable to
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose binding to modify
        /// </param>
        public static void glBindFragDataLocation(uint program, uint color, string name) {
            Pointers.glBindFragDataLocation(program, color, name);
        }
        
        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number
        /// <para>
        /// glBindFragDataLocation explicitly specifies the binding of the user-defined varying out variable
        /// name to fragment shader color number colorNumber for program program. If name was bound previously,
        /// its assigned binding is replaced with colorNumber. name must be a null-terminated string.
        /// colorNumber must be less than GL_MAX_DRAW_BUFFERS
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to modify
        /// </param>
        /// <param name="color">
        /// The color number to bind the user-defined varying out variable to
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose binding to modify
        /// </param>
        public static void glBindFragDataLocationEXT(uint program, uint color, string name) {
            Pointers.glBindFragDataLocationEXT(program, color, name);
        }
        
        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number and index
        /// <para>
        /// glBindFragDataLocationIndexed specifies that the varying out variable name in program should be
        /// bound to fragment color colorNumber when the program is next linked. index may be zero or one to
        /// specify that the color be used as either the first or second color input to the blend equation,
        /// respectively
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to modify
        /// </param>
        /// <param name="colorNumber">
        /// The color number to bind the user-defined varying out variable to
        /// </param>
        /// <param name="index">
        /// The index of the color input to bind the user-defined varying out variable to
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose binding to modify
        /// </param>
        public static void glBindFragDataLocationIndexed(uint program, uint colorNumber, uint index, string name) {
            Pointers.glBindFragDataLocationIndexed(program, colorNumber, index, name);
        }
        
        /// <summary>
        /// bind a user-defined varying out variable to a fragment shader color number and index
        /// <para>
        /// glBindFragDataLocationIndexed specifies that the varying out variable name in program should be
        /// bound to fragment color colorNumber when the program is next linked. index may be zero or one to
        /// specify that the color be used as either the first or second color input to the blend equation,
        /// respectively
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to modify
        /// </param>
        /// <param name="colorNumber">
        /// The color number to bind the user-defined varying out variable to
        /// </param>
        /// <param name="index">
        /// The index of the color input to bind the user-defined varying out variable to
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose binding to modify
        /// </param>
        public static void glBindFragDataLocationIndexedEXT(uint program, uint colorNumber, uint index, string name) {
            Pointers.glBindFragDataLocationIndexedEXT(program, colorNumber, index, name);
        }
        
        public static void glBindFragmentShaderATI(uint id) {
            Pointers.glBindFragmentShaderATI(id);
        }
        
        /// <summary>
        /// bind a framebuffer to a framebuffer target
        /// <para>
        /// glBindFramebuffer binds the framebuffer object with name framebuffer to the framebuffer target
        /// specified by target. target must be either GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or
        /// GL_FRAMEBUFFER. If a framebuffer object is bound to GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER, it
        /// becomes the target for rendering or readback operations, respectively, until it is deleted or
        /// another framebuffer is bound to the corresponding bind point. Calling glBindFramebuffer with target
        /// set to GL_FRAMEBUFFER binds framebuffer to both the read and draw framebuffer targets. framebuffer
        /// is the name of a framebuffer object previously returned from a call to glGenFramebuffers, or zero to
        /// break the existing binding of a framebuffer object to target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the framebuffer target of the binding operation.
        /// </param>
        /// <param name="framebuffer">
        /// Specifies the name of the framebuffer object to bind.
        /// </param>
        public static void glBindFramebuffer(int target, uint framebuffer) {
            Pointers.glBindFramebuffer(target, framebuffer);
        }
        
        public static void glBindFramebufferEXT(int target, uint framebuffer) {
            Pointers.glBindFramebufferEXT(target, framebuffer);
        }
        
        public static void glBindFramebufferOES(int target, uint framebuffer) {
            Pointers.glBindFramebufferOES(target, framebuffer);
        }
        
        /// <summary>
        /// bind a level of a texture to an image unit
        /// <para>
        /// glBindImageTexture binds a single level of a texture to an image unit for the purpose of reading and
        /// writing it from shaders. unit specifies the zero-based index of the image unit to which to bind the
        /// texture level. texture specifies the name of an existing texture object to bind to the image unit.
        /// If texture is zero, then any existing binding to the image unit is broken. level specifies the level
        /// of the texture to bind to the image unit
        /// </para>
        /// </summary>
        /// <param name="unit">
        /// Specifies the index of the image unit to which to bind the texture
        /// </param>
        /// <param name="texture">
        /// Specifies the name of the texture to bind to the image unit.
        /// </param>
        /// <param name="level">
        /// Specifies the level of the texture that is to be bound.
        /// </param>
        /// <param name="layered">
        /// Specifies whether a layered texture binding is to be established.
        /// </param>
        /// <param name="layer">
        /// If layered is GL_FALSE, specifies the layer of texture to be bound to the image unit. Ignored
        /// otherwise.
        /// </param>
        /// <param name="access">
        /// Specifies a token indicating the type of access that will be performed on the image.
        /// </param>
        /// <param name="format">
        /// Specifies the format that the elements of the image will be treated as for the purposes of formatted
        /// stores.
        /// </param>
        public static void glBindImageTexture(uint unit, uint texture, int level, bool layered, int layer, int access, int format) {
            Pointers.glBindImageTexture(unit, texture, level, layered, layer, access, format);
        }
        
        public static void glBindImageTextureEXT(uint index, uint texture, int level, bool layered, int layer, int access, int format) {
            Pointers.glBindImageTextureEXT(index, texture, level, layered, layer, access, format);
        }
        
        /// <summary>
        /// bind one or more named texture images to a sequence of consecutive image units
        /// <para>
        /// glBindImageTextures binds images from an array of existing texture objects to a specified number of
        /// consecutive image units. count specifies the number of texture objects whose names are stored in the
        /// array textures. That number of texture names are read from the array and bound to the count
        /// consecutive texture units starting from first. If the name zero appears in the textures array, any
        /// existing binding to the image unit is reset. Any non-zero entry in textures must be the name of an
        /// existing texture object. When a non-zero entry in textures is present, the image at level zero is
        /// bound, the binding is considered layered, with the first layer set to zero, and the image is bound
        /// for read-write access. The image unit format parameter is taken from the internal format of the
        /// image at level zero of the texture object. For cube map textures, the internal format of the
        /// positive X image of level zero is used. If textures is NULL then it is as if an appropriately sized
        /// array containing only zeros had been specified
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first image unit to which a texture is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of textures to bind.
        /// </param>
        /// <param name="textures">
        /// Specifies the address of an array of names of existing texture objects.
        /// </param>
        public static void glBindImageTextures(uint first, int count, uint* textures) {
            Pointers.glBindImageTextures(first, count, textures);
        }
        
        /// <summary>
        /// bind one or more named texture images to a sequence of consecutive image units
        /// <para>
        /// glBindImageTextures binds images from an array of existing texture objects to a specified number of
        /// consecutive image units. count specifies the number of texture objects whose names are stored in the
        /// array textures. That number of texture names are read from the array and bound to the count
        /// consecutive texture units starting from first. If the name zero appears in the textures array, any
        /// existing binding to the image unit is reset. Any non-zero entry in textures must be the name of an
        /// existing texture object. When a non-zero entry in textures is present, the image at level zero is
        /// bound, the binding is considered layered, with the first layer set to zero, and the image is bound
        /// for read-write access. The image unit format parameter is taken from the internal format of the
        /// image at level zero of the texture object. For cube map textures, the internal format of the
        /// positive X image of level zero is used. If textures is NULL then it is as if an appropriately sized
        /// array containing only zeros had been specified
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first image unit to which a texture is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of textures to bind.
        /// </param>
        /// <param name="textures">
        /// Specifies the address of an array of names of existing texture objects.
        /// </param>
        public static void glBindImageTextures(uint first, int count, uint[] textures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glBindImageTextures(first, count, textures_);
        }
        
        public static uint glBindLightParameterEXT(int light, int value) {
            return Pointers.glBindLightParameterEXT(light, value);
        }
        
        public static uint glBindMaterialParameterEXT(int face, int value) {
            return Pointers.glBindMaterialParameterEXT(face, value);
        }
        
        public static void glBindMultiTextureEXT(int texunit, int target, uint texture) {
            Pointers.glBindMultiTextureEXT(texunit, target, texture);
        }
        
        public static uint glBindParameterEXT(int value) {
            return Pointers.glBindParameterEXT(value);
        }
        
        public static void glBindProgramARB(int target, uint program) {
            Pointers.glBindProgramARB(target, program);
        }
        
        public static void glBindProgramNV(int target, uint id) {
            Pointers.glBindProgramNV(target, id);
        }
        
        /// <summary>
        /// bind a program pipeline to the current context
        /// <para>
        /// glBindProgramPipeline binds a program pipeline object to the current context. pipeline must be a
        /// name previously returned from a call to glGenProgramPipelines. If no program pipeline exists with
        /// name pipeline then a new pipeline object is created with that name and initialized to the default
        /// state vector
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of the pipeline object to bind to the context.
        /// </param>
        public static void glBindProgramPipeline(uint pipeline) {
            Pointers.glBindProgramPipeline(pipeline);
        }
        
        public static void glBindProgramPipelineEXT(uint pipeline) {
            Pointers.glBindProgramPipelineEXT(pipeline);
        }
        
        /// <summary>
        /// bind a renderbuffer to a renderbuffer target
        /// <para>
        /// glBindRenderbuffer binds the renderbuffer object with name renderbuffer to the renderbuffer target
        /// specified by target. target must be GL_RENDERBUFFER. renderbuffer is the name of a renderbuffer
        /// object previously returned from a call to glGenRenderbuffers, or zero to break the existing binding
        /// of a renderbuffer object to target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the renderbuffer target of the binding operation. target must be GL_RENDERBUFFER.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of the renderbuffer object to bind.
        /// </param>
        public static void glBindRenderbuffer(int target, uint renderbuffer) {
            Pointers.glBindRenderbuffer(target, renderbuffer);
        }
        
        public static void glBindRenderbufferEXT(int target, uint renderbuffer) {
            Pointers.glBindRenderbufferEXT(target, renderbuffer);
        }
        
        public static void glBindRenderbufferOES(int target, uint renderbuffer) {
            Pointers.glBindRenderbufferOES(target, renderbuffer);
        }
        
        /// <summary>
        /// bind a named sampler to a texturing target
        /// <para>
        /// glBindSampler binds sampler to the texture unit at index unit. sampler must be zero or the name of a
        /// sampler object previously returned from a call to glGenSamplers. unit must be less than the value of
        /// GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
        /// </para>
        /// </summary>
        /// <param name="unit">
        /// Specifies the index of the texture unit to which the sampler is bound.
        /// </param>
        /// <param name="sampler">
        /// Specifies the name of a sampler.
        /// </param>
        public static void glBindSampler(uint unit, uint sampler) {
            Pointers.glBindSampler(unit, sampler);
        }
        
        /// <summary>
        /// bind one or more named sampler objects to a sequence of consecutive sampler units
        /// <para>
        /// glBindSamplers binds samplers from an array of existing sampler objects to a specified number of
        /// consecutive sampler units. count specifies the number of sampler objects whose names are stored in
        /// the array samplers. That number of sampler names is read from the array and bound to the count
        /// consecutive sampler units starting from first
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first sampler unit to which a sampler object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of samplers to bind.
        /// </param>
        /// <param name="samplers">
        /// Specifies the address of an array of names of existing sampler objects.
        /// </param>
        public static void glBindSamplers(uint first, int count, uint* samplers) {
            Pointers.glBindSamplers(first, count, samplers);
        }
        
        /// <summary>
        /// bind one or more named sampler objects to a sequence of consecutive sampler units
        /// <para>
        /// glBindSamplers binds samplers from an array of existing sampler objects to a specified number of
        /// consecutive sampler units. count specifies the number of sampler objects whose names are stored in
        /// the array samplers. That number of sampler names is read from the array and bound to the count
        /// consecutive sampler units starting from first
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first sampler unit to which a sampler object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of samplers to bind.
        /// </param>
        /// <param name="samplers">
        /// Specifies the address of an array of names of existing sampler objects.
        /// </param>
        public static void glBindSamplers(uint first, int count, uint[] samplers) {
            fixed(uint* samplers_ = &samplers[0])
                Pointers.glBindSamplers(first, count, samplers_);
        }
        
        public static uint glBindTexGenParameterEXT(int unit, int coord, int value) {
            return Pointers.glBindTexGenParameterEXT(unit, coord, value);
        }
        
        /// <summary>
        /// bind a named texture to a texturing target
        /// <para>
        /// glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to
        /// GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
        /// GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER,
        /// GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and texture set to the name of the new
        /// texture binds the texture name to the target. When a texture is bound to a target, the previous
        /// binding for that target is automatically broken
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D,
        /// GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP,
        /// GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        public static void glBindTexture(int target, uint texture) {
            Pointers.glBindTexture(target, texture);
        }
        
        /// <summary>
        /// bind a named texture to a texturing target
        /// <para>
        /// glBindTexture lets you create or use a named texture. Calling glBindTexture with target set to
        /// GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
        /// GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER,
        /// GL_TEXTURE_2D_MULTISAMPLE or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and texture set to the name of the new
        /// texture binds the texture name to the target. When a texture is bound to a target, the previous
        /// binding for that target is automatically broken
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound. Must be one of GL_TEXTURE_1D, GL_TEXTURE_2D,
        /// GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP,
        /// GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE or
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        public static void glBindTextureEXT(int target, uint texture) {
            Pointers.glBindTextureEXT(target, texture);
        }
        
        /// <summary>
        /// bind an existing texture object to the specified texture unit 
        /// </summary>
        /// <param name="unit">
        /// Specifies the texture unit, to which the texture object should be bound to.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of a texture.
        /// </param>
        public static void glBindTextureUnit(uint unit, uint texture) {
            Pointers.glBindTextureUnit(unit, texture);
        }
        
        public static uint glBindTextureUnitParameterEXT(int unit, int value) {
            return Pointers.glBindTextureUnitParameterEXT(unit, value);
        }
        
        /// <summary>
        /// bind one or more named textures to a sequence of consecutive texture units
        /// <para>
        /// glBindTextures binds an array of existing texture objects to a specified number of consecutive
        /// texture units. count specifies the number of texture objects whose names are stored in the array
        /// textures. That number of texture names are read from the array and bound to the count consecutive
        /// texture units starting from first. The target, or type of texture is deduced from the texture object
        /// and each texture is bound to the corresponding target of the texture unit. If the name zero appears
        /// in the textures array, any existing binding to any target of the texture unit is reset and the
        /// default texture for that target is bound in its place. Any non-zero entry in textures must be the
        /// name of an existing texture object. If textures is NULL then it is as if an appropriately sized
        /// array containing only zeros had been specified
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first texture unit to which a texture is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of textures to bind.
        /// </param>
        /// <param name="textures">
        /// Specifies the address of an array of names of existing texture objects.
        /// </param>
        public static void glBindTextures(uint first, int count, uint* textures) {
            Pointers.glBindTextures(first, count, textures);
        }
        
        /// <summary>
        /// bind one or more named textures to a sequence of consecutive texture units
        /// <para>
        /// glBindTextures binds an array of existing texture objects to a specified number of consecutive
        /// texture units. count specifies the number of texture objects whose names are stored in the array
        /// textures. That number of texture names are read from the array and bound to the count consecutive
        /// texture units starting from first. The target, or type of texture is deduced from the texture object
        /// and each texture is bound to the corresponding target of the texture unit. If the name zero appears
        /// in the textures array, any existing binding to any target of the texture unit is reset and the
        /// default texture for that target is bound in its place. Any non-zero entry in textures must be the
        /// name of an existing texture object. If textures is NULL then it is as if an appropriately sized
        /// array containing only zeros had been specified
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first texture unit to which a texture is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of textures to bind.
        /// </param>
        /// <param name="textures">
        /// Specifies the address of an array of names of existing texture objects.
        /// </param>
        public static void glBindTextures(uint first, int count, uint[] textures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glBindTextures(first, count, textures_);
        }
        
        /// <summary>
        /// bind a transform feedback object
        /// <para>
        /// glBindTransformFeedback binds the transform feedback object with name id to the current GL state. id
        /// must be a name previously returned from a call to glGenTransformFeedbacks. If id has not previously
        /// been bound, a new transform feedback object with name id and initialized with with the default
        /// transform state vector is created
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which to bind the transform feedback object id. target must be
        /// GL_TRANSFORM_FEEDBACK.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object reserved by glGenTransformFeedbacks.
        /// </param>
        public static void glBindTransformFeedback(int target, uint id) {
            Pointers.glBindTransformFeedback(target, id);
        }
        
        public static void glBindTransformFeedbackNV(int target, uint id) {
            Pointers.glBindTransformFeedbackNV(target, id);
        }
        
        /// <summary>
        /// bind a vertex array object
        /// <para>
        /// glBindVertexArray binds the vertex array object with name array. array is the name of a vertex array
        /// object previously returned from a call to glGenVertexArrays, or zero to break the existing vertex
        /// array object binding
        /// </para>
        /// </summary>
        /// <param name="array">
        /// Specifies the name of the vertex array to bind.
        /// </param>
        public static void glBindVertexArray(uint array) {
            Pointers.glBindVertexArray(array);
        }
        
        public static void glBindVertexArrayAPPLE(uint array) {
            Pointers.glBindVertexArrayAPPLE(array);
        }
        
        /// <summary>
        /// bind a vertex array object
        /// <para>
        /// glBindVertexArray binds the vertex array object with name array. array is the name of a vertex array
        /// object previously returned from a call to glGenVertexArrays, or zero to break the existing vertex
        /// array object binding
        /// </para>
        /// </summary>
        /// <param name="array">
        /// Specifies the name of the vertex array to bind.
        /// </param>
        public static void glBindVertexArrayOES(uint array) {
            Pointers.glBindVertexArrayOES(array);
        }
        
        /// <summary>
        /// bind a buffer to a vertex buffer bind point
        /// </summary>
        /// <param name="bindingindex">
        /// The index of the vertex buffer binding point to which to bind the buffer.
        /// </param>
        /// <param name="buffer">
        /// The name of a buffer to bind to the vertex buffer binding point.
        /// </param>
        /// <param name="offset">
        /// The offset of the first element of the buffer.
        /// </param>
        /// <param name="stride">
        /// The distance between elements within the buffer.
        /// </param>
        public static void glBindVertexBuffer(uint bindingindex, uint buffer, uint offset, int stride) {
            Pointers.glBindVertexBuffer(bindingindex, buffer, offset, stride);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint* buffers, uint* offsets, int* strides) {
            Pointers.glBindVertexBuffers(first, count, buffers, offsets, strides);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint* buffers, uint* offsets, int[] strides) {
            fixed(int* strides_ = &strides[0])
                Pointers.glBindVertexBuffers(first, count, buffers, offsets, strides_);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint* buffers, uint[] offsets, int* strides) {
            fixed(uint* offsets_ = &offsets[0])
                Pointers.glBindVertexBuffers(first, count, buffers, offsets_, strides);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint* buffers, uint[] offsets, int[] strides) {
            fixed(uint* offsets_ = &offsets[0])
            fixed(int* strides_ = &strides[0])
                Pointers.glBindVertexBuffers(first, count, buffers, offsets_, strides_);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint[] buffers, uint* offsets, int* strides) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glBindVertexBuffers(first, count, buffers_, offsets, strides);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint[] buffers, uint* offsets, int[] strides) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(int* strides_ = &strides[0])
                Pointers.glBindVertexBuffers(first, count, buffers_, offsets, strides_);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint[] buffers, uint[] offsets, int* strides) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* offsets_ = &offsets[0])
                Pointers.glBindVertexBuffers(first, count, buffers_, offsets_, strides);
        }
        
        /// <summary>
        /// attach multiple buffer objects to a vertex array object
        /// <para>
        /// glBindVertexBuffers and glVertexArrayVertexBuffers bind storage from an array of existing buffer
        /// objects to a specified number of consecutive vertex buffer binding points units in a vertex array
        /// object. For glBindVertexBuffers, the vertex array object is the currently bound vertex array object.
        /// For glVertexArrayVertexBuffers, vaobj is the name of the vertex array object
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the first vertex buffer binding point to which a buffer object is to be bound.
        /// </param>
        /// <param name="count">
        /// Specifies the number of buffers to bind.
        /// </param>
        /// <param name="buffers">
        /// Specifies the address of an array of names of existing buffer objects.
        /// </param>
        /// <param name="offsets">
        /// Specifies the address of an array of offsets to associate with the binding points.
        /// </param>
        /// <param name="strides"> </param>
        public static void glBindVertexBuffers(uint first, int count, uint[] buffers, uint[] offsets, int[] strides) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* offsets_ = &offsets[0])
            fixed(int* strides_ = &strides[0])
                Pointers.glBindVertexBuffers(first, count, buffers_, offsets_, strides_);
        }
        
        public static void glBindVertexShaderEXT(uint id) {
            Pointers.glBindVertexShaderEXT(id);
        }
        
        public static void glBindVideoCaptureStreamBufferNV(uint video_capture_slot, uint stream, int frame_region, IntPtr offset) {
            Pointers.glBindVideoCaptureStreamBufferNV(video_capture_slot, stream, frame_region, offset);
        }
        
        public static void glBindVideoCaptureStreamTextureNV(uint video_capture_slot, uint stream, int frame_region, int target, uint texture) {
            Pointers.glBindVideoCaptureStreamTextureNV(video_capture_slot, stream, frame_region, target, texture);
        }
        
        public static void glBinormal3bEXT(sbyte bx, sbyte by, sbyte bz) {
            Pointers.glBinormal3bEXT(bx, by, bz);
        }
        
        public static void glBinormal3bvEXT(sbyte* v) {
            Pointers.glBinormal3bvEXT(v);
        }
        
        public static void glBinormal3bvEXT(sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glBinormal3bvEXT(v_);
        }
        
        public static void glBinormal3dEXT(double bx, double by, double bz) {
            Pointers.glBinormal3dEXT(bx, by, bz);
        }
        
        public static void glBinormal3dvEXT(double* v) {
            Pointers.glBinormal3dvEXT(v);
        }
        
        public static void glBinormal3dvEXT(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glBinormal3dvEXT(v_);
        }
        
        public static void glBinormal3fEXT(float bx, float by, float bz) {
            Pointers.glBinormal3fEXT(bx, by, bz);
        }
        
        public static void glBinormal3fvEXT(float* v) {
            Pointers.glBinormal3fvEXT(v);
        }
        
        public static void glBinormal3fvEXT(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glBinormal3fvEXT(v_);
        }
        
        public static void glBinormal3iEXT(int bx, int by, int bz) {
            Pointers.glBinormal3iEXT(bx, by, bz);
        }
        
        public static void glBinormal3ivEXT(int* v) {
            Pointers.glBinormal3ivEXT(v);
        }
        
        public static void glBinormal3ivEXT(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glBinormal3ivEXT(v_);
        }
        
        public static void glBinormal3sEXT(short bx, short by, short bz) {
            Pointers.glBinormal3sEXT(bx, by, bz);
        }
        
        public static void glBinormal3svEXT(short* v) {
            Pointers.glBinormal3svEXT(v);
        }
        
        public static void glBinormal3svEXT(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glBinormal3svEXT(v_);
        }
        
        public static void glBinormalPointerEXT(int type, int stride, IntPtr pointer) {
            Pointers.glBinormalPointerEXT(type, stride, pointer);
        }
        
        /// <summary>
        /// draw a bitmap
        /// <para>
        /// A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster
        /// position, and frame buffer pixels corresponding to 1's in the bitmap are written using the current
        /// raster color or index. Frame buffer pixels corresponding to 0's in the bitmap are not modified
        /// </para>
        /// </summary>
        /// <param name="width">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="height">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="xorig">
        /// Specify the location of the origin in the bitmap image. The origin is measured from the lower left
        /// corner of the bitmap, with right and up being the positive axes.
        /// </param>
        /// <param name="yorig">
        /// Specify the location of the origin in the bitmap image. The origin is measured from the lower left
        /// corner of the bitmap, with right and up being the positive axes.
        /// </param>
        /// <param name="xmove">
        /// Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.
        /// </param>
        /// <param name="ymove">
        /// Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.
        /// </param>
        /// <param name="bitmap">
        /// Specifies the address of the bitmap image.
        /// </param>
        public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte* bitmap) {
            Pointers.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap);
        }
        
        /// <summary>
        /// draw a bitmap
        /// <para>
        /// A bitmap is a binary image. When drawn, the bitmap is positioned relative to the current raster
        /// position, and frame buffer pixels corresponding to 1's in the bitmap are written using the current
        /// raster color or index. Frame buffer pixels corresponding to 0's in the bitmap are not modified
        /// </para>
        /// </summary>
        /// <param name="width">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="height">
        /// Specify the pixel width and height of the bitmap image.
        /// </param>
        /// <param name="xorig">
        /// Specify the location of the origin in the bitmap image. The origin is measured from the lower left
        /// corner of the bitmap, with right and up being the positive axes.
        /// </param>
        /// <param name="yorig">
        /// Specify the location of the origin in the bitmap image. The origin is measured from the lower left
        /// corner of the bitmap, with right and up being the positive axes.
        /// </param>
        /// <param name="xmove">
        /// Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.
        /// </param>
        /// <param name="ymove">
        /// Specify the x and y offsets to be added to the current raster position after the bitmap is drawn.
        /// </param>
        /// <param name="bitmap">
        /// Specifies the address of the bitmap image.
        /// </param>
        public static void glBitmap(int width, int height, float xorig, float yorig, float xmove, float ymove, byte[] bitmap) {
            fixed(byte* bitmap_ = &bitmap[0])
                Pointers.glBitmap(width, height, xorig, yorig, xmove, ymove, bitmap_);
        }
        
        public static void glBitmapxOES(int width, int height, IntPtr xorig, IntPtr yorig, IntPtr xmove, IntPtr ymove, byte* bitmap) {
            Pointers.glBitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap);
        }
        
        public static void glBitmapxOES(int width, int height, IntPtr xorig, IntPtr yorig, IntPtr xmove, IntPtr ymove, byte[] bitmap) {
            fixed(byte* bitmap_ = &bitmap[0])
                Pointers.glBitmapxOES(width, height, xorig, yorig, xmove, ymove, bitmap_);
        }
        
        public static void glBlendBarrier() {
            Pointers.glBlendBarrier();
        }
        
        public static void glBlendBarrierKHR() {
            Pointers.glBlendBarrierKHR();
        }
        
        public static void glBlendBarrierNV() {
            Pointers.glBlendBarrierNV();
        }
        
        /// <summary>
        /// set the blend color
        /// <para>
        /// The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The color
        /// components are clamped to the range 0 1 before being stored. See glBlendFunc for a complete
        /// description of the blending operations. Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0)
        /// </para>
        /// </summary>
        /// <param name="red">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        /// <param name="green">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        /// <param name="blue">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        /// <param name="alpha">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        public static void glBlendColor(float red, float green, float blue, float alpha) {
            Pointers.glBlendColor(red, green, blue, alpha);
        }
        
        /// <summary>
        /// set the blend color
        /// <para>
        /// The GL_BLEND_COLOR may be used to calculate the source and destination blending factors. The color
        /// components are clamped to the range 0 1 before being stored. See glBlendFunc for a complete
        /// description of the blending operations. Initially the GL_BLEND_COLOR is set to (0, 0, 0, 0)
        /// </para>
        /// </summary>
        /// <param name="red">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        /// <param name="green">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        /// <param name="blue">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        /// <param name="alpha">
        /// specify the components of GL_BLEND_COLOR
        /// </param>
        public static void glBlendColorEXT(float red, float green, float blue, float alpha) {
            Pointers.glBlendColorEXT(red, green, blue, alpha);
        }
        
        public static void glBlendColorxOES(IntPtr red, IntPtr green, IntPtr blue, IntPtr alpha) {
            Pointers.glBlendColorxOES(red, green, blue, alpha);
        }
        
        /// <summary>
        /// specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// <para>
        /// The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel
        /// already in the framebuffer (the ''destination'' color). This function sets both the RGB blend
        /// equation and the alpha blend equation to a single equation. glBlendEquationi specifies the blend
        /// equation for a single draw buffer whereas glBlendEquation sets the blend equation for all draw
        /// buffers
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,
        /// GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </param>
        public static void glBlendEquation(int mode) {
            Pointers.glBlendEquation(mode);
        }
        
        /// <summary>
        /// specify the equation used for both the RGB blend equation and the Alpha blend equation
        /// <para>
        /// The blend equations determine how a new pixel (the ''source'' color) is combined with a pixel
        /// already in the framebuffer (the ''destination'' color). This function sets both the RGB blend
        /// equation and the alpha blend equation to a single equation. glBlendEquationi specifies the blend
        /// equation for a single draw buffer whereas glBlendEquation sets the blend equation for all draw
        /// buffers
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// specifies how source and destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT,
        /// GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </param>
        public static void glBlendEquationEXT(int mode) {
            Pointers.glBlendEquationEXT(mode);
        }
        
        public static void glBlendEquationIndexedAMD(uint buf, int mode) {
            Pointers.glBlendEquationIndexedAMD(buf, mode);
        }
        
        public static void glBlendEquationOES(int mode) {
            Pointers.glBlendEquationOES(mode);
        }
        
        /// <summary>
        /// set the RGB blend equation and the alpha blend equation separately
        /// <para>
        /// The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel
        /// already in the framebuffer (the ''destination'' color). These functions specify one blend equation
        /// for the RGB-color components and one blend equation for the alpha component.
        /// glBlendEquationSeparatei specifies the blend equations for a single draw buffer whereas
        /// glBlendEquationSeparate sets the blend equations for all draw buffers
        /// </para>
        /// </summary>
        /// <param name="modeRGB">
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and
        /// destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT,
        /// GL_MIN, GL_MAX.
        /// </param>
        /// <param name="modeAlpha">
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are
        /// combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </param>
        public static void glBlendEquationSeparate(int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparate(modeRGB, modeAlpha);
        }
        
        /// <summary>
        /// set the RGB blend equation and the alpha blend equation separately
        /// <para>
        /// The blend equations determines how a new pixel (the ''source'' color) is combined with a pixel
        /// already in the framebuffer (the ''destination'' color). These functions specify one blend equation
        /// for the RGB-color components and one blend equation for the alpha component.
        /// glBlendEquationSeparatei specifies the blend equations for a single draw buffer whereas
        /// glBlendEquationSeparate sets the blend equations for all draw buffers
        /// </para>
        /// </summary>
        /// <param name="modeRGB">
        /// specifies the RGB blend equation, how the red, green, and blue components of the source and
        /// destination colors are combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT,
        /// GL_MIN, GL_MAX.
        /// </param>
        /// <param name="modeAlpha">
        /// specifies the alpha blend equation, how the alpha component of the source and destination colors are
        /// combined. It must be GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MIN, GL_MAX.
        /// </param>
        public static void glBlendEquationSeparateEXT(int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparateEXT(modeRGB, modeAlpha);
        }
        
        public static void glBlendEquationSeparateIndexedAMD(uint buf, int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparateIndexedAMD(buf, modeRGB, modeAlpha);
        }
        
        public static void glBlendEquationSeparateOES(int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparateOES(modeRGB, modeAlpha);
        }
        
        public static void glBlendEquationSeparatei(uint buf, int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
        }
        
        public static void glBlendEquationSeparateiARB(uint buf, int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparateiARB(buf, modeRGB, modeAlpha);
        }
        
        public static void glBlendEquationSeparateiEXT(uint buf, int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparateiEXT(buf, modeRGB, modeAlpha);
        }
        
        public static void glBlendEquationSeparateiOES(uint buf, int modeRGB, int modeAlpha) {
            Pointers.glBlendEquationSeparateiOES(buf, modeRGB, modeAlpha);
        }
        
        public static void glBlendEquationi(uint buf, int mode) {
            Pointers.glBlendEquationi(buf, mode);
        }
        
        public static void glBlendEquationiARB(uint buf, int mode) {
            Pointers.glBlendEquationiARB(buf, mode);
        }
        
        public static void glBlendEquationiEXT(uint buf, int mode) {
            Pointers.glBlendEquationiEXT(buf, mode);
        }
        
        public static void glBlendEquationiOES(uint buf, int mode) {
            Pointers.glBlendEquationiOES(buf, mode);
        }
        
        /// <summary>
        /// specify pixel arithmetic
        /// <para>
        /// Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA
        /// values that are already in the frame buffer (the destination values). Blending is initially
        /// disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending
        /// </para>
        /// </summary>
        /// <param name="sfactor">
        /// Specifies how the red, green, blue, and alpha source blending factors are computed. The initial
        /// value is GL_ONE.
        /// </param>
        /// <param name="dfactor">
        /// Specifies how the red, green, blue, and alpha destination blending factors are computed. The
        /// following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR,
        /// GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA,
        /// GL_ONE_MINUS_DST_ALPHA. GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and
        /// GL_ONE_MINUS_CONSTANT_ALPHA. The initial value is GL_ZERO.
        /// </param>
        public static void glBlendFunc(int sfactor, int dfactor) {
            Pointers.glBlendFunc(sfactor, dfactor);
        }
        
        public static void glBlendFuncIndexedAMD(uint buf, int src, int dst) {
            Pointers.glBlendFuncIndexedAMD(buf, src, dst);
        }
        
        /// <summary>
        /// specify pixel arithmetic for RGB and alpha components separately
        /// <para>
        /// Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA
        /// values that are already in the frame buffer (the destination values). Blending is initially
        /// disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending
        /// </para>
        /// </summary>
        /// <param name="sfactorRGB">
        /// Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.
        /// </param>
        /// <param name="dfactorRGB">
        /// Specifies how the red, green, and blue destination blending factors are computed. The initial value
        /// is GL_ZERO.
        /// </param>
        /// <param name="sfactorAlpha">
        /// Specified how the alpha source blending factor is computed. The initial value is GL_ONE.
        /// </param>
        /// <param name="dfactorAlpha">
        /// Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.
        /// </param>
        public static void glBlendFuncSeparate(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha) {
            Pointers.glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }
        
        /// <summary>
        /// specify pixel arithmetic for RGB and alpha components separately
        /// <para>
        /// Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA
        /// values that are already in the frame buffer (the destination values). Blending is initially
        /// disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending
        /// </para>
        /// </summary>
        /// <param name="sfactorRGB">
        /// Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.
        /// </param>
        /// <param name="dfactorRGB">
        /// Specifies how the red, green, and blue destination blending factors are computed. The initial value
        /// is GL_ZERO.
        /// </param>
        /// <param name="sfactorAlpha">
        /// Specified how the alpha source blending factor is computed. The initial value is GL_ONE.
        /// </param>
        /// <param name="dfactorAlpha">
        /// Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.
        /// </param>
        public static void glBlendFuncSeparateEXT(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha) {
            Pointers.glBlendFuncSeparateEXT(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }
        
        /// <summary>
        /// specify pixel arithmetic for RGB and alpha components separately
        /// <para>
        /// Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA
        /// values that are already in the frame buffer (the destination values). Blending is initially
        /// disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending
        /// </para>
        /// </summary>
        /// <param name="sfactorRGB">
        /// Specifies how the red, green, and blue blending factors are computed. The initial value is GL_ONE.
        /// </param>
        /// <param name="dfactorRGB">
        /// Specifies how the red, green, and blue destination blending factors are computed. The initial value
        /// is GL_ZERO.
        /// </param>
        /// <param name="sfactorAlpha">
        /// Specified how the alpha source blending factor is computed. The initial value is GL_ONE.
        /// </param>
        /// <param name="dfactorAlpha">
        /// Specified how the alpha destination blending factor is computed. The initial value is GL_ZERO.
        /// </param>
        public static void glBlendFuncSeparateINGR(int sfactorRGB, int dfactorRGB, int sfactorAlpha, int dfactorAlpha) {
            Pointers.glBlendFuncSeparateINGR(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
        }
        
        public static void glBlendFuncSeparateIndexedAMD(uint buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
            Pointers.glBlendFuncSeparateIndexedAMD(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        
        public static void glBlendFuncSeparateOES(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
            Pointers.glBlendFuncSeparateOES(srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        
        public static void glBlendFuncSeparatei(uint buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
            Pointers.glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        
        public static void glBlendFuncSeparateiARB(uint buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
            Pointers.glBlendFuncSeparateiARB(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        
        public static void glBlendFuncSeparateiEXT(uint buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
            Pointers.glBlendFuncSeparateiEXT(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        
        public static void glBlendFuncSeparateiOES(uint buf, int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
            Pointers.glBlendFuncSeparateiOES(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
        }
        
        public static void glBlendFunci(uint buf, int src, int dst) {
            Pointers.glBlendFunci(buf, src, dst);
        }
        
        public static void glBlendFunciARB(uint buf, int src, int dst) {
            Pointers.glBlendFunciARB(buf, src, dst);
        }
        
        public static void glBlendFunciEXT(uint buf, int src, int dst) {
            Pointers.glBlendFunciEXT(buf, src, dst);
        }
        
        public static void glBlendFunciOES(uint buf, int src, int dst) {
            Pointers.glBlendFunciOES(buf, src, dst);
        }
        
        public static void glBlendParameteriNV(int pname, int value) {
            Pointers.glBlendParameteriNV(pname, value);
        }
        
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>
        /// glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of
        /// a read framebuffer to another region of a draw framebuffer
        /// </para>
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or
        /// GL_LINEAR.
        /// </param>
        public static void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, int filter) {
            Pointers.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>
        /// glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of
        /// a read framebuffer to another region of a draw framebuffer
        /// </para>
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or
        /// GL_LINEAR.
        /// </param>
        public static void glBlitFramebuffer(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, Enums.ClearBufferMask mask, int filter) {
            Pointers.glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, filter);
        }
        
        public static void glBlitFramebufferANGLE(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, int filter) {
            Pointers.glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        public static void glBlitFramebufferANGLE(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, Enums.ClearBufferMask mask, int filter) {
            Pointers.glBlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, filter);
        }
        
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>
        /// glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of
        /// a read framebuffer to another region of a draw framebuffer
        /// </para>
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or
        /// GL_LINEAR.
        /// </param>
        public static void glBlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, int filter) {
            Pointers.glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>
        /// glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of
        /// a read framebuffer to another region of a draw framebuffer
        /// </para>
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or
        /// GL_LINEAR.
        /// </param>
        public static void glBlitFramebufferEXT(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, Enums.ClearBufferMask mask, int filter) {
            Pointers.glBlitFramebufferEXT(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, filter);
        }
        
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>
        /// glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of
        /// a read framebuffer to another region of a draw framebuffer
        /// </para>
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or
        /// GL_LINEAR.
        /// </param>
        public static void glBlitFramebufferNV(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, int filter) {
            Pointers.glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        /// <summary>
        /// copy a block of pixels from one framebuffer object to another
        /// <para>
        /// glBlitFramebuffer and glBlitNamedFramebuffer transfer a rectangle of pixel values from one region of
        /// a read framebuffer to another region of a draw framebuffer
        /// </para>
        /// </summary>
        /// <param name="srcX0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY0">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcX1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="srcY1">
        /// Specify the bounds of the source rectangle within the read buffer of the read framebuffer.
        /// </param>
        /// <param name="dstX0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY0">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstX1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="dstY1">
        /// Specify the bounds of the destination rectangle within the write buffer of the write framebuffer.
        /// </param>
        /// <param name="mask">
        /// The bitwise OR of the flags indicating which buffers are to be copied. The allowed flags are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT and GL_STENCIL_BUFFER_BIT.
        /// </param>
        /// <param name="filter">
        /// Specifies the interpolation to be applied if the image is stretched. Must be GL_NEAREST or
        /// GL_LINEAR.
        /// </param>
        public static void glBlitFramebufferNV(int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, Enums.ClearBufferMask mask, int filter) {
            Pointers.glBlitFramebufferNV(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, filter);
        }
        
        public static void glBlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, int filter) {
            Pointers.glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        public static void glBlitNamedFramebuffer(uint readFramebuffer, uint drawFramebuffer, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, Enums.ClearBufferMask mask, int filter) {
            Pointers.glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, filter);
        }
        
        public static void glBufferAddressRangeNV(int pname, uint index, ulong address, uint length) {
            Pointers.glBufferAddressRangeNV(pname, index, address, length);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferData, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if
        /// no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be
        /// GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY,
        /// GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </param>
        public static void glBufferData(int target, uint size, IntPtr data, int usage) {
            Pointers.glBufferData(target, size, data, usage);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferData, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if
        /// no data is to be copied.
        /// </param>
        /// <param name="usage">
        /// Specifies the expected usage pattern of the data store. The symbolic constant must be
        /// GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY,
        /// GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY.
        /// </param>
        public static void glBufferDataARB(int target, uint size, IntPtr data, int usage) {
            Pointers.glBufferDataARB(target, size, data, usage);
        }
        
        public static void glBufferPageCommitmentARB(int target, uint offset, uint size, bool commit) {
            Pointers.glBufferPageCommitmentARB(target, offset, size, commit);
        }
        
        public static void glBufferParameteriAPPLE(int target, int pname, int param) {
            Pointers.glBufferParameteriAPPLE(target, pname, param);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if
        /// no data is to be copied.
        /// </param>
        /// <param name="flags">
        /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the
        /// following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT,
        /// GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.
        /// </param>
        public static void glBufferStorage(int target, uint size, IntPtr data, uint flags) {
            Pointers.glBufferStorage(target, size, data, flags);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if
        /// no data is to be copied.
        /// </param>
        /// <param name="flags">
        /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the
        /// following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT,
        /// GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.
        /// </param>
        public static void glBufferStorage(int target, uint size, IntPtr data, Enums.MapBufferUsageMask flags) {
            Pointers.glBufferStorage(target, size, data, (uint)flags);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if
        /// no data is to be copied.
        /// </param>
        /// <param name="flags">
        /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the
        /// following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT,
        /// GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.
        /// </param>
        public static void glBufferStorageEXT(int target, uint size, IntPtr data, uint flags) {
            Pointers.glBufferStorageEXT(target, size, data, flags);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferStorage, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the buffer object's new data store.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to data that will be copied into the data store for initialization, or NULL if
        /// no data is to be copied.
        /// </param>
        /// <param name="flags">
        /// Specifies the intended usage of the buffer's data store. Must be a bitwise combination of the
        /// following flags. GL_DYNAMIC_STORAGE_BIT, GL_MAP_READ_BIT GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT,
        /// GL_MAP_COHERENT_BIT, and GL_CLIENT_STORAGE_BIT.
        /// </param>
        public static void glBufferStorageEXT(int target, uint size, IntPtr data, Enums.MapBufferUsageMask flags) {
            Pointers.glBufferStorageEXT(target, size, data, (uint)flags);
        }
        
        public static void glBufferStorageExternalEXT(int target, uint offset, uint size, IntPtr clientBuffer, uint flags) {
            Pointers.glBufferStorageExternalEXT(target, offset, size, clientBuffer, flags);
        }
        
        public static void glBufferStorageExternalEXT(int target, uint offset, uint size, IntPtr clientBuffer, Enums.MapBufferUsageMask flags) {
            Pointers.glBufferStorageExternalEXT(target, offset, size, clientBuffer, (uint)flags);
        }
        
        public static void glBufferStorageMemEXT(int target, uint size, uint memory, ulong offset) {
            Pointers.glBufferStorageMemEXT(target, size, memory, offset);
        }
        
        /// <summary>
        /// updates a subset of a buffer object's data store
        /// <para>
        /// glBufferSubData and glNamedBufferSubData redefine some or all of the data store for the specified
        /// buffer object. Data starting at byte offset offset and extending for size bytes is copied to the
        /// data store from the memory pointed to by data. offset and size must define a range lying entirely
        /// within the buffer object's data store
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured
        /// in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        public static void glBufferSubData(int target, uint offset, uint size, IntPtr data) {
            Pointers.glBufferSubData(target, offset, size, data);
        }
        
        /// <summary>
        /// updates a subset of a buffer object's data store
        /// <para>
        /// glBufferSubData and glNamedBufferSubData redefine some or all of the data store for the specified
        /// buffer object. Data starting at byte offset offset and extending for size bytes is copied to the
        /// data store from the memory pointed to by data. offset and size must define a range lying entirely
        /// within the buffer object's data store
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glBufferSubData, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store where data replacement will begin, measured
        /// in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being replaced.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the new data that will be copied into the data store.
        /// </param>
        public static void glBufferSubDataARB(int target, IntPtr offset, uint size, IntPtr data) {
            Pointers.glBufferSubDataARB(target, offset, size, data);
        }
        
        public static void glCallCommandListNV(uint list) {
            Pointers.glCallCommandListNV(list);
        }
        
        /// <summary>
        /// execute a display list
        /// <para>
        /// glCallList causes the named display list to be executed. The commands saved in the display list are
        /// executed in order, just as if they were called without using a display list. If list has not been
        /// defined as a display list, glCallList is ignored
        /// </para>
        /// </summary>
        /// <param name="list">
        /// Specifies the integer name of the display list to be executed.
        /// </param>
        public static void glCallList(uint list) {
            Pointers.glCallList(list);
        }
        
        /// <summary>
        /// execute a list of display lists
        /// <para>
        /// glCallLists causes each display list in the list of names passed as lists to be executed. As a
        /// result, the commands saved in each display list are executed in order, just as if they were called
        /// without using a display list. Names of display lists that have not been defined are ignored
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of display lists to be executed.
        /// </param>
        /// <param name="type">
        /// Specifies the type of values in lists. Symbolic constants GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT,
        /// GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, GL_2_BYTES, GL_3_BYTES, and GL_4_BYTES are
        /// accepted.
        /// </param>
        /// <param name="lists">
        /// Specifies the address of an array of name offsets in the display list. The pointer type is void
        /// because the offsets can be bytes, shorts, ints, or floats, depending on the value of type.
        /// </param>
        public static void glCallLists(int n, int type, IntPtr lists) {
            Pointers.glCallLists(n, type, lists);
        }
        
        /// <summary>
        /// check the completeness status of a framebuffer
        /// <para>
        /// glCheckFramebufferStatus and glCheckNamedFramebufferStatus return the completeness status of a
        /// framebuffer object when treated as a read or draw framebuffer, depending on the value of target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target
        /// against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus.
        /// </param>
        public static int glCheckFramebufferStatus(int target) {
            return Pointers.glCheckFramebufferStatus(target);
        }
        
        /// <summary>
        /// check the completeness status of a framebuffer
        /// <para>
        /// glCheckFramebufferStatus and glCheckNamedFramebufferStatus return the completeness status of a
        /// framebuffer object when treated as a read or draw framebuffer, depending on the value of target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specify the target to which the framebuffer is bound for glCheckFramebufferStatus, and the target
        /// against which framebuffer completeness of framebuffer is checked for glCheckNamedFramebufferStatus.
        /// </param>
        public static int glCheckFramebufferStatusEXT(int target) {
            return Pointers.glCheckFramebufferStatusEXT(target);
        }
        
        public static int glCheckFramebufferStatusOES(int target) {
            return Pointers.glCheckFramebufferStatusOES(target);
        }
        
        public static int glCheckNamedFramebufferStatus(uint framebuffer, int target) {
            return Pointers.glCheckNamedFramebufferStatus(framebuffer, target);
        }
        
        public static int glCheckNamedFramebufferStatusEXT(uint framebuffer, int target) {
            return Pointers.glCheckNamedFramebufferStatusEXT(framebuffer, target);
        }
        
        /// <summary>
        /// specify whether data read via glReadPixels should be clamped
        /// <para>
        /// glClampColor controls color clamping that is performed during glReadPixels. target must be
        /// GL_CLAMP_READ_COLOR. If clamp is GL_TRUE, read color clamping is enabled; if clamp is GL_FALSE, read
        /// color clamping is disabled. If clamp is GL_FIXED_ONLY, read color clamping is enabled only if the
        /// selected read buffer has fixed point components and disabled otherwise
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Target for color clamping. target must be GL_CLAMP_READ_COLOR.
        /// </param>
        /// <param name="clamp">
        /// Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE.
        /// </param>
        public static void glClampColor(int target, int clamp) {
            Pointers.glClampColor(target, clamp);
        }
        
        /// <summary>
        /// specify whether data read via glReadPixels should be clamped
        /// <para>
        /// glClampColor controls color clamping that is performed during glReadPixels. target must be
        /// GL_CLAMP_READ_COLOR. If clamp is GL_TRUE, read color clamping is enabled; if clamp is GL_FALSE, read
        /// color clamping is disabled. If clamp is GL_FIXED_ONLY, read color clamping is enabled only if the
        /// selected read buffer has fixed point components and disabled otherwise
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Target for color clamping. target must be GL_CLAMP_READ_COLOR.
        /// </param>
        /// <param name="clamp">
        /// Specifies whether to apply color clamping. clamp must be GL_TRUE or GL_FALSE.
        /// </param>
        public static void glClampColorARB(int target, int clamp) {
            Pointers.glClampColorARB(target, clamp);
        }
        
        /// <summary>
        /// clear buffers to preset values
        /// <para>
        /// glClear sets the bitplane area of the window to values previously selected by glClearColor,
        /// glClearDepth, and glClearStencil. Multiple color buffers can be cleared simultaneously by selecting
        /// more than one buffer at a time using glDrawBuffer
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
        /// </param>
        public static void glClear(uint mask) {
            Pointers.glClear(mask);
        }
        
        /// <summary>
        /// clear buffers to preset values
        /// <para>
        /// glClear sets the bitplane area of the window to values previously selected by glClearColor,
        /// glClearDepth, and glClearStencil. Multiple color buffers can be cleared simultaneously by selecting
        /// more than one buffer at a time using glDrawBuffer
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Bitwise OR of masks that indicate the buffers to be cleared. The three masks are
        /// GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT.
        /// </param>
        public static void glClear(Enums.ClearBufferMask mask) {
            Pointers.glClear((uint)mask);
        }
        
        /// <summary>
        /// specify clear values for the accumulation buffer
        /// <para>
        /// glClearAccum specifies the red, green, blue, and alpha values used by glClear to clear the
        /// accumulation buffer
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The
        /// initial values are all 0.
        /// </param>
        /// <param name="green">
        /// Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The
        /// initial values are all 0.
        /// </param>
        /// <param name="blue">
        /// Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The
        /// initial values are all 0.
        /// </param>
        /// <param name="alpha">
        /// Specify the red, green, blue, and alpha values used when the accumulation buffer is cleared. The
        /// initial values are all 0.
        /// </param>
        public static void glClearAccum(float red, float green, float blue, float alpha) {
            Pointers.glClearAccum(red, green, blue, alpha);
        }
        
        public static void glClearAccumxOES(IntPtr red, IntPtr green, IntPtr blue, IntPtr alpha) {
            Pointers.glClearAccumxOES(red, green, blue, alpha);
        }
        
        /// <summary>
        /// fill a buffer object's data store with a fixed value
        /// <para>
        /// glClearBufferData and glClearNamedBufferData fill the entirety of a buffer object's data store with
        /// data from client memory
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glClearBufferData, which must must be
        /// one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="internalformat">
        /// The internal format with which the data will be stored in the buffer object.
        /// </param>
        /// <param name="format">
        /// The format of the data in memory addressed by data.
        /// </param>
        /// <param name="type">
        /// The type of the data in memory addressed by data.
        /// </param>
        /// <param name="data">
        /// The type of the data in memory addressed by data.
        /// </param>
        public static void glClearBufferData(int target, int internalformat, int format, int type, IntPtr data) {
            Pointers.glClearBufferData(target, internalformat, format, type, data);
        }
        
        /// <summary>
        /// fill all or part of buffer object's data store with a fixed value
        /// <para>
        /// glClearBufferSubData and glClearNamedBufferSubData fill a specified region of a buffer object's data
        /// store with data from client memory
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glClearBufferSubData, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="internalformat">
        /// The internal format with which the data will be stored in the buffer object.
        /// </param>
        /// <param name="offset">
        /// The offset in basic machine units into the buffer object's data store at which to start filling.
        /// </param>
        /// <param name="size">
        /// The size in basic machine units of the range of the data store to fill.
        /// </param>
        /// <param name="format">
        /// The format of the data in memory addressed by data.
        /// </param>
        /// <param name="type">
        /// The type of the data in memory addressed by data.
        /// </param>
        /// <param name="data">
        /// The type of the data in memory addressed by data.
        /// </param>
        public static void glClearBufferSubData(int target, int internalformat, uint offset, uint size, int format, int type, IntPtr data) {
            Pointers.glClearBufferSubData(target, internalformat, offset, size, format, type, data);
        }
        
        public static void glClearBufferfi(int buffer, int drawbuffer, float depth, int stencil) {
            Pointers.glClearBufferfi(buffer, drawbuffer, depth, stencil);
        }
        
        public static void glClearBufferfv(int buffer, int drawbuffer, float* value) {
            Pointers.glClearBufferfv(buffer, drawbuffer, value);
        }
        
        public static void glClearBufferfv(int buffer, int drawbuffer, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glClearBufferfv(buffer, drawbuffer, value_);
        }
        
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>
        /// These commands clear a specified buffer of a framebuffer to specified value(s). For glClearBuffer*,
        /// the framebuffer is the currently bound draw framebuffer object. For glClearNamedFramebuffer*,
        /// framebuffer is zero, indicating the default draw framebuffer, or the name of a framebuffer object
        /// </para>
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">
        /// A pointer to the value or values to clear the buffer to.
        /// </param>
        public static void glClearBufferiv(int buffer, int drawbuffer, int* value) {
            Pointers.glClearBufferiv(buffer, drawbuffer, value);
        }
        
        /// <summary>
        /// clear individual buffers of a framebuffer
        /// <para>
        /// These commands clear a specified buffer of a framebuffer to specified value(s). For glClearBuffer*,
        /// the framebuffer is the currently bound draw framebuffer object. For glClearNamedFramebuffer*,
        /// framebuffer is zero, indicating the default draw framebuffer, or the name of a framebuffer object
        /// </para>
        /// </summary>
        /// <param name="buffer">
        /// Specify the buffer to clear.
        /// </param>
        /// <param name="drawbuffer">
        /// Specify a particular draw buffer to clear.
        /// </param>
        /// <param name="value">
        /// A pointer to the value or values to clear the buffer to.
        /// </param>
        public static void glClearBufferiv(int buffer, int drawbuffer, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glClearBufferiv(buffer, drawbuffer, value_);
        }
        
        public static void glClearBufferuiv(int buffer, int drawbuffer, uint* value) {
            Pointers.glClearBufferuiv(buffer, drawbuffer, value);
        }
        
        public static void glClearBufferuiv(int buffer, int drawbuffer, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glClearBufferuiv(buffer, drawbuffer, value_);
        }
        
        /// <summary>
        /// specify clear values for the color buffers
        /// <para>
        /// glClearColor specifies the red, green, blue, and alpha values used by glClear to clear the color
        /// buffers. Values specified by glClearColor are clamped to the range 0 1
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial
        /// values are all 0.
        /// </param>
        /// <param name="green">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial
        /// values are all 0.
        /// </param>
        /// <param name="blue">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial
        /// values are all 0.
        /// </param>
        /// <param name="alpha">
        /// Specify the red, green, blue, and alpha values used when the color buffers are cleared. The initial
        /// values are all 0.
        /// </param>
        public static void glClearColor(float red, float green, float blue, float alpha) {
            Pointers.glClearColor(red, green, blue, alpha);
        }
        
        public static void glClearColorIiEXT(int red, int green, int blue, int alpha) {
            Pointers.glClearColorIiEXT(red, green, blue, alpha);
        }
        
        public static void glClearColorIuiEXT(uint red, uint green, uint blue, uint alpha) {
            Pointers.glClearColorIuiEXT(red, green, blue, alpha);
        }
        
        public static void glClearColorx(IntPtr red, IntPtr green, IntPtr blue, IntPtr alpha) {
            Pointers.glClearColorx(red, green, blue, alpha);
        }
        
        public static void glClearColorxOES(IntPtr red, IntPtr green, IntPtr blue, IntPtr alpha) {
            Pointers.glClearColorxOES(red, green, blue, alpha);
        }
        
        /// <summary>
        /// specify the clear value for the depth buffer
        /// <para>
        /// glClearDepth specifies the depth value used by glClear to clear the depth buffer. Values specified
        /// by glClearDepth are clamped to the range 0 1
        /// </para>
        /// </summary>
        /// <param name="depth">
        /// Specifies the depth value used when the depth buffer is cleared. The initial value is 1.
        /// </param>
        public static void glClearDepth(double depth) {
            Pointers.glClearDepth(depth);
        }
        
        public static void glClearDepthdNV(double depth) {
            Pointers.glClearDepthdNV(depth);
        }
        
        public static void glClearDepthf(float d) {
            Pointers.glClearDepthf(d);
        }
        
        public static void glClearDepthfOES(float depth) {
            Pointers.glClearDepthfOES(depth);
        }
        
        public static void glClearDepthx(IntPtr depth) {
            Pointers.glClearDepthx(depth);
        }
        
        public static void glClearDepthxOES(IntPtr depth) {
            Pointers.glClearDepthxOES(depth);
        }
        
        /// <summary>
        /// specify the clear value for the color index buffers
        /// <para>
        /// glClearIndex specifies the index used by glClear to clear the color index buffers. c is not clamped.
        /// Rather, c is converted to a fixed-point value with unspecified precision to the right of the binary
        /// point. The integer part of this value is then masked with 2 m - 1 , where m is the number of bits in
        /// a color index stored in the frame buffer
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the index used when the color index buffers are cleared. The initial value is 0.
        /// </param>
        public static void glClearIndex(float c) {
            Pointers.glClearIndex(c);
        }
        
        public static void glClearNamedBufferData(uint buffer, int internalformat, int format, int type, IntPtr data) {
            Pointers.glClearNamedBufferData(buffer, internalformat, format, type, data);
        }
        
        public static void glClearNamedBufferDataEXT(uint buffer, int internalformat, int format, int type, IntPtr data) {
            Pointers.glClearNamedBufferDataEXT(buffer, internalformat, format, type, data);
        }
        
        public static void glClearNamedBufferSubData(uint buffer, int internalformat, uint offset, uint size, int format, int type, IntPtr data) {
            Pointers.glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);
        }
        
        public static void glClearNamedBufferSubDataEXT(uint buffer, int internalformat, uint offset, uint size, int format, int type, IntPtr data) {
            Pointers.glClearNamedBufferSubDataEXT(buffer, internalformat, offset, size, format, type, data);
        }
        
        public static void glClearNamedFramebufferfi(uint framebuffer, int buffer, int drawbuffer, float depth, int stencil) {
            Pointers.glClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
        }
        
        public static void glClearNamedFramebufferfv(uint framebuffer, int buffer, int drawbuffer, float* value) {
            Pointers.glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
        }
        
        public static void glClearNamedFramebufferfv(uint framebuffer, int buffer, int drawbuffer, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value_);
        }
        
        public static void glClearNamedFramebufferiv(uint framebuffer, int buffer, int drawbuffer, int* value) {
            Pointers.glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
        }
        
        public static void glClearNamedFramebufferiv(uint framebuffer, int buffer, int drawbuffer, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value_);
        }
        
        public static void glClearNamedFramebufferuiv(uint framebuffer, int buffer, int drawbuffer, uint* value) {
            Pointers.glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
        }
        
        public static void glClearNamedFramebufferuiv(uint framebuffer, int buffer, int drawbuffer, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value_);
        }
        
        public static void glClearPixelLocalStorageuiEXT(int offset, int n, uint* values) {
            Pointers.glClearPixelLocalStorageuiEXT(offset, n, values);
        }
        
        public static void glClearPixelLocalStorageuiEXT(int offset, int n, uint[] values) {
            fixed(uint* values_ = &values[0])
                Pointers.glClearPixelLocalStorageuiEXT(offset, n, values_);
        }
        
        /// <summary>
        /// specify the clear value for the stencil buffer
        /// <para>
        /// glClearStencil specifies the index used by glClear to clear the stencil buffer. s is masked with 2 m
        /// - 1 , where m is the number of bits in the stencil buffer
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specifies the index used when the stencil buffer is cleared. The initial value is 0.
        /// </param>
        public static void glClearStencil(int s) {
            Pointers.glClearStencil(s);
        }
        
        /// <summary>
        /// fills all a texture image with a constant value
        /// <para>
        /// glClearTexImage fills all an image contained in a texture with an application supplied value.
        /// texture must be the name of an existing texture. Further, texture may not be the name of a buffer
        /// texture, nor may its internal format be compressed
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// The name of an existing texture object containing the image to be cleared.
        /// </param>
        /// <param name="level">
        /// The level of texture containing the region to be cleared.
        /// </param>
        /// <param name="format">
        /// The format of the data whose address in memory is given by data.
        /// </param>
        /// <param name="type">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        /// <param name="data">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        public static void glClearTexImage(uint texture, int level, int format, int type, IntPtr data) {
            Pointers.glClearTexImage(texture, level, format, type, data);
        }
        
        /// <summary>
        /// fills all a texture image with a constant value
        /// <para>
        /// glClearTexImage fills all an image contained in a texture with an application supplied value.
        /// texture must be the name of an existing texture. Further, texture may not be the name of a buffer
        /// texture, nor may its internal format be compressed
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// The name of an existing texture object containing the image to be cleared.
        /// </param>
        /// <param name="level">
        /// The level of texture containing the region to be cleared.
        /// </param>
        /// <param name="format">
        /// The format of the data whose address in memory is given by data.
        /// </param>
        /// <param name="type">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        /// <param name="data">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        public static void glClearTexImageEXT(uint texture, int level, int format, int type, IntPtr data) {
            Pointers.glClearTexImageEXT(texture, level, format, type, data);
        }
        
        /// <summary>
        /// fills all or part of a texture image with a constant value
        /// <para>
        /// glClearTexSubImage fills all or part of an image contained in a texture with an application supplied
        /// value. texture must be the name of an existing texture. Further, texture may not be the name of a
        /// buffer texture, nor may its internal format be compressed
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// The name of an existing texture object containing the image to be cleared.
        /// </param>
        /// <param name="level">
        /// The level of texture containing the region to be cleared.
        /// </param>
        /// <param name="xoffset">
        /// The coordinate of the left edge of the region to be cleared.
        /// </param>
        /// <param name="yoffset">
        /// The coordinate of the lower edge of the region to be cleared.
        /// </param>
        /// <param name="zoffset">
        /// The coordinate of the front of the region to be cleared.
        /// </param>
        /// <param name="width">
        /// The width of the region to be cleared.
        /// </param>
        /// <param name="height">
        /// The height of the region to be cleared.
        /// </param>
        /// <param name="depth">
        /// The depth of the region to be cleared.
        /// </param>
        /// <param name="format">
        /// The format of the data whose address in memory is given by data.
        /// </param>
        /// <param name="type">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        /// <param name="data">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        public static void glClearTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr data) {
            Pointers.glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
        }
        
        /// <summary>
        /// fills all or part of a texture image with a constant value
        /// <para>
        /// glClearTexSubImage fills all or part of an image contained in a texture with an application supplied
        /// value. texture must be the name of an existing texture. Further, texture may not be the name of a
        /// buffer texture, nor may its internal format be compressed
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// The name of an existing texture object containing the image to be cleared.
        /// </param>
        /// <param name="level">
        /// The level of texture containing the region to be cleared.
        /// </param>
        /// <param name="xoffset">
        /// The coordinate of the left edge of the region to be cleared.
        /// </param>
        /// <param name="yoffset">
        /// The coordinate of the lower edge of the region to be cleared.
        /// </param>
        /// <param name="zoffset">
        /// The coordinate of the front of the region to be cleared.
        /// </param>
        /// <param name="width">
        /// The width of the region to be cleared.
        /// </param>
        /// <param name="height">
        /// The height of the region to be cleared.
        /// </param>
        /// <param name="depth">
        /// The depth of the region to be cleared.
        /// </param>
        /// <param name="format">
        /// The format of the data whose address in memory is given by data.
        /// </param>
        /// <param name="type">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        /// <param name="data">
        /// The type of the data whose address in memory is given by data.
        /// </param>
        public static void glClearTexSubImageEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr data) {
            Pointers.glClearTexSubImageEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
        }
        
        /// <summary>
        /// select active texture unit
        /// <para>
        /// glClientActiveTexture selects the vertex array client state parameters to be modified by
        /// glTexCoordPointer, and enabled or disabled with glEnableClientState or glDisableClientState,
        /// respectively, when called with a parameter of GL_TEXTURE_COORD_ARRAY
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies which texture unit to make active. The number of texture units is implementation
        /// dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to
        /// the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial
        /// value is GL_TEXTURE0.
        /// </param>
        public static void glClientActiveTexture(int texture) {
            Pointers.glClientActiveTexture(texture);
        }
        
        /// <summary>
        /// select active texture unit
        /// <para>
        /// glClientActiveTexture selects the vertex array client state parameters to be modified by
        /// glTexCoordPointer, and enabled or disabled with glEnableClientState or glDisableClientState,
        /// respectively, when called with a parameter of GL_TEXTURE_COORD_ARRAY
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies which texture unit to make active. The number of texture units is implementation
        /// dependent, but must be at least two. texture must be one of GL_TEXTUREi, where i ranges from 0 to
        /// the value of GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value. The initial
        /// value is GL_TEXTURE0.
        /// </param>
        public static void glClientActiveTextureARB(int texture) {
            Pointers.glClientActiveTextureARB(texture);
        }
        
        public static void glClientActiveVertexStreamATI(int stream) {
            Pointers.glClientActiveVertexStreamATI(stream);
        }
        
        public static void glClientAttribDefaultEXT(uint mask) {
            Pointers.glClientAttribDefaultEXT(mask);
        }
        
        public static void glClientAttribDefaultEXT(Enums.ClientAttribMask mask) {
            Pointers.glClientAttribDefaultEXT((uint)mask);
        }
        
        /// <summary>
        /// block and wait for a sync object to become signaled
        /// <para>
        /// glClientWaitSync causes the client to block and wait for the sync object specified by sync to become
        /// signaled. If sync is signaled when glClientWaitSync is called, glClientWaitSync returns immediately,
        /// otherwise it will block and wait for up to timeout nanoseconds for sync to become signaled
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// The sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </param>
        /// <param name="timeout">
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become
        /// signaled.
        /// </param>
        public static int glClientWaitSync(IntPtr sync, uint flags, ulong timeout) {
            return Pointers.glClientWaitSync(sync, flags, timeout);
        }
        
        /// <summary>
        /// block and wait for a sync object to become signaled
        /// <para>
        /// glClientWaitSync causes the client to block and wait for the sync object specified by sync to become
        /// signaled. If sync is signaled when glClientWaitSync is called, glClientWaitSync returns immediately,
        /// otherwise it will block and wait for up to timeout nanoseconds for sync to become signaled
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// The sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </param>
        /// <param name="timeout">
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become
        /// signaled.
        /// </param>
        public static int glClientWaitSync(IntPtr sync, Enums.SyncObjectMask flags, ulong timeout) {
            return Pointers.glClientWaitSync(sync, (uint)flags, timeout);
        }
        
        /// <summary>
        /// block and wait for a sync object to become signaled
        /// <para>
        /// glClientWaitSync causes the client to block and wait for the sync object specified by sync to become
        /// signaled. If sync is signaled when glClientWaitSync is called, glClientWaitSync returns immediately,
        /// otherwise it will block and wait for up to timeout nanoseconds for sync to become signaled
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// The sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </param>
        /// <param name="timeout">
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become
        /// signaled.
        /// </param>
        public static int glClientWaitSyncAPPLE(IntPtr sync, uint flags, ulong timeout) {
            return Pointers.glClientWaitSyncAPPLE(sync, flags, timeout);
        }
        
        /// <summary>
        /// block and wait for a sync object to become signaled
        /// <para>
        /// glClientWaitSync causes the client to block and wait for the sync object specified by sync to become
        /// signaled. If sync is signaled when glClientWaitSync is called, glClientWaitSync returns immediately,
        /// otherwise it will block and wait for up to timeout nanoseconds for sync to become signaled
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// The sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be GL_SYNC_FLUSH_COMMANDS_BIT.
        /// </param>
        /// <param name="timeout">
        /// The timeout, specified in nanoseconds, for which the implementation should wait for sync to become
        /// signaled.
        /// </param>
        public static int glClientWaitSyncAPPLE(IntPtr sync, Enums.SyncObjectMask flags, ulong timeout) {
            return Pointers.glClientWaitSyncAPPLE(sync, (uint)flags, timeout);
        }
        
        /// <summary>
        /// control clip coordinate to window coordinate behavior
        /// <para>
        /// glClipControl controls the clipping volume behavior and the clip coordinate to window coordinate
        /// transformation behavior
        /// </para>
        /// </summary>
        /// <param name="origin">
        /// Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT.
        /// </param>
        /// <param name="depth">
        /// Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE.
        /// </param>
        public static void glClipControl(int origin, int depth) {
            Pointers.glClipControl(origin, depth);
        }
        
        /// <summary>
        /// control clip coordinate to window coordinate behavior
        /// <para>
        /// glClipControl controls the clipping volume behavior and the clip coordinate to window coordinate
        /// transformation behavior
        /// </para>
        /// </summary>
        /// <param name="origin">
        /// Specifies the clip control origin. Must be one of GL_LOWER_LEFT or GL_UPPER_LEFT.
        /// </param>
        /// <param name="depth">
        /// Specifies the clip control depth mode. Must be one of GL_NEGATIVE_ONE_TO_ONE or GL_ZERO_TO_ONE.
        /// </param>
        public static void glClipControlEXT(int origin, int depth) {
            Pointers.glClipControlEXT(origin, depth);
        }
        
        /// <summary>
        /// specify a plane against which all geometry is clipped
        /// <para>
        /// Geometry is always clipped against the boundaries of a six-plane frustum in x, y, and z. glClipPlane
        /// allows the specification of additional planes, not necessarily perpendicular to the x, y, or z axis,
        /// against which all geometry is clipped. To determine the maximum number of additional clipping
        /// planes, call glGetIntegerv with argument GL_MAX_CLIP_PLANES. All implementations support at least
        /// six such clipping planes. Because the resulting clipping region is the intersection of the defined
        /// half-spaces, it is always convex
        /// </para>
        /// </summary>
        /// <param name="plane">
        /// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where
        /// i is an integer between 0 and GL_MAX_CLIP_PLANES -1 , are accepted.
        /// </param>
        /// <param name="equation">
        /// Specifies the address of an array of four double-precision floating-point values. These values are
        /// interpreted as a plane equation.
        /// </param>
        public static void glClipPlane(int plane, double* equation) {
            Pointers.glClipPlane(plane, equation);
        }
        
        /// <summary>
        /// specify a plane against which all geometry is clipped
        /// <para>
        /// Geometry is always clipped against the boundaries of a six-plane frustum in x, y, and z. glClipPlane
        /// allows the specification of additional planes, not necessarily perpendicular to the x, y, or z axis,
        /// against which all geometry is clipped. To determine the maximum number of additional clipping
        /// planes, call glGetIntegerv with argument GL_MAX_CLIP_PLANES. All implementations support at least
        /// six such clipping planes. Because the resulting clipping region is the intersection of the defined
        /// half-spaces, it is always convex
        /// </para>
        /// </summary>
        /// <param name="plane">
        /// Specifies which clipping plane is being positioned. Symbolic names of the form GL_CLIP_PLANEi, where
        /// i is an integer between 0 and GL_MAX_CLIP_PLANES -1 , are accepted.
        /// </param>
        /// <param name="equation">
        /// Specifies the address of an array of four double-precision floating-point values. These values are
        /// interpreted as a plane equation.
        /// </param>
        public static void glClipPlane(int plane, double[] equation) {
            fixed(double* equation_ = &equation[0])
                Pointers.glClipPlane(plane, equation_);
        }
        
        public static void glClipPlanef(int p, float* eqn) {
            Pointers.glClipPlanef(p, eqn);
        }
        
        public static void glClipPlanef(int p, float[] eqn) {
            fixed(float* eqn_ = &eqn[0])
                Pointers.glClipPlanef(p, eqn_);
        }
        
        public static void glClipPlanefIMG(int p, float* eqn) {
            Pointers.glClipPlanefIMG(p, eqn);
        }
        
        public static void glClipPlanefIMG(int p, float[] eqn) {
            fixed(float* eqn_ = &eqn[0])
                Pointers.glClipPlanefIMG(p, eqn_);
        }
        
        public static void glClipPlanefOES(int plane, float* equation) {
            Pointers.glClipPlanefOES(plane, equation);
        }
        
        public static void glClipPlanefOES(int plane, float[] equation) {
            fixed(float* equation_ = &equation[0])
                Pointers.glClipPlanefOES(plane, equation_);
        }
        
        public static void glClipPlanex(int plane, IntPtr* equation) {
            Pointers.glClipPlanex(plane, equation);
        }
        
        public static void glClipPlanex(int plane, IntPtr[] equation) {
            fixed(IntPtr* equation_ = &equation[0])
                Pointers.glClipPlanex(plane, equation_);
        }
        
        public static void glClipPlanexIMG(int p, IntPtr* eqn) {
            Pointers.glClipPlanexIMG(p, eqn);
        }
        
        public static void glClipPlanexIMG(int p, IntPtr[] eqn) {
            fixed(IntPtr* eqn_ = &eqn[0])
                Pointers.glClipPlanexIMG(p, eqn_);
        }
        
        public static void glClipPlanexOES(int plane, IntPtr* equation) {
            Pointers.glClipPlanexOES(plane, equation);
        }
        
        public static void glClipPlanexOES(int plane, IntPtr[] equation) {
            fixed(IntPtr* equation_ = &equation[0])
                Pointers.glClipPlanexOES(plane, equation_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3b(sbyte red, sbyte green, sbyte blue) {
            Pointers.glColor3b(red, green, blue);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3bv(sbyte* v) {
            Pointers.glColor3bv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3bv(sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glColor3bv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3d(double red, double green, double blue) {
            Pointers.glColor3d(red, green, blue);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3dv(double* v) {
            Pointers.glColor3dv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glColor3dv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3f(float red, float green, float blue) {
            Pointers.glColor3f(red, green, blue);
        }
        
        public static void glColor3fVertex3fSUN(float r, float g, float b, float x, float y, float z) {
            Pointers.glColor3fVertex3fSUN(r, g, b, x, y, z);
        }
        
        public static void glColor3fVertex3fvSUN(float* c, float* v) {
            Pointers.glColor3fVertex3fvSUN(c, v);
        }
        
        public static void glColor3fVertex3fvSUN(float* c, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glColor3fVertex3fvSUN(c, v_);
        }
        
        public static void glColor3fVertex3fvSUN(float[] c, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glColor3fVertex3fvSUN(c_, v);
        }
        
        public static void glColor3fVertex3fvSUN(float[] c, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glColor3fVertex3fvSUN(c_, v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3fv(float* v) {
            Pointers.glColor3fv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glColor3fv(v_);
        }
        
        public static void glColor3hNV(short red, short green, short blue) {
            Pointers.glColor3hNV(red, green, blue);
        }
        
        public static void glColor3hvNV(short* v) {
            Pointers.glColor3hvNV(v);
        }
        
        public static void glColor3hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glColor3hvNV(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3i(int red, int green, int blue) {
            Pointers.glColor3i(red, green, blue);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3iv(int* v) {
            Pointers.glColor3iv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glColor3iv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3s(short red, short green, short blue) {
            Pointers.glColor3s(red, green, blue);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3sv(short* v) {
            Pointers.glColor3sv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glColor3sv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3ub(byte red, byte green, byte blue) {
            Pointers.glColor3ub(red, green, blue);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3ubv(byte* v) {
            Pointers.glColor3ubv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3ubv(byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glColor3ubv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3ui(uint red, uint green, uint blue) {
            Pointers.glColor3ui(red, green, blue);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3uiv(uint* v) {
            Pointers.glColor3uiv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3uiv(uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glColor3uiv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        public static void glColor3us(ushort red, ushort green, ushort blue) {
            Pointers.glColor3us(red, green, blue);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3usv(ushort* v) {
            Pointers.glColor3usv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor3usv(ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glColor3usv(v_);
        }
        
        public static void glColor3xOES(IntPtr red, IntPtr green, IntPtr blue) {
            Pointers.glColor3xOES(red, green, blue);
        }
        
        public static void glColor3xvOES(IntPtr* components) {
            Pointers.glColor3xvOES(components);
        }
        
        public static void glColor3xvOES(IntPtr[] components) {
            fixed(IntPtr* components_ = &components[0])
                Pointers.glColor3xvOES(components_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4b(sbyte red, sbyte green, sbyte blue, sbyte alpha) {
            Pointers.glColor4b(red, green, blue, alpha);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4bv(sbyte* v) {
            Pointers.glColor4bv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4bv(sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glColor4bv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4d(double red, double green, double blue, double alpha) {
            Pointers.glColor4d(red, green, blue, alpha);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4dv(double* v) {
            Pointers.glColor4dv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glColor4dv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4f(float red, float green, float blue, float alpha) {
            Pointers.glColor4f(red, green, blue, alpha);
        }
        
        public static void glColor4fNormal3fVertex3fSUN(float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glColor4fNormal3fVertex3fSUN(r, g, b, a, nx, ny, nz, x, y, z);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float* c, float* n, float* v) {
            Pointers.glColor4fNormal3fVertex3fvSUN(c, n, v);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float* c, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glColor4fNormal3fVertex3fvSUN(c, n, v_);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float* c, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glColor4fNormal3fVertex3fvSUN(c, n_, v);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float* c, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glColor4fNormal3fVertex3fvSUN(c, n_, v_);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float[] c, float* n, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glColor4fNormal3fVertex3fvSUN(c_, n, v);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float[] c, float* n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glColor4fNormal3fVertex3fvSUN(c_, n, v_);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float[] c, float[] n, float* v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glColor4fNormal3fVertex3fvSUN(c_, n_, v);
        }
        
        public static void glColor4fNormal3fVertex3fvSUN(float[] c, float[] n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glColor4fNormal3fVertex3fvSUN(c_, n_, v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4fv(float* v) {
            Pointers.glColor4fv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glColor4fv(v_);
        }
        
        public static void glColor4hNV(short red, short green, short blue, short alpha) {
            Pointers.glColor4hNV(red, green, blue, alpha);
        }
        
        public static void glColor4hvNV(short* v) {
            Pointers.glColor4hvNV(v);
        }
        
        public static void glColor4hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glColor4hvNV(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4i(int red, int green, int blue, int alpha) {
            Pointers.glColor4i(red, green, blue, alpha);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4iv(int* v) {
            Pointers.glColor4iv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glColor4iv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4s(short red, short green, short blue, short alpha) {
            Pointers.glColor4s(red, green, blue, alpha);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4sv(short* v) {
            Pointers.glColor4sv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glColor4sv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4ub(byte red, byte green, byte blue, byte alpha) {
            Pointers.glColor4ub(red, green, blue, alpha);
        }
        
        public static void glColor4ubVertex2fSUN(byte r, byte g, byte b, byte a, float x, float y) {
            Pointers.glColor4ubVertex2fSUN(r, g, b, a, x, y);
        }
        
        public static void glColor4ubVertex2fvSUN(byte* c, float* v) {
            Pointers.glColor4ubVertex2fvSUN(c, v);
        }
        
        public static void glColor4ubVertex2fvSUN(byte* c, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glColor4ubVertex2fvSUN(c, v_);
        }
        
        public static void glColor4ubVertex2fvSUN(byte[] c, float* v) {
            fixed(byte* c_ = &c[0])
                Pointers.glColor4ubVertex2fvSUN(c_, v);
        }
        
        public static void glColor4ubVertex2fvSUN(byte[] c, float[] v) {
            fixed(byte* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glColor4ubVertex2fvSUN(c_, v_);
        }
        
        public static void glColor4ubVertex3fSUN(byte r, byte g, byte b, byte a, float x, float y, float z) {
            Pointers.glColor4ubVertex3fSUN(r, g, b, a, x, y, z);
        }
        
        public static void glColor4ubVertex3fvSUN(byte* c, float* v) {
            Pointers.glColor4ubVertex3fvSUN(c, v);
        }
        
        public static void glColor4ubVertex3fvSUN(byte* c, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glColor4ubVertex3fvSUN(c, v_);
        }
        
        public static void glColor4ubVertex3fvSUN(byte[] c, float* v) {
            fixed(byte* c_ = &c[0])
                Pointers.glColor4ubVertex3fvSUN(c_, v);
        }
        
        public static void glColor4ubVertex3fvSUN(byte[] c, float[] v) {
            fixed(byte* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glColor4ubVertex3fvSUN(c_, v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4ubv(byte* v) {
            Pointers.glColor4ubv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4ubv(byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glColor4ubv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4ui(uint red, uint green, uint blue, uint alpha) {
            Pointers.glColor4ui(red, green, blue, alpha);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4uiv(uint* v) {
            Pointers.glColor4uiv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4uiv(uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glColor4uiv(v_);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current color.
        /// </param>
        /// <param name="alpha">
        /// Specifies a new alpha value for the current color. Included only in the four-argument glColor4
        /// commands.
        /// </param>
        public static void glColor4us(ushort red, ushort green, ushort blue, ushort alpha) {
            Pointers.glColor4us(red, green, blue, alpha);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4usv(ushort* v) {
            Pointers.glColor4usv(v);
        }
        
        /// <summary>
        /// set the current color
        /// <para>
        /// The GL stores both a current single-valued color index and a current four-valued RGBA color. glColor
        /// sets a new four-valued RGBA color. glColor has two major variants: glColor3 and glColor4. glColor3
        /// variants specify new red, green, and blue values explicitly and set the current alpha value to 1.0
        /// (full intensity) implicitly. glColor4 variants specify all four color components explicitly
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue, and (sometimes) alpha values.
        /// </param>
        public static void glColor4usv(ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glColor4usv(v_);
        }
        
        public static void glColor4x(IntPtr red, IntPtr green, IntPtr blue, IntPtr alpha) {
            Pointers.glColor4x(red, green, blue, alpha);
        }
        
        public static void glColor4xOES(IntPtr red, IntPtr green, IntPtr blue, IntPtr alpha) {
            Pointers.glColor4xOES(red, green, blue, alpha);
        }
        
        public static void glColor4xvOES(IntPtr* components) {
            Pointers.glColor4xvOES(components);
        }
        
        public static void glColor4xvOES(IntPtr[] components) {
            fixed(IntPtr* components_ = &components[0])
                Pointers.glColor4xvOES(components_);
        }
        
        public static void glColorFormatNV(int size, int type, int stride) {
            Pointers.glColorFormatNV(size, type, stride);
        }
        
        public static void glColorFragmentOp1ATI(int op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod) {
            Pointers.glColorFragmentOp1ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod);
        }
        
        public static void glColorFragmentOp2ATI(int op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod) {
            Pointers.glColorFragmentOp2ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod);
        }
        
        public static void glColorFragmentOp3ATI(int op, uint dst, uint dstMask, uint dstMod, uint arg1, uint arg1Rep, uint arg1Mod, uint arg2, uint arg2Rep, uint arg2Mod, uint arg3, uint arg3Rep, uint arg3Mod) {
            Pointers.glColorFragmentOp3ATI(op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod);
        }
        
        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>
        /// glColorMask and glColorMaski specify whether the individual color components in the frame buffer can
        /// or cannot be written. glColorMaski sets the mask for a specific draw buffer, whereas glColorMask
        /// sets the mask for all draw buffers. If red is GL_FALSE, for example, no change is made to the red
        /// component of any pixel in any of the color buffers, regardless of the drawing operation attempted
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="green">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="blue">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="alpha">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        public static void glColorMask(bool red, bool green, bool blue, bool alpha) {
            Pointers.glColorMask(red, green, blue, alpha);
        }
        
        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>
        /// glColorMask and glColorMaski specify whether the individual color components in the frame buffer can
        /// or cannot be written. glColorMaski sets the mask for a specific draw buffer, whereas glColorMask
        /// sets the mask for all draw buffers. If red is GL_FALSE, for example, no change is made to the red
        /// component of any pixel in any of the color buffers, regardless of the drawing operation attempted
        /// </para>
        /// </summary>
        /// <param name="index">
        /// For glColorMaski, specifies the index of the draw buffer whose color mask to set.
        /// </param>
        /// <param name="r">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="g">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="b">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="a">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        public static void glColorMaskIndexedEXT(uint index, bool r, bool g, bool b, bool a) {
            Pointers.glColorMaskIndexedEXT(index, r, g, b, a);
        }
        
        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>
        /// glColorMask and glColorMaski specify whether the individual color components in the frame buffer can
        /// or cannot be written. glColorMaski sets the mask for a specific draw buffer, whereas glColorMask
        /// sets the mask for all draw buffers. If red is GL_FALSE, for example, no change is made to the red
        /// component of any pixel in any of the color buffers, regardless of the drawing operation attempted
        /// </para>
        /// </summary>
        /// <param name="index">
        /// For glColorMaski, specifies the index of the draw buffer whose color mask to set.
        /// </param>
        /// <param name="r">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="g">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="b">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="a">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        public static void glColorMaski(uint index, bool r, bool g, bool b, bool a) {
            Pointers.glColorMaski(index, r, g, b, a);
        }
        
        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>
        /// glColorMask and glColorMaski specify whether the individual color components in the frame buffer can
        /// or cannot be written. glColorMaski sets the mask for a specific draw buffer, whereas glColorMask
        /// sets the mask for all draw buffers. If red is GL_FALSE, for example, no change is made to the red
        /// component of any pixel in any of the color buffers, regardless of the drawing operation attempted
        /// </para>
        /// </summary>
        /// <param name="index">
        /// For glColorMaski, specifies the index of the draw buffer whose color mask to set.
        /// </param>
        /// <param name="r">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="g">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="b">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="a">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        public static void glColorMaskiEXT(uint index, bool r, bool g, bool b, bool a) {
            Pointers.glColorMaskiEXT(index, r, g, b, a);
        }
        
        /// <summary>
        /// enable and disable writing of frame buffer color components
        /// <para>
        /// glColorMask and glColorMaski specify whether the individual color components in the frame buffer can
        /// or cannot be written. glColorMaski sets the mask for a specific draw buffer, whereas glColorMask
        /// sets the mask for all draw buffers. If red is GL_FALSE, for example, no change is made to the red
        /// component of any pixel in any of the color buffers, regardless of the drawing operation attempted
        /// </para>
        /// </summary>
        /// <param name="index">
        /// For glColorMaski, specifies the index of the draw buffer whose color mask to set.
        /// </param>
        /// <param name="r">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="g">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="b">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        /// <param name="a">
        /// Specify whether red, green, blue, and alpha are to be written into the frame buffer. The initial
        /// values are all GL_TRUE, indicating that the color components are written.
        /// </param>
        public static void glColorMaskiOES(uint index, bool r, bool g, bool b, bool a) {
            Pointers.glColorMaskiOES(index, r, g, b, a);
        }
        
        /// <summary>
        /// cause a material color to track the current color
        /// <para>
        /// glColorMaterial specifies which material parameters track the current color. When GL_COLOR_MATERIAL
        /// is enabled, the material parameter or parameters specified by mode, of the material or materials
        /// specified by face, track the current color at all times
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies whether front, back, or both front and back material parameters should track the current
        /// color. Accepted values are GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK. The initial value is
        /// GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="mode">
        /// Specifies which of several material parameters track the current color. Accepted values are
        /// GL_EMISSION, GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, and GL_AMBIENT_AND_DIFFUSE. The initial value is
        /// GL_AMBIENT_AND_DIFFUSE.
        /// </param>
        public static void glColorMaterial(int face, int mode) {
            Pointers.glColorMaterial(face, mode);
        }
        
        public static void glColorP3ui(int type, uint color) {
            Pointers.glColorP3ui(type, color);
        }
        
        public static void glColorP3uiv(int type, uint* color) {
            Pointers.glColorP3uiv(type, color);
        }
        
        public static void glColorP3uiv(int type, out uint color) {
            fixed(uint* color_ = &color)
                Pointers.glColorP3uiv(type, color_);
        }
        
        public static void glColorP4ui(int type, uint color) {
            Pointers.glColorP4ui(type, color);
        }
        
        public static void glColorP4uiv(int type, uint* color) {
            Pointers.glColorP4uiv(type, color);
        }
        
        public static void glColorP4uiv(int type, out uint color) {
            fixed(uint* color_ = &color)
                Pointers.glColorP4uiv(type, color_);
        }
        
        /// <summary>
        /// define an array of colors
        /// <para>
        /// glColorPointer specifies the location and data format of an array of color components to use when
        /// rendering. size specifies the number of components per color, and must be 3 or 4. type specifies the
        /// data type of each color component, and stride specifies the byte stride from one color to the next,
        /// allowing vertices and attributes to be packed into a single array or stored in separate arrays.
        /// (Single-array storage may be more efficient on some implementations; see glInterleavedArrays.)
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the number of components per color. Must be 3 or 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE,
        /// GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, and GL_DOUBLE are
        /// accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to
        /// be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first component of the first color element in the array. The initial
        /// value is 0.
        /// </param>
        public static void glColorPointer(int size, int type, int stride, IntPtr pointer) {
            Pointers.glColorPointer(size, type, stride, pointer);
        }
        
        public static void glColorPointerEXT(int size, int type, int stride, int count, IntPtr pointer) {
            Pointers.glColorPointerEXT(size, type, stride, count, pointer);
        }
        
        public static void glColorPointerListIBM(int size, int type, int stride, IntPtr* pointer, int ptrstride) {
            Pointers.glColorPointerListIBM(size, type, stride, pointer, ptrstride);
        }
        
        public static void glColorPointerListIBM(int size, int type, int stride, IntPtr[] pointer, int ptrstride) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glColorPointerListIBM(size, type, stride, pointer_, ptrstride);
        }
        
        public static void glColorPointervINTEL(int size, int type, IntPtr* pointer) {
            Pointers.glColorPointervINTEL(size, type, pointer);
        }
        
        public static void glColorPointervINTEL(int size, int type, IntPtr[] pointer) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glColorPointervINTEL(size, type, pointer_);
        }
        
        /// <summary>
        /// respecify a portion of a color table
        /// <para>
        /// glColorSubTable is used to respecify a contiguous portion of a color table previously defined using
        /// glColorTable. The pixels referenced by data replace the portion of the existing table from indices
        /// start to start + count - 1 , inclusive. This region may not include any entries outside the range of
        /// the color table as it was originally specified. It is not an error to specify a subtexture with
        /// width of 0, but such a specification has no effect
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="count">
        /// The number of table entries to replace.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="data">
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        public static void glColorSubTable(int target, int start, int count, int format, int type, IntPtr data) {
            Pointers.glColorSubTable(target, start, count, format, type, data);
        }
        
        /// <summary>
        /// respecify a portion of a color table
        /// <para>
        /// glColorSubTable is used to respecify a contiguous portion of a color table previously defined using
        /// glColorTable. The pixels referenced by data replace the portion of the existing table from indices
        /// start to start + count - 1 , inclusive. This region may not include any entries outside the range of
        /// the color table as it was originally specified. It is not an error to specify a subtexture with
        /// width of 0, but such a specification has no effect
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="count">
        /// The number of table entries to replace.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="data">
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        public static void glColorSubTableEXT(int target, int start, int count, int format, int type, IntPtr data) {
            Pointers.glColorSubTableEXT(target, start, count, format, type, data);
        }
        
        /// <summary>
        /// define a color lookup table
        /// <para>
        /// glColorTable may be used in two ways: to test the actual size and color resolution of a lookup table
        /// given a particular set of parameters, or to load the contents of a color lookup table. Use the
        /// targets GL_PROXY_* for the first case and the other targets for the second case
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE,
        /// GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
        /// GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16,
        /// GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,
        /// GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4,
        /// GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8,
        /// GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2,
        /// GL_RGBA12, and GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The number of entries in the color lookup table specified by data.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="table">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        public static void glColorTable(int target, int internalformat, int width, int format, int type, IntPtr table) {
            Pointers.glColorTable(target, internalformat, width, format, type, table);
        }
        
        /// <summary>
        /// define a color lookup table
        /// <para>
        /// glColorTable may be used in two ways: to test the actual size and color resolution of a lookup table
        /// given a particular set of parameters, or to load the contents of a color lookup table. Use the
        /// targets GL_PROXY_* for the first case and the other targets for the second case
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE,
        /// GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="internalFormat">
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
        /// GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16,
        /// GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,
        /// GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4,
        /// GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8,
        /// GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2,
        /// GL_RGBA12, and GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The number of entries in the color lookup table specified by data.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="table">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        public static void glColorTableEXT(int target, int internalFormat, int width, int format, int type, IntPtr table) {
            Pointers.glColorTableEXT(target, internalFormat, width, format, type, table);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameterfv(int target, int pname, float* _params) {
            Pointers.glColorTableParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glColorTableParameterfv(target, pname, _params_);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameterfvSGI(int target, int pname, float* _params) {
            Pointers.glColorTableParameterfvSGI(target, pname, _params);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameterfvSGI(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glColorTableParameterfvSGI(target, pname, _params_);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameteriv(int target, int pname, int* _params) {
            Pointers.glColorTableParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glColorTableParameteriv(target, pname, _params_);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameterivSGI(int target, int pname, int* _params) {
            Pointers.glColorTableParameterivSGI(target, pname, _params);
        }
        
        /// <summary>
        /// set color lookup table parameters
        /// <para>
        /// glColorTableParameter is used to specify the scale factors and bias terms applied to color
        /// components when they are loaded into a color table. target indicates which color table the scale and
        /// bias terms apply to; it must be set to GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a texture color lookup table parameter. Must be one of GL_COLOR_TABLE_SCALE or
        /// GL_COLOR_TABLE_BIAS.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameters are stored.
        /// </param>
        public static void glColorTableParameterivSGI(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glColorTableParameterivSGI(target, pname, _params_);
        }
        
        /// <summary>
        /// define a color lookup table
        /// <para>
        /// glColorTable may be used in two ways: to test the actual size and color resolution of a lookup table
        /// given a particular set of parameters, or to load the contents of a color lookup table. Use the
        /// targets GL_PROXY_* for the first case and the other targets for the second case
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, GL_POST_COLOR_MATRIX_COLOR_TABLE,
        /// GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the color table. The allowable values are GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
        /// GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16,
        /// GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,
        /// GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_INTENSITY, GL_INTENSITY4,
        /// GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB, GL_RGB4, GL_RGB5, GL_RGB8,
        /// GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8, GL_RGB10_A2,
        /// GL_RGBA12, and GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The number of entries in the color lookup table specified by data.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. The allowable values are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="table">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        public static void glColorTableSGI(int target, int internalformat, int width, int format, int type, IntPtr table) {
            Pointers.glColorTableSGI(target, internalformat, width, format, type, table);
        }
        
        public static void glCombinerInputNV(int stage, int portion, int variable, int input, int mapping, int componentUsage) {
            Pointers.glCombinerInputNV(stage, portion, variable, input, mapping, componentUsage);
        }
        
        public static void glCombinerOutputNV(int stage, int portion, int abOutput, int cdOutput, int sumOutput, int scale, int bias, bool abDotProduct, bool cdDotProduct, bool muxSum) {
            Pointers.glCombinerOutputNV(stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum);
        }
        
        public static void glCombinerParameterfNV(int pname, float param) {
            Pointers.glCombinerParameterfNV(pname, param);
        }
        
        public static void glCombinerParameterfvNV(int pname, float* _params) {
            Pointers.glCombinerParameterfvNV(pname, _params);
        }
        
        public static void glCombinerParameterfvNV(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glCombinerParameterfvNV(pname, _params_);
        }
        
        public static void glCombinerParameteriNV(int pname, int param) {
            Pointers.glCombinerParameteriNV(pname, param);
        }
        
        public static void glCombinerParameterivNV(int pname, int* _params) {
            Pointers.glCombinerParameterivNV(pname, _params);
        }
        
        public static void glCombinerParameterivNV(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glCombinerParameterivNV(pname, _params_);
        }
        
        public static void glCombinerStageParameterfvNV(int stage, int pname, float* _params) {
            Pointers.glCombinerStageParameterfvNV(stage, pname, _params);
        }
        
        public static void glCombinerStageParameterfvNV(int stage, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glCombinerStageParameterfvNV(stage, pname, _params_);
        }
        
        public static void glCommandListSegmentsNV(uint list, uint segments) {
            Pointers.glCommandListSegmentsNV(list, segments);
        }
        
        public static void glCompileCommandListNV(uint list) {
            Pointers.glCompileCommandListNV(list);
        }
        
        /// <summary>
        /// Compiles a shader object
        /// <para>
        /// glCompileShader compiles the source code strings that have been stored in the shader object
        /// specified by shader
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be compiled.
        /// </param>
        public static void glCompileShader(uint shader) {
            Pointers.glCompileShader(shader);
        }
        
        /// <summary>
        /// Compiles a shader object
        /// <para>
        /// glCompileShader compiles the source code strings that have been stored in the shader object
        /// specified by shader
        /// </para>
        /// </summary>
        /// <param name="shaderObj">
        /// Specifies the shader object to be compiled.
        /// </param>
        public static void glCompileShaderARB(uint shaderObj) {
            Pointers.glCompileShaderARB(shaderObj);
        }
        
        public static void glCompileShaderIncludeARB(uint shader, int count, string[] path, int* length) {
            Pointers.glCompileShaderIncludeARB(shader, count, path, length);
        }
        
        public static void glCompileShaderIncludeARB(uint shader, int count, string[] path, int[] length) {
            fixed(int* length_ = &length[0])
                Pointers.glCompileShaderIncludeARB(shader, count, path, length_);
        }
        
        public static void glCompressedMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int width, int border, int imageSize, IntPtr bits) {
            Pointers.glCompressedMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, imageSize, bits);
        }
        
        public static void glCompressedMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int width, int height, int border, int imageSize, IntPtr bits) {
            Pointers.glCompressedMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, imageSize, bits);
        }
        
        public static void glCompressedMultiTexImage3DEXT(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits) {
            Pointers.glCompressedMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, imageSize, bits);
        }
        
        public static void glCompressedMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int width, int format, int imageSize, IntPtr bits) {
            Pointers.glCompressedMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, imageSize, bits);
        }
        
        public static void glCompressedMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr bits) {
            Pointers.glCompressedMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
        }
        
        public static void glCompressedMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr bits) {
            Pointers.glCompressedMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
        }
        
        /// <summary>
        /// specify a one-dimensional texture image in a compressed format
        /// <para>
        /// Texturing allows elements of an image array to be read by shaders
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at
        /// least 64 texels wide. The height of the 1D texture image is 1.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the width of the texture image. All implementations support texture images that are at
        /// least 64 texels wide. The height of the 1D texture image is 1.
        /// </param>
        public static void glCompressedTexImage1D(int target, int level, int internalformat, int width, int border, int imageSize, IntPtr data) {
            Pointers.glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
        }
        
        /// <summary>
        /// specify a one-dimensional texture image in a compressed format
        /// <para>
        /// Texturing allows elements of an image array to be read by shaders
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at
        /// least 64 texels wide. The height of the 1D texture image is 1.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the width of the texture image. All implementations support texture images that are at
        /// least 64 texels wide. The height of the 1D texture image is 1.
        /// </param>
        public static void glCompressedTexImage1DARB(int target, int level, int internalformat, int width, int border, int imageSize, IntPtr data) {
            Pointers.glCompressedTexImage1DARB(target, level, internalformat, width, border, imageSize, data);
        }
        
        /// <summary>
        /// specify a two-dimensional texture image in a compressed format
        /// <para>
        /// Texturing allows elements of an image array to be read by shaders
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY,
        /// GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map
        /// texture images that are at least 16384 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map
        /// texture images that are at least 16384 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map
        /// texture images that are at least 16384 texels wide.
        /// </param>
        public static void glCompressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, int imageSize, IntPtr data) {
            Pointers.glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
        }
        
        /// <summary>
        /// specify a two-dimensional texture image in a compressed format
        /// <para>
        /// Texturing allows elements of an image array to be read by shaders
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY,
        /// GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map
        /// texture images that are at least 16384 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 2D texture and cube map
        /// texture images that are at least 16384 texels high.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the width of the texture image. All implementations support 2D texture and cube map
        /// texture images that are at least 16384 texels wide.
        /// </param>
        public static void glCompressedTexImage2DARB(int target, int level, int internalformat, int width, int height, int border, int imageSize, IntPtr data) {
            Pointers.glCompressedTexImage2DARB(target, level, internalformat, width, height, border, imageSize, data);
        }
        
        /// <summary>
        /// specify a three-dimensional texture image in a compressed format
        /// <para>
        /// Texturing allows elements of an image array to be read by shaders
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or
        /// GL_PROXY_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels wide.
        /// </param>
        public static void glCompressedTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) {
            Pointers.glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
        }
        
        /// <summary>
        /// specify a three-dimensional texture image in a compressed format
        /// <para>
        /// Texturing allows elements of an image array to be read by shaders
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY or
        /// GL_PROXY_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels wide.
        /// </param>
        public static void glCompressedTexImage3DARB(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) {
            Pointers.glCompressedTexImage3DARB(target, level, internalformat, width, height, depth, border, imageSize, data);
        }
        
        public static void glCompressedTexImage3DOES(int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr data) {
            Pointers.glCompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function. Must be
        /// GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        public static void glCompressedTexSubImage1D(int target, int level, int xoffset, int width, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target, to which the texture is bound, for glCompressedTexSubImage1D function. Must be
        /// GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        public static void glCompressedTexSubImage1DARB(int target, int level, int xoffset, int width, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTexSubImage1DARB(target, level, xoffset, width, format, imageSize, data);
        }
        
        /// <summary>
        /// specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glCompressedTexSubImage2D function. Must be
        /// GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        public static void glCompressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        
        /// <summary>
        /// specify a two-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glCompressedTexSubImage2D function. Must be
        /// GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        public static void glCompressedTexSubImage2DARB(int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTexSubImage2DARB(target, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        
        /// <summary>
        /// specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glCompressedTexSubImage3D function. Must be
        /// GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset"> </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        public static void glCompressedTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        
        /// <summary>
        /// specify a three-dimensional texture subimage in a compressed format
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glCompressedTexSubImage3D function. Must be
        /// GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, or GL_TEXTURE_CUBE_MAP_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset"> </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the compressed image data stored at address data.
        /// </param>
        /// <param name="imageSize">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        /// <param name="data">
        /// Specifies the number of unsigned bytes of image data starting at the address specified by data.
        /// </param>
        public static void glCompressedTexSubImage3DARB(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTexSubImage3DARB(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        
        public static void glCompressedTexSubImage3DOES(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        
        public static void glCompressedTextureImage1DEXT(uint texture, int target, int level, int internalformat, int width, int border, int imageSize, IntPtr bits) {
            Pointers.glCompressedTextureImage1DEXT(texture, target, level, internalformat, width, border, imageSize, bits);
        }
        
        public static void glCompressedTextureImage2DEXT(uint texture, int target, int level, int internalformat, int width, int height, int border, int imageSize, IntPtr bits) {
            Pointers.glCompressedTextureImage2DEXT(texture, target, level, internalformat, width, height, border, imageSize, bits);
        }
        
        public static void glCompressedTextureImage3DEXT(uint texture, int target, int level, int internalformat, int width, int height, int depth, int border, int imageSize, IntPtr bits) {
            Pointers.glCompressedTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, imageSize, bits);
        }
        
        public static void glCompressedTextureSubImage1D(uint texture, int level, int xoffset, int width, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
        }
        
        public static void glCompressedTextureSubImage1DEXT(uint texture, int target, int level, int xoffset, int width, int format, int imageSize, IntPtr bits) {
            Pointers.glCompressedTextureSubImage1DEXT(texture, target, level, xoffset, width, format, imageSize, bits);
        }
        
        public static void glCompressedTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
        }
        
        public static void glCompressedTextureSubImage2DEXT(uint texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int imageSize, IntPtr bits) {
            Pointers.glCompressedTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits);
        }
        
        public static void glCompressedTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr data) {
            Pointers.glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
        }
        
        public static void glCompressedTextureSubImage3DEXT(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int imageSize, IntPtr bits) {
            Pointers.glCompressedTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits);
        }
        
        public static void glConservativeRasterParameterfNV(int pname, float value) {
            Pointers.glConservativeRasterParameterfNV(pname, value);
        }
        
        public static void glConservativeRasterParameteriNV(int pname, int param) {
            Pointers.glConservativeRasterParameteriNV(pname, param);
        }
        
        /// <summary>
        /// define a one-dimensional convolution filter
        /// <para>
        /// glConvolutionFilter1D builds a one-dimensional convolution filter kernel from an array of pixels
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_1D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by data.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE,
        /// GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="image">
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE,
        /// GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </param>
        public static void glConvolutionFilter1D(int target, int internalformat, int width, int format, int type, IntPtr image) {
            Pointers.glConvolutionFilter1D(target, internalformat, width, format, type, image);
        }
        
        /// <summary>
        /// define a one-dimensional convolution filter
        /// <para>
        /// glConvolutionFilter1D builds a one-dimensional convolution filter kernel from an array of pixels
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_1D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by data.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE,
        /// GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="image">
        /// The format of the pixel data in data. The allowable values are GL_ALPHA, GL_LUMINANCE,
        /// GL_LUMINANCE_ALPHA, GL_INTENSITY, GL_RGB, and GL_RGBA.
        /// </param>
        public static void glConvolutionFilter1DEXT(int target, int internalformat, int width, int format, int type, IntPtr image) {
            Pointers.glConvolutionFilter1DEXT(target, internalformat, width, format, type, image);
        }
        
        /// <summary>
        /// define a two-dimensional convolution filter
        /// <para>
        /// glConvolutionFilter2D builds a two-dimensional convolution filter kernel from an array of pixels
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_2D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by data.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array referenced by data.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="image">
        /// The height of the pixel array referenced by data.
        /// </param>
        public static void glConvolutionFilter2D(int target, int internalformat, int width, int height, int format, int type, IntPtr image) {
            Pointers.glConvolutionFilter2D(target, internalformat, width, height, format, type, image);
        }
        
        /// <summary>
        /// define a two-dimensional convolution filter
        /// <para>
        /// glConvolutionFilter2D builds a two-dimensional convolution filter kernel from an array of pixels
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_2D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array referenced by data.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array referenced by data.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in data. The allowable values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="image">
        /// The height of the pixel array referenced by data.
        /// </param>
        public static void glConvolutionFilter2DEXT(int target, int internalformat, int width, int height, int format, int type, IntPtr image) {
            Pointers.glConvolutionFilter2DEXT(target, internalformat, width, height, format, type, image);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterf(int target, int pname, float _params) {
            Pointers.glConvolutionParameterf(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterfEXT(int target, int pname, float _params) {
            Pointers.glConvolutionParameterfEXT(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterfv(int target, int pname, float* _params) {
            Pointers.glConvolutionParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glConvolutionParameterfv(target, pname, _params_);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterfvEXT(int target, int pname, float* _params) {
            Pointers.glConvolutionParameterfvEXT(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterfvEXT(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glConvolutionParameterfvEXT(target, pname, _params_);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameteri(int target, int pname, int _params) {
            Pointers.glConvolutionParameteri(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameteriEXT(int target, int pname, int _params) {
            Pointers.glConvolutionParameteriEXT(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameteriv(int target, int pname, int* _params) {
            Pointers.glConvolutionParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glConvolutionParameteriv(target, pname, _params_);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterivEXT(int target, int pname, int* _params) {
            Pointers.glConvolutionParameterivEXT(target, pname, _params);
        }
        
        /// <summary>
        /// set convolution parameters
        /// <para>
        /// glConvolutionParameter sets the value of a convolution parameter
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target for the convolution parameter. Must be one of GL_CONVOLUTION_1D, GL_CONVOLUTION_2D, or
        /// GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be set. Must be GL_CONVOLUTION_BORDER_MODE.
        /// </param>
        /// <param name="_params">
        /// The parameter value. Must be one of GL_REDUCE, GL_CONSTANT_BORDER, GL_REPLICATE_BORDER.
        /// </param>
        public static void glConvolutionParameterivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glConvolutionParameterivEXT(target, pname, _params_);
        }
        
        public static void glConvolutionParameterxOES(int target, int pname, IntPtr param) {
            Pointers.glConvolutionParameterxOES(target, pname, param);
        }
        
        public static void glConvolutionParameterxvOES(int target, int pname, IntPtr* _params) {
            Pointers.glConvolutionParameterxvOES(target, pname, _params);
        }
        
        public static void glConvolutionParameterxvOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glConvolutionParameterxvOES(target, pname, _params_);
        }
        
        /// <summary>
        /// copy all or part of the data store of a buffer object to the data store of another buffer object
        /// <para>
        /// glCopyBufferSubData and glCopyNamedBufferSubData copy part of the data store attached to a source
        /// buffer object to the data store attached to a destination buffer object. The number of basic machine
        /// units indicated by size is copied from the source at offset readOffset to the destination at
        /// writeOffset. readOffset, writeOffset and size are in terms of basic machine units
        /// </para>
        /// </summary>
        /// <param name="readTarget">
        /// Specifies the target to which the source buffer object is bound for glCopyBufferSubData
        /// </param>
        /// <param name="writeTarget">
        /// Specifies the target to which the destination buffer object is bound for glCopyBufferSubData.
        /// </param>
        /// <param name="readOffset">
        /// Specifies the offset, in basic machine units, within the data store of the source buffer object at
        /// which data will be read.
        /// </param>
        /// <param name="writeOffset">
        /// Specifies the offset, in basic machine units, within the data store of the destination buffer object
        /// at which data will be written.
        /// </param>
        /// <param name="size">
        /// Specifies the size, in basic machine units, of the data to be copied from the source buffer object
        /// to the destination buffer object.
        /// </param>
        public static void glCopyBufferSubData(int readTarget, int writeTarget, uint readOffset, uint writeOffset, uint size) {
            Pointers.glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
        }
        
        /// <summary>
        /// copy all or part of the data store of a buffer object to the data store of another buffer object
        /// <para>
        /// glCopyBufferSubData and glCopyNamedBufferSubData copy part of the data store attached to a source
        /// buffer object to the data store attached to a destination buffer object. The number of basic machine
        /// units indicated by size is copied from the source at offset readOffset to the destination at
        /// writeOffset. readOffset, writeOffset and size are in terms of basic machine units
        /// </para>
        /// </summary>
        /// <param name="readTarget">
        /// Specifies the target to which the source buffer object is bound for glCopyBufferSubData
        /// </param>
        /// <param name="writeTarget">
        /// Specifies the target to which the destination buffer object is bound for glCopyBufferSubData.
        /// </param>
        /// <param name="readOffset">
        /// Specifies the offset, in basic machine units, within the data store of the source buffer object at
        /// which data will be read.
        /// </param>
        /// <param name="writeOffset">
        /// Specifies the offset, in basic machine units, within the data store of the destination buffer object
        /// at which data will be written.
        /// </param>
        /// <param name="size">
        /// Specifies the size, in basic machine units, of the data to be copied from the source buffer object
        /// to the destination buffer object.
        /// </param>
        public static void glCopyBufferSubDataNV(int readTarget, int writeTarget, uint readOffset, uint writeOffset, uint size) {
            Pointers.glCopyBufferSubDataNV(readTarget, writeTarget, readOffset, writeOffset, size);
        }
        
        /// <summary>
        /// respecify a portion of a color table
        /// <para>
        /// glCopyColorSubTable is used to respecify a contiguous portion of a color table previously defined
        /// using glColorTable. The pixels copied from the framebuffer replace the portion of the existing table
        /// from indices start to start + x - 1 , inclusive. This region may not include any entries outside the
        /// range of the color table, as was originally specified. It is not an error to specify a subtexture
        /// with width of 0, but such a specification has no effect
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="x">
        /// The window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// The window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// The number of table entries to replace.
        /// </param>
        public static void glCopyColorSubTable(int target, int start, int x, int y, int width) {
            Pointers.glCopyColorSubTable(target, start, x, y, width);
        }
        
        /// <summary>
        /// respecify a portion of a color table
        /// <para>
        /// glCopyColorSubTable is used to respecify a contiguous portion of a color table previously defined
        /// using glColorTable. The pixels copied from the framebuffer replace the portion of the existing table
        /// from indices start to start + x - 1 , inclusive. This region may not include any entries outside the
        /// range of the color table, as was originally specified. It is not an error to specify a subtexture
        /// with width of 0, but such a specification has no effect
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="start">
        /// The starting index of the portion of the color table to be replaced.
        /// </param>
        /// <param name="x">
        /// The window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// The window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// The number of table entries to replace.
        /// </param>
        public static void glCopyColorSubTableEXT(int target, int start, int x, int y, int width) {
            Pointers.glCopyColorSubTableEXT(target, start, x, y, width);
        }
        
        /// <summary>
        /// copy pixels into a color table
        /// <para>
        /// glCopyColorTable loads a color table with pixels from the current GL_READ_BUFFER (rather than from
        /// main memory, as is the case for glColorTable)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="internalformat">
        /// The internal storage format of the texture image. Must be one of the following symbolic constants:
        /// GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8,
        /// GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="x">
        /// The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color
        /// table.
        /// </param>
        /// <param name="y">
        /// The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color
        /// table.
        /// </param>
        /// <param name="width">
        /// The width of the pixel rectangle.
        /// </param>
        public static void glCopyColorTable(int target, int internalformat, int x, int y, int width) {
            Pointers.glCopyColorTable(target, internalformat, x, y, width);
        }
        
        /// <summary>
        /// copy pixels into a color table
        /// <para>
        /// glCopyColorTable loads a color table with pixels from the current GL_READ_BUFFER (rather than from
        /// main memory, as is the case for glColorTable)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The color table target. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="internalformat">
        /// The internal storage format of the texture image. Must be one of the following symbolic constants:
        /// GL_ALPHA, GL_ALPHA4, GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8,
        /// GL_LUMINANCE12, GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="x">
        /// The x coordinate of the lower-left corner of the pixel rectangle to be transferred to the color
        /// table.
        /// </param>
        /// <param name="y">
        /// The y coordinate of the lower-left corner of the pixel rectangle to be transferred to the color
        /// table.
        /// </param>
        /// <param name="width">
        /// The width of the pixel rectangle.
        /// </param>
        public static void glCopyColorTableSGI(int target, int internalformat, int x, int y, int width) {
            Pointers.glCopyColorTableSGI(target, internalformat, x, y, width);
        }
        
        /// <summary>
        /// copy pixels into a one-dimensional convolution filter
        /// <para>
        /// glCopyConvolutionFilter1D defines a one-dimensional convolution filter kernel with pixels from the
        /// current GL_READ_BUFFER (rather than from main memory, as is the case for glConvolutionFilter1D)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_1D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="x">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="y">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        public static void glCopyConvolutionFilter1D(int target, int internalformat, int x, int y, int width) {
            Pointers.glCopyConvolutionFilter1D(target, internalformat, x, y, width);
        }
        
        /// <summary>
        /// copy pixels into a one-dimensional convolution filter
        /// <para>
        /// glCopyConvolutionFilter1D defines a one-dimensional convolution filter kernel with pixels from the
        /// current GL_READ_BUFFER (rather than from main memory, as is the case for glConvolutionFilter1D)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_1D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="x">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="y">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        public static void glCopyConvolutionFilter1DEXT(int target, int internalformat, int x, int y, int width) {
            Pointers.glCopyConvolutionFilter1DEXT(target, internalformat, x, y, width);
        }
        
        /// <summary>
        /// copy pixels into a two-dimensional convolution filter
        /// <para>
        /// glCopyConvolutionFilter2D defines a two-dimensional convolution filter kernel with pixels from the
        /// current GL_READ_BUFFER (rather than from main memory, as is the case for glConvolutionFilter2D)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_2D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="x">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="y">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array to copy.
        /// </param>
        public static void glCopyConvolutionFilter2D(int target, int internalformat, int x, int y, int width, int height) {
            Pointers.glCopyConvolutionFilter2D(target, internalformat, x, y, width, height);
        }
        
        /// <summary>
        /// copy pixels into a two-dimensional convolution filter
        /// <para>
        /// glCopyConvolutionFilter2D defines a two-dimensional convolution filter kernel with pixels from the
        /// current GL_READ_BUFFER (rather than from main memory, as is the case for glConvolutionFilter2D)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_CONVOLUTION_2D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="x">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="y">
        /// The window space coordinates of the lower-left coordinate of the pixel array to copy.
        /// </param>
        /// <param name="width">
        /// The width of the pixel array to copy.
        /// </param>
        /// <param name="height">
        /// The height of the pixel array to copy.
        /// </param>
        public static void glCopyConvolutionFilter2DEXT(int target, int internalformat, int x, int y, int width, int height) {
            Pointers.glCopyConvolutionFilter2DEXT(target, internalformat, x, y, width, height);
        }
        
        /// <summary>
        /// perform a raw data copy between two images
        /// <para>
        /// glCopyImageSubData may be used to copy data from one image (i.e. texture or renderbuffer) to
        /// another. glCopyImageSubData does not perform general-purpose conversions such as scaling, resizing,
        /// blending, color-space, or format conversions. It should be considered to operate in a manner similar
        /// to a CPU memcpy. CopyImageSubData can copy between images with different internal formats, provided
        /// the formats are compatible
        /// </para>
        /// </summary>
        /// <param name="srcName">
        /// The name of a texture or renderbuffer object from which to copy.
        /// </param>
        /// <param name="srcTarget">
        /// The target representing the namespace of the source name srcName.
        /// </param>
        /// <param name="srcLevel">
        /// The mipmap level to read from the source.
        /// </param>
        /// <param name="srcX">
        /// The X coordinate of the left edge of the souce region to copy.
        /// </param>
        /// <param name="srcY">
        /// The Y coordinate of the top edge of the souce region to copy.
        /// </param>
        /// <param name="srcZ">
        /// The Z coordinate of the near edge of the souce region to copy.
        /// </param>
        /// <param name="dstName">
        /// The name of a texture or renderbuffer object to which to copy.
        /// </param>
        /// <param name="dstTarget">
        /// The target representing the namespace of the destination name dstName.
        /// </param>
        /// <param name="dstLevel"> </param>
        /// <param name="dstX">
        /// The X coordinate of the left edge of the destination region.
        /// </param>
        /// <param name="dstY">
        /// The Y coordinate of the top edge of the destination region.
        /// </param>
        /// <param name="dstZ">
        /// The Z coordinate of the near edge of the destination region.
        /// </param>
        /// <param name="srcWidth">
        /// The width of the region to be copied.
        /// </param>
        /// <param name="srcHeight">
        /// The height of the region to be copied.
        /// </param>
        /// <param name="srcDepth">
        /// The depth of the region to be copied.
        /// </param>
        public static void glCopyImageSubData(uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            Pointers.glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        
        /// <summary>
        /// perform a raw data copy between two images
        /// <para>
        /// glCopyImageSubData may be used to copy data from one image (i.e. texture or renderbuffer) to
        /// another. glCopyImageSubData does not perform general-purpose conversions such as scaling, resizing,
        /// blending, color-space, or format conversions. It should be considered to operate in a manner similar
        /// to a CPU memcpy. CopyImageSubData can copy between images with different internal formats, provided
        /// the formats are compatible
        /// </para>
        /// </summary>
        /// <param name="srcName">
        /// The name of a texture or renderbuffer object from which to copy.
        /// </param>
        /// <param name="srcTarget">
        /// The target representing the namespace of the source name srcName.
        /// </param>
        /// <param name="srcLevel">
        /// The mipmap level to read from the source.
        /// </param>
        /// <param name="srcX">
        /// The X coordinate of the left edge of the souce region to copy.
        /// </param>
        /// <param name="srcY">
        /// The Y coordinate of the top edge of the souce region to copy.
        /// </param>
        /// <param name="srcZ">
        /// The Z coordinate of the near edge of the souce region to copy.
        /// </param>
        /// <param name="dstName">
        /// The name of a texture or renderbuffer object to which to copy.
        /// </param>
        /// <param name="dstTarget">
        /// The target representing the namespace of the destination name dstName.
        /// </param>
        /// <param name="dstLevel"> </param>
        /// <param name="dstX">
        /// The X coordinate of the left edge of the destination region.
        /// </param>
        /// <param name="dstY">
        /// The Y coordinate of the top edge of the destination region.
        /// </param>
        /// <param name="dstZ">
        /// The Z coordinate of the near edge of the destination region.
        /// </param>
        /// <param name="srcWidth">
        /// The width of the region to be copied.
        /// </param>
        /// <param name="srcHeight">
        /// The height of the region to be copied.
        /// </param>
        /// <param name="srcDepth">
        /// The depth of the region to be copied.
        /// </param>
        public static void glCopyImageSubDataEXT(uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            Pointers.glCopyImageSubDataEXT(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        
        public static void glCopyImageSubDataNV(uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) {
            Pointers.glCopyImageSubDataNV(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
        }
        
        /// <summary>
        /// perform a raw data copy between two images
        /// <para>
        /// glCopyImageSubData may be used to copy data from one image (i.e. texture or renderbuffer) to
        /// another. glCopyImageSubData does not perform general-purpose conversions such as scaling, resizing,
        /// blending, color-space, or format conversions. It should be considered to operate in a manner similar
        /// to a CPU memcpy. CopyImageSubData can copy between images with different internal formats, provided
        /// the formats are compatible
        /// </para>
        /// </summary>
        /// <param name="srcName">
        /// The name of a texture or renderbuffer object from which to copy.
        /// </param>
        /// <param name="srcTarget">
        /// The target representing the namespace of the source name srcName.
        /// </param>
        /// <param name="srcLevel">
        /// The mipmap level to read from the source.
        /// </param>
        /// <param name="srcX">
        /// The X coordinate of the left edge of the souce region to copy.
        /// </param>
        /// <param name="srcY">
        /// The Y coordinate of the top edge of the souce region to copy.
        /// </param>
        /// <param name="srcZ">
        /// The Z coordinate of the near edge of the souce region to copy.
        /// </param>
        /// <param name="dstName">
        /// The name of a texture or renderbuffer object to which to copy.
        /// </param>
        /// <param name="dstTarget">
        /// The target representing the namespace of the destination name dstName.
        /// </param>
        /// <param name="dstLevel"> </param>
        /// <param name="dstX">
        /// The X coordinate of the left edge of the destination region.
        /// </param>
        /// <param name="dstY">
        /// The Y coordinate of the top edge of the destination region.
        /// </param>
        /// <param name="dstZ">
        /// The Z coordinate of the near edge of the destination region.
        /// </param>
        /// <param name="srcWidth">
        /// The width of the region to be copied.
        /// </param>
        /// <param name="srcHeight">
        /// The height of the region to be copied.
        /// </param>
        /// <param name="srcDepth">
        /// The depth of the region to be copied.
        /// </param>
        public static void glCopyImageSubDataOES(uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            Pointers.glCopyImageSubDataOES(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        
        public static void glCopyMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int x, int y, int width, int border) {
            Pointers.glCopyMultiTexImage1DEXT(texunit, target, level, internalformat, x, y, width, border);
        }
        
        public static void glCopyMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int x, int y, int width, int height, int border) {
            Pointers.glCopyMultiTexImage2DEXT(texunit, target, level, internalformat, x, y, width, height, border);
        }
        
        public static void glCopyMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int x, int y, int width) {
            Pointers.glCopyMultiTexSubImage1DEXT(texunit, target, level, xoffset, x, y, width);
        }
        
        public static void glCopyMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            Pointers.glCopyMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, x, y, width, height);
        }
        
        public static void glCopyMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            Pointers.glCopyMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        public static void glCopyNamedBufferSubData(uint readBuffer, uint writeBuffer, uint readOffset, uint writeOffset, uint size) {
            Pointers.glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
        }
        
        public static void glCopyPathNV(uint resultPath, uint srcPath) {
            Pointers.glCopyPathNV(resultPath, srcPath);
        }
        
        /// <summary>
        /// copy pixels in the frame buffer
        /// <para>
        /// glCopyPixels copies a screen-aligned rectangle of pixels from the specified frame buffer location to
        /// a region relative to the current raster position. Its operation is well defined only if the entire
        /// pixel source region is within the exposed portion of the window. Results of copies from outside the
        /// window, or from regions of the window that are not exposed, are hardware dependent and undefined
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the rectangular region of pixels to be copied. Both must be nonnegative.
        /// </param>
        /// <param name="type">
        /// Specifies whether color values, depth values, or stencil values are to be copied. Symbolic constants
        /// GL_COLOR, GL_DEPTH, and GL_STENCIL are accepted.
        /// </param>
        public static void glCopyPixels(int x, int y, int width, int height, int type) {
            Pointers.glCopyPixels(x, y, width, height, type);
        }
        
        /// <summary>
        /// copy pixels into a 1D texture image
        /// <para>
        /// glCopyTexImage1D defines a one-dimensional texture image with pixels from the current GL_READ_BUFFER
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants:
        /// GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB,
        /// GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24,
        /// GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5,
        /// GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. The height of the texture image is 1.
        /// </param>
        /// <param name="border">
        /// Must be 0.
        /// </param>
        public static void glCopyTexImage1D(int target, int level, int internalformat, int x, int y, int width, int border) {
            Pointers.glCopyTexImage1D(target, level, internalformat, x, y, width, border);
        }
        
        /// <summary>
        /// copy pixels into a 1D texture image
        /// <para>
        /// glCopyTexImage1D defines a one-dimensional texture image with pixels from the current GL_READ_BUFFER
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants:
        /// GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB,
        /// GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24,
        /// GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5,
        /// GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. The height of the texture image is 1.
        /// </param>
        /// <param name="border">
        /// Must be 0.
        /// </param>
        public static void glCopyTexImage1DEXT(int target, int level, int internalformat, int x, int y, int width, int border) {
            Pointers.glCopyTexImage1DEXT(target, level, internalformat, x, y, width, border);
        }
        
        /// <summary>
        /// copy pixels into a 2D texture image
        /// <para>
        /// glCopyTexImage2D defines a two-dimensional texture image, or cube-map texture image with pixels from
        /// the current GL_READ_BUFFER
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants:
        /// GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB,
        /// GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24,
        /// GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5,
        /// GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="border">
        /// Must be 0.
        /// </param>
        public static void glCopyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
            Pointers.glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
        }
        
        /// <summary>
        /// copy pixels into a 2D texture image
        /// <para>
        /// glCopyTexImage2D defines a two-dimensional texture image, or cube-map texture image with pixels from
        /// the current GL_READ_BUFFER
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the texture. Must be one of the following symbolic constants:
        /// GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB,
        /// GL_COMPRESSED_SRGB_ALPHA. GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24,
        /// GL_DEPTH_COMPONENT32, GL_STENCIL_INDEX8, GL_RED, GL_RG, GL_RGB, GL_R3_G3_B2, GL_RGB4, GL_RGB5,
        /// GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, GL_RGBA16, GL_SRGB, GL_SRGB8, GL_SRGB_ALPHA, or GL_SRGB8_ALPHA8.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image.
        /// </param>
        /// <param name="border">
        /// Must be 0.
        /// </param>
        public static void glCopyTexImage2DEXT(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
            Pointers.glCopyTexImage2DEXT(target, level, internalformat, x, y, width, height, border);
        }
        
        /// <summary>
        /// copy a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be
        /// GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies the texel offset within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        public static void glCopyTexSubImage1D(int target, int level, int xoffset, int x, int y, int width) {
            Pointers.glCopyTexSubImage1D(target, level, xoffset, x, y, width);
        }
        
        /// <summary>
        /// copy a one-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glCopyTexSubImage1D function. Must be
        /// GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies the texel offset within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the left corner of the row of pixels to be copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        public static void glCopyTexSubImage1DEXT(int target, int level, int xoffset, int x, int y, int width) {
            Pointers.glCopyTexSubImage1DEXT(target, level, xoffset, x, y, width);
        }
        
        /// <summary>
        /// copy a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be
        /// GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        public static void glCopyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            Pointers.glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
        }
        
        /// <summary>
        /// copy a two-dimensional texture subimage
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glCopyTexSubImage2D function. Must be
        /// GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_RECTANGLE.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        public static void glCopyTexSubImage2DEXT(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            Pointers.glCopyTexSubImage2DEXT(target, level, xoffset, yoffset, x, y, width, height);
        }
        
        /// <summary>
        /// copy a three-dimensional texture subimage
        /// <para>
        /// glCopyTexSubImage3D and glCopyTextureSubImage3D functions replace a rectangular portion of a
        /// three-dimensional or two-dimensional array texture image with pixels from the current GL_READ_BUFFER
        /// (rather than from main memory, as is the case for glTexSubImage3D)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be
        /// GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        public static void glCopyTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            Pointers.glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        /// <summary>
        /// copy a three-dimensional texture subimage
        /// <para>
        /// glCopyTexSubImage3D and glCopyTextureSubImage3D functions replace a rectangular portion of a
        /// three-dimensional or two-dimensional array texture image with pixels from the current GL_READ_BUFFER
        /// (rather than from main memory, as is the case for glTexSubImage3D)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glCopyTexSubImage3D function. Must be
        /// GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="x">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the lower left corner of the rectangular region of pixels to be
        /// copied.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        public static void glCopyTexSubImage3DEXT(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            Pointers.glCopyTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        public static void glCopyTexSubImage3DOES(int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            Pointers.glCopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        public static void glCopyTextureImage1DEXT(uint texture, int target, int level, int internalformat, int x, int y, int width, int border) {
            Pointers.glCopyTextureImage1DEXT(texture, target, level, internalformat, x, y, width, border);
        }
        
        public static void glCopyTextureImage2DEXT(uint texture, int target, int level, int internalformat, int x, int y, int width, int height, int border) {
            Pointers.glCopyTextureImage2DEXT(texture, target, level, internalformat, x, y, width, height, border);
        }
        
        public static void glCopyTextureLevelsAPPLE(uint destinationTexture, uint sourceTexture, int sourceBaseLevel, int sourceLevelCount) {
            Pointers.glCopyTextureLevelsAPPLE(destinationTexture, sourceTexture, sourceBaseLevel, sourceLevelCount);
        }
        
        public static void glCopyTextureSubImage1D(uint texture, int level, int xoffset, int x, int y, int width) {
            Pointers.glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
        }
        
        public static void glCopyTextureSubImage1DEXT(uint texture, int target, int level, int xoffset, int x, int y, int width) {
            Pointers.glCopyTextureSubImage1DEXT(texture, target, level, xoffset, x, y, width);
        }
        
        public static void glCopyTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            Pointers.glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
        }
        
        public static void glCopyTextureSubImage2DEXT(uint texture, int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
            Pointers.glCopyTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, x, y, width, height);
        }
        
        public static void glCopyTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            Pointers.glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        public static void glCopyTextureSubImage3DEXT(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int x, int y, int width, int height) {
            Pointers.glCopyTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, x, y, width, height);
        }
        
        public static void glCoverFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int coverMode, int transformType, float* transformValues) {
            Pointers.glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
        }
        
        public static void glCoverFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int coverMode, int transformType, float[] transformValues) {
            fixed(float* transformValues_ = &transformValues[0])
                Pointers.glCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues_);
        }
        
        public static void glCoverFillPathNV(uint path, int coverMode) {
            Pointers.glCoverFillPathNV(path, coverMode);
        }
        
        public static void glCoverStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int coverMode, int transformType, float* transformValues) {
            Pointers.glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues);
        }
        
        public static void glCoverStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int coverMode, int transformType, float[] transformValues) {
            fixed(float* transformValues_ = &transformValues[0])
                Pointers.glCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues_);
        }
        
        public static void glCoverStrokePathNV(uint path, int coverMode) {
            Pointers.glCoverStrokePathNV(path, coverMode);
        }
        
        public static void glCoverageMaskNV(bool mask) {
            Pointers.glCoverageMaskNV(mask);
        }
        
        public static void glCoverageModulationNV(int components) {
            Pointers.glCoverageModulationNV(components);
        }
        
        public static void glCoverageModulationTableNV(int n, float* v) {
            Pointers.glCoverageModulationTableNV(n, v);
        }
        
        public static void glCoverageModulationTableNV(int n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glCoverageModulationTableNV(n, v_);
        }
        
        public static void glCoverageOperationNV(int operation) {
            Pointers.glCoverageOperationNV(operation);
        }
        
        /// <summary>
        /// create buffer objects
        /// <para>
        /// glCreateBuffers returns n previously unused buffer names in buffers, each representing a new buffer
        /// object initialized as if it had been bound to an unspecified target
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to create.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which names of the new buffer objects are stored.
        /// </param>
        public static void glCreateBuffers(int n, uint* buffers) {
            Pointers.glCreateBuffers(n, buffers);
        }
        
        /// <summary>
        /// create buffer objects
        /// <para>
        /// glCreateBuffers returns n previously unused buffer names in buffers, each representing a new buffer
        /// object initialized as if it had been bound to an unspecified target
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to create.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which names of the new buffer objects are stored.
        /// </param>
        public static void glCreateBuffers(int n, uint[] buffers) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glCreateBuffers(n, buffers_);
        }
        
        public static uint glCreateBuffer() {
            var buffers_ = new uint[1];
            glCreateBuffers(1, buffers_);
            return buffers_[0];
        }
        
        public static void glCreateCommandListsNV(int n, uint* lists) {
            Pointers.glCreateCommandListsNV(n, lists);
        }
        
        public static void glCreateCommandListsNV(int n, uint[] lists) {
            fixed(uint* lists_ = &lists[0])
                Pointers.glCreateCommandListsNV(n, lists_);
        }
        
        public static uint glCreateCommandListsNV() {
            var lists_ = new uint[1];
            glCreateCommandListsNV(1, lists_);
            return lists_[0];
        }
        
        /// <summary>
        /// create framebuffer objects
        /// <para>
        /// glCreateFramebuffers returns n previously unused framebuffer names in framebuffers, each
        /// representing a new framebuffer object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of framebuffer objects to create.
        /// </param>
        /// <param name="framebuffers"> </param>
        public static void glCreateFramebuffers(int n, uint* framebuffers) {
            Pointers.glCreateFramebuffers(n, framebuffers);
        }
        
        /// <summary>
        /// create framebuffer objects
        /// <para>
        /// glCreateFramebuffers returns n previously unused framebuffer names in framebuffers, each
        /// representing a new framebuffer object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of framebuffer objects to create.
        /// </param>
        /// <param name="framebuffers"> </param>
        public static void glCreateFramebuffers(int n, uint[] framebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glCreateFramebuffers(n, framebuffers_);
        }
        
        public static uint glCreateFramebuffer() {
            var framebuffers_ = new uint[1];
            glCreateFramebuffers(1, framebuffers_);
            return framebuffers_[0];
        }
        
        public static void glCreateMemoryObjectsEXT(int n, uint* memoryObjects) {
            Pointers.glCreateMemoryObjectsEXT(n, memoryObjects);
        }
        
        public static void glCreateMemoryObjectsEXT(int n, uint[] memoryObjects) {
            fixed(uint* memoryObjects_ = &memoryObjects[0])
                Pointers.glCreateMemoryObjectsEXT(n, memoryObjects_);
        }
        
        public static void glCreatePerfQueryINTEL(uint queryId, uint* queryHandle) {
            Pointers.glCreatePerfQueryINTEL(queryId, queryHandle);
        }
        
        public static void glCreatePerfQueryINTEL(uint queryId, uint[] queryHandle) {
            fixed(uint* queryHandle_ = &queryHandle[0])
                Pointers.glCreatePerfQueryINTEL(queryId, queryHandle_);
        }
        
        /// <summary>
        /// Creates a program object
        /// <para>
        /// glCreateProgram creates an empty program object and returns a non-zero value by which it can be
        /// referenced. A program object is an object to which shader objects can be attached. This provides a
        /// mechanism to specify the shader objects that will be linked to create a program. It also provides a
        /// means for checking the compatibility of the shaders that will be used to create a program (for
        /// instance, checking the compatibility between a vertex shader and a fragment shader). When no longer
        /// needed as part of a program object, shader objects can be detached
        /// </para>
        /// </summary>
        public static uint glCreateProgram() {
            return Pointers.glCreateProgram();
        }
        
        /// <summary>
        /// Creates a program object
        /// <para>
        /// glCreateProgram creates an empty program object and returns a non-zero value by which it can be
        /// referenced. A program object is an object to which shader objects can be attached. This provides a
        /// mechanism to specify the shader objects that will be linked to create a program. It also provides a
        /// means for checking the compatibility of the shaders that will be used to create a program (for
        /// instance, checking the compatibility between a vertex shader and a fragment shader). When no longer
        /// needed as part of a program object, shader objects can be detached
        /// </para>
        /// </summary>
        public static uint glCreateProgramObjectARB() {
            return Pointers.glCreateProgramObjectARB();
        }
        
        /// <summary>
        /// create program pipeline objects
        /// <para>
        /// glCreateProgramPipelines returns n previously unused program pipeline names in pipelines, each
        /// representing a new program pipeline object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of program pipeline objects to create.
        /// </param>
        /// <param name="pipelines">
        /// Specifies an array in which names of the new program pipeline objects are stored.
        /// </param>
        public static void glCreateProgramPipelines(int n, uint* pipelines) {
            Pointers.glCreateProgramPipelines(n, pipelines);
        }
        
        /// <summary>
        /// create program pipeline objects
        /// <para>
        /// glCreateProgramPipelines returns n previously unused program pipeline names in pipelines, each
        /// representing a new program pipeline object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of program pipeline objects to create.
        /// </param>
        /// <param name="pipelines">
        /// Specifies an array in which names of the new program pipeline objects are stored.
        /// </param>
        public static void glCreateProgramPipelines(int n, uint[] pipelines) {
            fixed(uint* pipelines_ = &pipelines[0])
                Pointers.glCreateProgramPipelines(n, pipelines_);
        }
        
        public static uint glCreateProgramPipeline() {
            var pipelines_ = new uint[1];
            glCreateProgramPipelines(1, pipelines_);
            return pipelines_[0];
        }
        
        /// <summary>
        /// create query objects
        /// <para>
        /// glCreateQueries returns n previously unused query object names in ids, each representing a new query
        /// object with the specified target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target of each created query object.
        /// </param>
        /// <param name="n">
        /// Number of query objects to create.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which names of the new query objects are stored.
        /// </param>
        public static void glCreateQueries(int target, int n, uint* ids) {
            Pointers.glCreateQueries(target, n, ids);
        }
        
        /// <summary>
        /// create query objects
        /// <para>
        /// glCreateQueries returns n previously unused query object names in ids, each representing a new query
        /// object with the specified target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target of each created query object.
        /// </param>
        /// <param name="n">
        /// Number of query objects to create.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which names of the new query objects are stored.
        /// </param>
        public static void glCreateQueries(int target, int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glCreateQueries(target, n, ids_);
        }
        
        /// <summary>
        /// create renderbuffer objects
        /// <para>
        /// glCreateRenderbuffers returns n previously unused renderbuffer object names in renderbuffers, each
        /// representing a new renderbuffer object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of renderbuffer objects to create.
        /// </param>
        /// <param name="renderbuffers">
        /// Specifies an array in which names of the new renderbuffer objects are stored.
        /// </param>
        public static void glCreateRenderbuffers(int n, uint* renderbuffers) {
            Pointers.glCreateRenderbuffers(n, renderbuffers);
        }
        
        /// <summary>
        /// create renderbuffer objects
        /// <para>
        /// glCreateRenderbuffers returns n previously unused renderbuffer object names in renderbuffers, each
        /// representing a new renderbuffer object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of renderbuffer objects to create.
        /// </param>
        /// <param name="renderbuffers">
        /// Specifies an array in which names of the new renderbuffer objects are stored.
        /// </param>
        public static void glCreateRenderbuffers(int n, uint[] renderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glCreateRenderbuffers(n, renderbuffers_);
        }
        
        public static uint glCreateRenderbuffer() {
            var renderbuffers_ = new uint[1];
            glCreateRenderbuffers(1, renderbuffers_);
            return renderbuffers_[0];
        }
        
        /// <summary>
        /// create sampler objects
        /// <para>
        /// glCreateSamplers returns n previously unused sampler names in samplers, each representing a new
        /// sampler object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of sampler objects to create.
        /// </param>
        /// <param name="samplers">
        /// Specifies an array in which names of the new sampler objects are stored.
        /// </param>
        public static void glCreateSamplers(int n, uint* samplers) {
            Pointers.glCreateSamplers(n, samplers);
        }
        
        /// <summary>
        /// create sampler objects
        /// <para>
        /// glCreateSamplers returns n previously unused sampler names in samplers, each representing a new
        /// sampler object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of sampler objects to create.
        /// </param>
        /// <param name="samplers">
        /// Specifies an array in which names of the new sampler objects are stored.
        /// </param>
        public static void glCreateSamplers(int n, uint[] samplers) {
            fixed(uint* samplers_ = &samplers[0])
                Pointers.glCreateSamplers(n, samplers_);
        }
        
        public static uint glCreateSampler() {
            var samplers_ = new uint[1];
            glCreateSamplers(1, samplers_);
            return samplers_[0];
        }
        
        /// <summary>
        /// Creates a shader object
        /// <para>
        /// glCreateShader creates an empty shader object and returns a non-zero value by which it can be
        /// referenced. A shader object is used to maintain the source code strings that define a shader.
        /// shaderType indicates the type of shader to be created. Five types of shader are supported. A shader
        /// of type GL_COMPUTE_SHADER is a shader that is intended to run on the programmable compute processor.
        /// A shader of type GL_VERTEX_SHADER is a shader that is intended to run on the programmable vertex
        /// processor. A shader of type GL_TESS_CONTROL_SHADER is a shader that is intended to run on the
        /// programmable tessellation processor in the control stage. A shader of type GL_TESS_EVALUATION_SHADER
        /// is a shader that is intended to run on the programmable tessellation processor in the evaluation
        /// stage. A shader of type GL_GEOMETRY_SHADER is a shader that is intended to run on the programmable
        /// geometry processor. A shader of type GL_FRAGMENT_SHADER is a shader that is intended to run on the
        /// programmable fragment processor
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER,
        /// GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.
        /// </param>
        public static uint glCreateShader(int type) {
            return Pointers.glCreateShader(type);
        }
        
        /// <summary>
        /// Creates a shader object
        /// <para>
        /// glCreateShader creates an empty shader object and returns a non-zero value by which it can be
        /// referenced. A shader object is used to maintain the source code strings that define a shader.
        /// shaderType indicates the type of shader to be created. Five types of shader are supported. A shader
        /// of type GL_COMPUTE_SHADER is a shader that is intended to run on the programmable compute processor.
        /// A shader of type GL_VERTEX_SHADER is a shader that is intended to run on the programmable vertex
        /// processor. A shader of type GL_TESS_CONTROL_SHADER is a shader that is intended to run on the
        /// programmable tessellation processor in the control stage. A shader of type GL_TESS_EVALUATION_SHADER
        /// is a shader that is intended to run on the programmable tessellation processor in the evaluation
        /// stage. A shader of type GL_GEOMETRY_SHADER is a shader that is intended to run on the programmable
        /// geometry processor. A shader of type GL_FRAGMENT_SHADER is a shader that is intended to run on the
        /// programmable fragment processor
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER,
        /// GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.
        /// </param>
        public static uint glCreateShader(Enums.ShaderType type) {
            return Pointers.glCreateShader((int)type);
        }
        
        /// <summary>
        /// Creates a shader object
        /// <para>
        /// glCreateShader creates an empty shader object and returns a non-zero value by which it can be
        /// referenced. A shader object is used to maintain the source code strings that define a shader.
        /// shaderType indicates the type of shader to be created. Five types of shader are supported. A shader
        /// of type GL_COMPUTE_SHADER is a shader that is intended to run on the programmable compute processor.
        /// A shader of type GL_VERTEX_SHADER is a shader that is intended to run on the programmable vertex
        /// processor. A shader of type GL_TESS_CONTROL_SHADER is a shader that is intended to run on the
        /// programmable tessellation processor in the control stage. A shader of type GL_TESS_EVALUATION_SHADER
        /// is a shader that is intended to run on the programmable tessellation processor in the evaluation
        /// stage. A shader of type GL_GEOMETRY_SHADER is a shader that is intended to run on the programmable
        /// geometry processor. A shader of type GL_FRAGMENT_SHADER is a shader that is intended to run on the
        /// programmable fragment processor
        /// </para>
        /// </summary>
        /// <param name="shaderType">
        /// Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER,
        /// GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.
        /// </param>
        public static uint glCreateShaderObjectARB(int shaderType) {
            return Pointers.glCreateShaderObjectARB(shaderType);
        }
        
        /// <summary>
        /// Creates a shader object
        /// <para>
        /// glCreateShader creates an empty shader object and returns a non-zero value by which it can be
        /// referenced. A shader object is used to maintain the source code strings that define a shader.
        /// shaderType indicates the type of shader to be created. Five types of shader are supported. A shader
        /// of type GL_COMPUTE_SHADER is a shader that is intended to run on the programmable compute processor.
        /// A shader of type GL_VERTEX_SHADER is a shader that is intended to run on the programmable vertex
        /// processor. A shader of type GL_TESS_CONTROL_SHADER is a shader that is intended to run on the
        /// programmable tessellation processor in the control stage. A shader of type GL_TESS_EVALUATION_SHADER
        /// is a shader that is intended to run on the programmable tessellation processor in the evaluation
        /// stage. A shader of type GL_GEOMETRY_SHADER is a shader that is intended to run on the programmable
        /// geometry processor. A shader of type GL_FRAGMENT_SHADER is a shader that is intended to run on the
        /// programmable fragment processor
        /// </para>
        /// </summary>
        /// <param name="shaderType">
        /// Specifies the type of shader to be created. Must be one of GL_COMPUTE_SHADER, GL_VERTEX_SHADER,
        /// GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER, or GL_FRAGMENT_SHADER.
        /// </param>
        public static uint glCreateShaderObjectARB(Enums.ShaderType shaderType) {
            return Pointers.glCreateShaderObjectARB((int)shaderType);
        }
        
        public static uint glCreateShaderProgramEXT(int type, string _string) {
            return Pointers.glCreateShaderProgramEXT(type, _string);
        }
        
        public static uint glCreateShaderProgramEXT(Enums.ShaderType type, string _string) {
            return Pointers.glCreateShaderProgramEXT((int)type, _string);
        }
        
        /// <summary>
        /// create a stand-alone program from an array of null-terminated source code strings
        /// <para>
        /// glCreateShaderProgram creates a program object containing compiled and linked shaders for a single
        /// stage specified by type. strings refers to an array of count strings from which to create the shader
        /// executables
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the type of shader to create.
        /// </param>
        /// <param name="count">
        /// Specifies the number of source code strings in the array strings.
        /// </param>
        /// <param name="strings">
        /// Specifies the address of an array of pointers to source code strings from which to create the
        /// program object.
        /// </param>
        public static uint glCreateShaderProgramv(int type, int count, string[] strings) {
            return Pointers.glCreateShaderProgramv(type, count, strings);
        }
        
        /// <summary>
        /// create a stand-alone program from an array of null-terminated source code strings
        /// <para>
        /// glCreateShaderProgram creates a program object containing compiled and linked shaders for a single
        /// stage specified by type. strings refers to an array of count strings from which to create the shader
        /// executables
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the type of shader to create.
        /// </param>
        /// <param name="count">
        /// Specifies the number of source code strings in the array strings.
        /// </param>
        /// <param name="strings">
        /// Specifies the address of an array of pointers to source code strings from which to create the
        /// program object.
        /// </param>
        public static uint glCreateShaderProgramv(Enums.ShaderType type, int count, string[] strings) {
            return Pointers.glCreateShaderProgramv((int)type, count, strings);
        }
        
        public static uint glCreateShaderProgramvEXT(int type, int count, string[] strings) {
            return Pointers.glCreateShaderProgramvEXT(type, count, strings);
        }
        
        public static uint glCreateShaderProgramvEXT(Enums.ShaderType type, int count, string[] strings) {
            return Pointers.glCreateShaderProgramvEXT((int)type, count, strings);
        }
        
        public static void glCreateStatesNV(int n, uint* states) {
            Pointers.glCreateStatesNV(n, states);
        }
        
        public static void glCreateStatesNV(int n, uint[] states) {
            fixed(uint* states_ = &states[0])
                Pointers.glCreateStatesNV(n, states_);
        }
        
        public static uint glCreateStatesNV() {
            var states_ = new uint[1];
            glCreateStatesNV(1, states_);
            return states_[0];
        }
        
        public static IntPtr glCreateSyncFromCLeventARB(IntPtr context, IntPtr _event, uint flags) {
            return Pointers.glCreateSyncFromCLeventARB(context, _event, flags);
        }
        
        /// <summary>
        /// create texture objects
        /// <para>
        /// glCreateTextures returns n previously unused texture names in textures, each representing a new
        /// texture object of the dimensionality and type specified by target and initialized to the default
        /// values for that texture type
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the effective texture target of each created texture.
        /// </param>
        /// <param name="n">
        /// Number of texture objects to create.
        /// </param>
        /// <param name="textures">
        /// Specifies an array in which names of the new texture objects are stored.
        /// </param>
        public static void glCreateTextures(int target, int n, uint* textures) {
            Pointers.glCreateTextures(target, n, textures);
        }
        
        /// <summary>
        /// create texture objects
        /// <para>
        /// glCreateTextures returns n previously unused texture names in textures, each representing a new
        /// texture object of the dimensionality and type specified by target and initialized to the default
        /// values for that texture type
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the effective texture target of each created texture.
        /// </param>
        /// <param name="n">
        /// Number of texture objects to create.
        /// </param>
        /// <param name="textures">
        /// Specifies an array in which names of the new texture objects are stored.
        /// </param>
        public static void glCreateTextures(int target, int n, uint[] textures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glCreateTextures(target, n, textures_);
        }
        
        /// <summary>
        /// create transform feedback objects
        /// <para>
        /// glCreateTransformFeedbacks returns n previously unused transform feedback object names in ids, each
        /// representing a new transform feedback object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of transform feedback objects to create.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which names of the new transform feedback objects are stored.
        /// </param>
        public static void glCreateTransformFeedbacks(int n, uint* ids) {
            Pointers.glCreateTransformFeedbacks(n, ids);
        }
        
        /// <summary>
        /// create transform feedback objects
        /// <para>
        /// glCreateTransformFeedbacks returns n previously unused transform feedback object names in ids, each
        /// representing a new transform feedback object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of transform feedback objects to create.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which names of the new transform feedback objects are stored.
        /// </param>
        public static void glCreateTransformFeedbacks(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glCreateTransformFeedbacks(n, ids_);
        }
        
        public static uint glCreateTransformFeedback() {
            var ids_ = new uint[1];
            glCreateTransformFeedbacks(1, ids_);
            return ids_[0];
        }
        
        /// <summary>
        /// create vertex array objects
        /// <para>
        /// glCreateVertexArrays returns n previously unused vertex array object names in arrays, each
        /// representing a new vertex array object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of vertex array objects to create.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which names of the new vertex array objects are stored.
        /// </param>
        public static void glCreateVertexArrays(int n, uint* arrays) {
            Pointers.glCreateVertexArrays(n, arrays);
        }
        
        /// <summary>
        /// create vertex array objects
        /// <para>
        /// glCreateVertexArrays returns n previously unused vertex array object names in arrays, each
        /// representing a new vertex array object initialized to the default state
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Number of vertex array objects to create.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which names of the new vertex array objects are stored.
        /// </param>
        public static void glCreateVertexArrays(int n, uint[] arrays) {
            fixed(uint* arrays_ = &arrays[0])
                Pointers.glCreateVertexArrays(n, arrays_);
        }
        
        public static uint glCreateVertexArray() {
            var arrays_ = new uint[1];
            glCreateVertexArrays(1, arrays_);
            return arrays_[0];
        }
        
        /// <summary>
        /// specify whether front- or back-facing facets can be culled
        /// <para>
        /// glCullFace specifies whether front- or back-facing facets are culled (as specified by mode) when
        /// facet culling is enabled. Facet culling is initially disabled. To enable and disable facet culling,
        /// call the glEnable and glDisable commands with the argument GL_CULL_FACE. Facets include triangles,
        /// quadrilaterals, polygons, and rectangles
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies whether front- or back-facing facets are candidates for culling. Symbolic constants
        /// GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK are accepted. The initial value is GL_BACK.
        /// </param>
        public static void glCullFace(int mode) {
            Pointers.glCullFace(mode);
        }
        
        public static void glCullParameterdvEXT(int pname, double* _params) {
            Pointers.glCullParameterdvEXT(pname, _params);
        }
        
        public static void glCullParameterdvEXT(int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glCullParameterdvEXT(pname, _params_);
        }
        
        public static void glCullParameterfvEXT(int pname, float* _params) {
            Pointers.glCullParameterfvEXT(pname, _params);
        }
        
        public static void glCullParameterfvEXT(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glCullParameterfvEXT(pname, _params_);
        }
        
        public static void glCurrentPaletteMatrixARB(int index) {
            Pointers.glCurrentPaletteMatrixARB(index);
        }
        
        public static void glCurrentPaletteMatrixOES(uint matrixpaletteindex) {
            Pointers.glCurrentPaletteMatrixOES(matrixpaletteindex);
        }
        
        /// <summary>
        /// specify a callback to receive debugging messages from the GL
        /// <para>
        /// glDebugMessageCallback sets the current debug output callback function to the function whose address
        /// is given in callback. The callback function should have the following prototype (in C), or be
        /// otherwise compatible with such a prototype:
        /// </para>
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        public static void glDebugMessageCallback(IntPtr callback, IntPtr userParam) {
            Pointers.glDebugMessageCallback(callback, userParam);
        }
        
        public static void glDebugMessageCallbackAMD(IntPtr callback, IntPtr userParam) {
            Pointers.glDebugMessageCallbackAMD(callback, userParam);
        }
        
        /// <summary>
        /// specify a callback to receive debugging messages from the GL
        /// <para>
        /// glDebugMessageCallback sets the current debug output callback function to the function whose address
        /// is given in callback. The callback function should have the following prototype (in C), or be
        /// otherwise compatible with such a prototype:
        /// </para>
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        public static void glDebugMessageCallbackARB(IntPtr callback, IntPtr userParam) {
            Pointers.glDebugMessageCallbackARB(callback, userParam);
        }
        
        /// <summary>
        /// specify a callback to receive debugging messages from the GL
        /// <para>
        /// glDebugMessageCallback sets the current debug output callback function to the function whose address
        /// is given in callback. The callback function should have the following prototype (in C), or be
        /// otherwise compatible with such a prototype:
        /// </para>
        /// </summary>
        /// <param name="callback">
        /// The address of a callback function that will be called when a debug message is generated.
        /// </param>
        /// <param name="userParam">
        /// A user supplied pointer that will be passed on each invocation of callback.
        /// </param>
        public static void glDebugMessageCallbackKHR(IntPtr callback, IntPtr userParam) {
            Pointers.glDebugMessageCallbackKHR(callback, userParam);
        }
        
        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug context. The
        /// parameters source, type and severity form a filter to select messages from the pool of potential
        /// messages generated by the GL
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or
        /// disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        public static void glDebugMessageControl(int source, int type, int severity, int count, uint* ids, bool enabled) {
            Pointers.glDebugMessageControl(source, type, severity, count, ids, enabled);
        }
        
        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug context. The
        /// parameters source, type and severity form a filter to select messages from the pool of potential
        /// messages generated by the GL
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or
        /// disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        public static void glDebugMessageControl(int source, int type, int severity, int count, uint[] ids, bool enabled) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDebugMessageControl(source, type, severity, count, ids_, enabled);
        }
        
        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug context. The
        /// parameters source, type and severity form a filter to select messages from the pool of potential
        /// messages generated by the GL
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or
        /// disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        public static void glDebugMessageControlARB(int source, int type, int severity, int count, uint* ids, bool enabled) {
            Pointers.glDebugMessageControlARB(source, type, severity, count, ids, enabled);
        }
        
        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug context. The
        /// parameters source, type and severity form a filter to select messages from the pool of potential
        /// messages generated by the GL
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or
        /// disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        public static void glDebugMessageControlARB(int source, int type, int severity, int count, uint[] ids, bool enabled) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDebugMessageControlARB(source, type, severity, count, ids_, enabled);
        }
        
        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug context. The
        /// parameters source, type and severity form a filter to select messages from the pool of potential
        /// messages generated by the GL
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or
        /// disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        public static void glDebugMessageControlKHR(int source, int type, int severity, int count, uint* ids, bool enabled) {
            Pointers.glDebugMessageControlKHR(source, type, severity, count, ids, enabled);
        }
        
        /// <summary>
        /// control the reporting of debug messages in a debug context
        /// <para>
        /// glDebugMessageControl controls the reporting of debug messages generated by a debug context. The
        /// parameters source, type and severity form a filter to select messages from the pool of potential
        /// messages generated by the GL
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of debug messages to enable or disable.
        /// </param>
        /// <param name="type">
        /// The type of debug messages to enable or disable.
        /// </param>
        /// <param name="severity">
        /// The severity of debug messages to enable or disable.
        /// </param>
        /// <param name="count">
        /// The length of the array ids.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers contianing the ids of the messages to enable or
        /// disable.
        /// </param>
        /// <param name="enabled">
        /// A Boolean flag determining whether the selected messages should be enabled or disabled.
        /// </param>
        public static void glDebugMessageControlKHR(int source, int type, int severity, int count, uint[] ids, bool enabled) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDebugMessageControlKHR(source, type, severity, count, ids_, enabled);
        }
        
        public static void glDebugMessageEnableAMD(int category, int severity, int count, uint* ids, bool enabled) {
            Pointers.glDebugMessageEnableAMD(category, severity, count, ids, enabled);
        }
        
        public static void glDebugMessageEnableAMD(int category, int severity, int count, uint[] ids, bool enabled) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDebugMessageEnableAMD(category, severity, count, ids_, enabled);
        }
        
        /// <summary>
        /// inject an application-supplied message into the debug message queue
        /// <para>
        /// glDebugMessageInsert inserts a user-supplied message into the debug output queue. source specifies
        /// the source that will be used to classify the message and must be GL_DEBUG_SOURCE_APPLICATION or
        /// GL_DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved for use by the GL implementation. type
        /// indicates the type of the message to be inserted and may be one of GL_DEBUG_TYPE_ERROR,
        /// GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR, GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,
        /// GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP,
        /// or GL_DEBUG_TYPE_OTHER. severity indicates the severity of the message and may be
        /// GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM, GL_DEBUG_SEVERITY_HIGH or
        /// GL_DEBUG_SEVERITY_NOTIFICATION. id is available for application defined use and may be any value.
        /// This value will be recorded and used to identify the message
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of the debug message to insert.
        /// </param>
        /// <param name="type">
        /// The type of the debug message insert.
        /// </param>
        /// <param name="id">
        /// The user-supplied identifier of the message to insert.
        /// </param>
        /// <param name="severity">
        /// The severity of the debug messages to insert.
        /// </param>
        /// <param name="length">
        /// The length string contained in the character array whose address is given by message.
        /// </param>
        /// <param name="buf">
        /// The address of a character array containing the message to insert.
        /// </param>
        public static void glDebugMessageInsert(int source, int type, uint id, int severity, int length, string buf) {
            Pointers.glDebugMessageInsert(source, type, id, severity, length, buf);
        }
        
        public static void glDebugMessageInsertAMD(int category, int severity, uint id, int length, string buf) {
            Pointers.glDebugMessageInsertAMD(category, severity, id, length, buf);
        }
        
        /// <summary>
        /// inject an application-supplied message into the debug message queue
        /// <para>
        /// glDebugMessageInsert inserts a user-supplied message into the debug output queue. source specifies
        /// the source that will be used to classify the message and must be GL_DEBUG_SOURCE_APPLICATION or
        /// GL_DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved for use by the GL implementation. type
        /// indicates the type of the message to be inserted and may be one of GL_DEBUG_TYPE_ERROR,
        /// GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR, GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,
        /// GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP,
        /// or GL_DEBUG_TYPE_OTHER. severity indicates the severity of the message and may be
        /// GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM, GL_DEBUG_SEVERITY_HIGH or
        /// GL_DEBUG_SEVERITY_NOTIFICATION. id is available for application defined use and may be any value.
        /// This value will be recorded and used to identify the message
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of the debug message to insert.
        /// </param>
        /// <param name="type">
        /// The type of the debug message insert.
        /// </param>
        /// <param name="id">
        /// The user-supplied identifier of the message to insert.
        /// </param>
        /// <param name="severity">
        /// The severity of the debug messages to insert.
        /// </param>
        /// <param name="length">
        /// The length string contained in the character array whose address is given by message.
        /// </param>
        /// <param name="buf">
        /// The address of a character array containing the message to insert.
        /// </param>
        public static void glDebugMessageInsertARB(int source, int type, uint id, int severity, int length, string buf) {
            Pointers.glDebugMessageInsertARB(source, type, id, severity, length, buf);
        }
        
        /// <summary>
        /// inject an application-supplied message into the debug message queue
        /// <para>
        /// glDebugMessageInsert inserts a user-supplied message into the debug output queue. source specifies
        /// the source that will be used to classify the message and must be GL_DEBUG_SOURCE_APPLICATION or
        /// GL_DEBUG_SOURCE_THIRD_PARTY. All other sources are reserved for use by the GL implementation. type
        /// indicates the type of the message to be inserted and may be one of GL_DEBUG_TYPE_ERROR,
        /// GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR, GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR, GL_DEBUG_TYPE_PORTABILITY,
        /// GL_DEBUG_TYPE_PERFORMANCE, GL_DEBUG_TYPE_MARKER, GL_DEBUG_TYPE_PUSH_GROUP, GL_DEBUG_TYPE_POP_GROUP,
        /// or GL_DEBUG_TYPE_OTHER. severity indicates the severity of the message and may be
        /// GL_DEBUG_SEVERITY_LOW, GL_DEBUG_SEVERITY_MEDIUM, GL_DEBUG_SEVERITY_HIGH or
        /// GL_DEBUG_SEVERITY_NOTIFICATION. id is available for application defined use and may be any value.
        /// This value will be recorded and used to identify the message
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of the debug message to insert.
        /// </param>
        /// <param name="type">
        /// The type of the debug message insert.
        /// </param>
        /// <param name="id">
        /// The user-supplied identifier of the message to insert.
        /// </param>
        /// <param name="severity">
        /// The severity of the debug messages to insert.
        /// </param>
        /// <param name="length">
        /// The length string contained in the character array whose address is given by message.
        /// </param>
        /// <param name="buf">
        /// The address of a character array containing the message to insert.
        /// </param>
        public static void glDebugMessageInsertKHR(int source, int type, uint id, int severity, int length, string buf) {
            Pointers.glDebugMessageInsertKHR(source, type, id, severity, length, buf);
        }
        
        public static void glDeformSGIX(uint mask) {
            Pointers.glDeformSGIX(mask);
        }
        
        public static void glDeformSGIX(Enums.FfdMaskSGIX mask) {
            Pointers.glDeformSGIX((uint)mask);
        }
        
        public static void glDeformationMap3dSGIX(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double* points) {
            Pointers.glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
        }
        
        public static void glDeformationMap3dSGIX(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double w1, double w2, int wstride, int worder, double[] points) {
            fixed(double* points_ = &points[0])
                Pointers.glDeformationMap3dSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_);
        }
        
        public static void glDeformationMap3fSGIX(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float* points) {
            Pointers.glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points);
        }
        
        public static void glDeformationMap3fSGIX(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float w1, float w2, int wstride, int worder, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glDeformationMap3fSGIX(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points_);
        }
        
        public static void glDeleteAsyncMarkersSGIX(uint marker, int range) {
            Pointers.glDeleteAsyncMarkersSGIX(marker, range);
        }
        
        /// <summary>
        /// delete named buffer objects
        /// <para>
        /// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer
        /// object is deleted, it has no contents, and its name is free for reuse (for example by glGenBuffers).
        /// If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any
        /// buffer object)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        public static void glDeleteBuffers(int n, uint* buffers) {
            Pointers.glDeleteBuffers(n, buffers);
        }
        
        /// <summary>
        /// delete named buffer objects
        /// <para>
        /// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer
        /// object is deleted, it has no contents, and its name is free for reuse (for example by glGenBuffers).
        /// If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any
        /// buffer object)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        public static void glDeleteBuffers(int n, uint[] buffers) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glDeleteBuffers(n, buffers_);
        }
        
        /// <summary>
        /// delete named buffer objects
        /// <para>
        /// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer
        /// object is deleted, it has no contents, and its name is free for reuse (for example by glGenBuffers).
        /// If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any
        /// buffer object)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        public static void glDeleteBuffersARB(int n, uint* buffers) {
            Pointers.glDeleteBuffersARB(n, buffers);
        }
        
        /// <summary>
        /// delete named buffer objects
        /// <para>
        /// glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer
        /// object is deleted, it has no contents, and its name is free for reuse (for example by glGenBuffers).
        /// If a buffer object that is currently bound is deleted, the binding reverts to 0 (the absence of any
        /// buffer object)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer objects to be deleted.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array of buffer objects to be deleted.
        /// </param>
        public static void glDeleteBuffersARB(int n, uint[] buffers) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glDeleteBuffersARB(n, buffers_);
        }
        
        public static void glDeleteCommandListsNV(int n, uint* lists) {
            Pointers.glDeleteCommandListsNV(n, lists);
        }
        
        public static void glDeleteCommandListsNV(int n, uint[] lists) {
            fixed(uint* lists_ = &lists[0])
                Pointers.glDeleteCommandListsNV(n, lists_);
        }
        
        public static void glDeleteFencesAPPLE(int n, uint* fences) {
            Pointers.glDeleteFencesAPPLE(n, fences);
        }
        
        public static void glDeleteFencesAPPLE(int n, uint[] fences) {
            fixed(uint* fences_ = &fences[0])
                Pointers.glDeleteFencesAPPLE(n, fences_);
        }
        
        public static void glDeleteFencesNV(int n, uint* fences) {
            Pointers.glDeleteFencesNV(n, fences);
        }
        
        public static void glDeleteFencesNV(int n, uint[] fences) {
            fixed(uint* fences_ = &fences[0])
                Pointers.glDeleteFencesNV(n, fences_);
        }
        
        public static void glDeleteFragmentShaderATI(uint id) {
            Pointers.glDeleteFragmentShaderATI(id);
        }
        
        /// <summary>
        /// delete framebuffer objects
        /// <para>
        /// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in the array addressed
        /// by framebuffers. The name zero is reserved by the GL and is silently ignored, should it occur in
        /// framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again
        /// unused and it has no attachments. If a framebuffer that is currently bound to one or more of the
        /// targets GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer had
        /// been executed with the corresponding target and framebuffer zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        public static void glDeleteFramebuffers(int n, uint* framebuffers) {
            Pointers.glDeleteFramebuffers(n, framebuffers);
        }
        
        /// <summary>
        /// delete framebuffer objects
        /// <para>
        /// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in the array addressed
        /// by framebuffers. The name zero is reserved by the GL and is silently ignored, should it occur in
        /// framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again
        /// unused and it has no attachments. If a framebuffer that is currently bound to one or more of the
        /// targets GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer had
        /// been executed with the corresponding target and framebuffer zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        public static void glDeleteFramebuffers(int n, uint[] framebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glDeleteFramebuffers(n, framebuffers_);
        }
        
        /// <summary>
        /// delete framebuffer objects
        /// <para>
        /// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in the array addressed
        /// by framebuffers. The name zero is reserved by the GL and is silently ignored, should it occur in
        /// framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again
        /// unused and it has no attachments. If a framebuffer that is currently bound to one or more of the
        /// targets GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer had
        /// been executed with the corresponding target and framebuffer zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        public static void glDeleteFramebuffersEXT(int n, uint* framebuffers) {
            Pointers.glDeleteFramebuffersEXT(n, framebuffers);
        }
        
        /// <summary>
        /// delete framebuffer objects
        /// <para>
        /// glDeleteFramebuffers deletes the n framebuffer objects whose names are stored in the array addressed
        /// by framebuffers. The name zero is reserved by the GL and is silently ignored, should it occur in
        /// framebuffers, as are other unused names. Once a framebuffer object is deleted, its name is again
        /// unused and it has no attachments. If a framebuffer that is currently bound to one or more of the
        /// targets GL_DRAW_FRAMEBUFFER or GL_READ_FRAMEBUFFER is deleted, it is as though glBindFramebuffer had
        /// been executed with the corresponding target and framebuffer zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer objects to be deleted.
        /// </param>
        /// <param name="framebuffers">
        /// A pointer to an array containing n framebuffer objects to be deleted.
        /// </param>
        public static void glDeleteFramebuffersEXT(int n, uint[] framebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glDeleteFramebuffersEXT(n, framebuffers_);
        }
        
        public static void glDeleteFramebuffersOES(int n, uint* framebuffers) {
            Pointers.glDeleteFramebuffersOES(n, framebuffers);
        }
        
        public static void glDeleteFramebuffersOES(int n, uint[] framebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glDeleteFramebuffersOES(n, framebuffers_);
        }
        
        /// <summary>
        /// delete a contiguous group of display lists
        /// <para>
        /// glDeleteLists causes a contiguous group of display lists to be deleted. list is the name of the
        /// first display list to be deleted, and range is the number of display lists to delete. All display
        /// lists d with list &lt;= d &lt;= list + range - 1 are deleted
        /// </para>
        /// </summary>
        /// <param name="list">
        /// Specifies the integer name of the first display list to delete.
        /// </param>
        /// <param name="range">
        /// Specifies the number of display lists to delete.
        /// </param>
        public static void glDeleteLists(uint list, int range) {
            Pointers.glDeleteLists(list, range);
        }
        
        public static void glDeleteMemoryObjectsEXT(int n, uint* memoryObjects) {
            Pointers.glDeleteMemoryObjectsEXT(n, memoryObjects);
        }
        
        public static void glDeleteMemoryObjectsEXT(int n, uint[] memoryObjects) {
            fixed(uint* memoryObjects_ = &memoryObjects[0])
                Pointers.glDeleteMemoryObjectsEXT(n, memoryObjects_);
        }
        
        public static void glDeleteNamedStringARB(int namelen, string name) {
            Pointers.glDeleteNamedStringARB(namelen, name);
        }
        
        public static void glDeleteNamesAMD(int identifier, uint num, uint* names) {
            Pointers.glDeleteNamesAMD(identifier, num, names);
        }
        
        public static void glDeleteNamesAMD(int identifier, uint num, uint[] names) {
            fixed(uint* names_ = &names[0])
                Pointers.glDeleteNamesAMD(identifier, num, names_);
        }
        
        public static void glDeleteObjectARB(uint obj) {
            Pointers.glDeleteObjectARB(obj);
        }
        
        public static void glDeleteOcclusionQueriesNV(int n, uint* ids) {
            Pointers.glDeleteOcclusionQueriesNV(n, ids);
        }
        
        public static void glDeleteOcclusionQueriesNV(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDeleteOcclusionQueriesNV(n, ids_);
        }
        
        public static void glDeletePathsNV(uint path, int range) {
            Pointers.glDeletePathsNV(path, range);
        }
        
        public static void glDeletePerfMonitorsAMD(int n, uint* monitors) {
            Pointers.glDeletePerfMonitorsAMD(n, monitors);
        }
        
        public static void glDeletePerfMonitorsAMD(int n, uint[] monitors) {
            fixed(uint* monitors_ = &monitors[0])
                Pointers.glDeletePerfMonitorsAMD(n, monitors_);
        }
        
        public static void glDeletePerfQueryINTEL(uint queryHandle) {
            Pointers.glDeletePerfQueryINTEL(queryHandle);
        }
        
        /// <summary>
        /// Deletes a program object
        /// <para>
        /// glDeleteProgram frees the memory and invalidates the name associated with the program object
        /// specified by program. This command effectively undoes the effects of a call to glCreateProgram
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be deleted.
        /// </param>
        public static void glDeleteProgram(uint program) {
            Pointers.glDeleteProgram(program);
        }
        
        /// <summary>
        /// delete program pipeline objects
        /// <para>
        /// glDeleteProgramPipelines deletes the n program pipeline objects whose names are stored in the array
        /// pipelines. Unused names in pipelines are ignored, as is the name zero. After a program pipeline
        /// object is deleted, its name is again unused and it has no contents. If program pipeline object that
        /// is currently bound is deleted, the binding for that object reverts to zero and no program pipeline
        /// object becomes current
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        public static void glDeleteProgramPipelines(int n, uint* pipelines) {
            Pointers.glDeleteProgramPipelines(n, pipelines);
        }
        
        /// <summary>
        /// delete program pipeline objects
        /// <para>
        /// glDeleteProgramPipelines deletes the n program pipeline objects whose names are stored in the array
        /// pipelines. Unused names in pipelines are ignored, as is the name zero. After a program pipeline
        /// object is deleted, its name is again unused and it has no contents. If program pipeline object that
        /// is currently bound is deleted, the binding for that object reverts to zero and no program pipeline
        /// object becomes current
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline objects to delete.
        /// </param>
        /// <param name="pipelines">
        /// Specifies an array of names of program pipeline objects to delete.
        /// </param>
        public static void glDeleteProgramPipelines(int n, uint[] pipelines) {
            fixed(uint* pipelines_ = &pipelines[0])
                Pointers.glDeleteProgramPipelines(n, pipelines_);
        }
        
        public static void glDeleteProgramPipelinesEXT(int n, uint* pipelines) {
            Pointers.glDeleteProgramPipelinesEXT(n, pipelines);
        }
        
        public static void glDeleteProgramPipelinesEXT(int n, uint[] pipelines) {
            fixed(uint* pipelines_ = &pipelines[0])
                Pointers.glDeleteProgramPipelinesEXT(n, pipelines_);
        }
        
        public static void glDeleteProgramsARB(int n, uint* programs) {
            Pointers.glDeleteProgramsARB(n, programs);
        }
        
        public static void glDeleteProgramsARB(int n, uint[] programs) {
            fixed(uint* programs_ = &programs[0])
                Pointers.glDeleteProgramsARB(n, programs_);
        }
        
        public static void glDeleteProgramsNV(int n, uint* programs) {
            Pointers.glDeleteProgramsNV(n, programs);
        }
        
        public static void glDeleteProgramsNV(int n, uint[] programs) {
            fixed(uint* programs_ = &programs[0])
                Pointers.glDeleteProgramsNV(n, programs_);
        }
        
        /// <summary>
        /// delete named query objects
        /// <para>
        /// glDeleteQueries deletes n query objects named by the elements of the array ids. After a query object
        /// is deleted, it has no contents, and its name is free for reuse (for example by glGenQueries)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of query objects to be deleted.
        /// </param>
        public static void glDeleteQueries(int n, uint* ids) {
            Pointers.glDeleteQueries(n, ids);
        }
        
        /// <summary>
        /// delete named query objects
        /// <para>
        /// glDeleteQueries deletes n query objects named by the elements of the array ids. After a query object
        /// is deleted, it has no contents, and its name is free for reuse (for example by glGenQueries)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of query objects to be deleted.
        /// </param>
        public static void glDeleteQueries(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDeleteQueries(n, ids_);
        }
        
        /// <summary>
        /// delete named query objects
        /// <para>
        /// glDeleteQueries deletes n query objects named by the elements of the array ids. After a query object
        /// is deleted, it has no contents, and its name is free for reuse (for example by glGenQueries)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of query objects to be deleted.
        /// </param>
        public static void glDeleteQueriesARB(int n, uint* ids) {
            Pointers.glDeleteQueriesARB(n, ids);
        }
        
        /// <summary>
        /// delete named query objects
        /// <para>
        /// glDeleteQueries deletes n query objects named by the elements of the array ids. After a query object
        /// is deleted, it has no contents, and its name is free for reuse (for example by glGenQueries)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query objects to be deleted.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of query objects to be deleted.
        /// </param>
        public static void glDeleteQueriesARB(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDeleteQueriesARB(n, ids_);
        }
        
        public static void glDeleteQueriesEXT(int n, uint* ids) {
            Pointers.glDeleteQueriesEXT(n, ids);
        }
        
        public static void glDeleteQueriesEXT(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDeleteQueriesEXT(n, ids_);
        }
        
        public static void glDeleteQueryResourceTagNV(int n, int* tagIds) {
            Pointers.glDeleteQueryResourceTagNV(n, tagIds);
        }
        
        public static void glDeleteQueryResourceTagNV(int n, int[] tagIds) {
            fixed(int* tagIds_ = &tagIds[0])
                Pointers.glDeleteQueryResourceTagNV(n, tagIds_);
        }
        
        /// <summary>
        /// delete renderbuffer objects
        /// <para>
        /// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in the array
        /// addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it
        /// occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name
        /// is again unused and it has no contents. If a renderbuffer that is currently bound to the target
        /// GL_RENDERBUFFER is deleted, it is as though glBindRenderbuffer had been executed with a target of
        /// GL_RENDERBUFFER and a name of zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        public static void glDeleteRenderbuffers(int n, uint* renderbuffers) {
            Pointers.glDeleteRenderbuffers(n, renderbuffers);
        }
        
        /// <summary>
        /// delete renderbuffer objects
        /// <para>
        /// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in the array
        /// addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it
        /// occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name
        /// is again unused and it has no contents. If a renderbuffer that is currently bound to the target
        /// GL_RENDERBUFFER is deleted, it is as though glBindRenderbuffer had been executed with a target of
        /// GL_RENDERBUFFER and a name of zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        public static void glDeleteRenderbuffers(int n, uint[] renderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glDeleteRenderbuffers(n, renderbuffers_);
        }
        
        /// <summary>
        /// delete renderbuffer objects
        /// <para>
        /// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in the array
        /// addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it
        /// occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name
        /// is again unused and it has no contents. If a renderbuffer that is currently bound to the target
        /// GL_RENDERBUFFER is deleted, it is as though glBindRenderbuffer had been executed with a target of
        /// GL_RENDERBUFFER and a name of zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        public static void glDeleteRenderbuffersEXT(int n, uint* renderbuffers) {
            Pointers.glDeleteRenderbuffersEXT(n, renderbuffers);
        }
        
        /// <summary>
        /// delete renderbuffer objects
        /// <para>
        /// glDeleteRenderbuffers deletes the n renderbuffer objects whose names are stored in the array
        /// addressed by renderbuffers. The name zero is reserved by the GL and is silently ignored, should it
        /// occur in renderbuffers, as are other unused names. Once a renderbuffer object is deleted, its name
        /// is again unused and it has no contents. If a renderbuffer that is currently bound to the target
        /// GL_RENDERBUFFER is deleted, it is as though glBindRenderbuffer had been executed with a target of
        /// GL_RENDERBUFFER and a name of zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer objects to be deleted.
        /// </param>
        /// <param name="renderbuffers">
        /// A pointer to an array containing n renderbuffer objects to be deleted.
        /// </param>
        public static void glDeleteRenderbuffersEXT(int n, uint[] renderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glDeleteRenderbuffersEXT(n, renderbuffers_);
        }
        
        public static void glDeleteRenderbuffersOES(int n, uint* renderbuffers) {
            Pointers.glDeleteRenderbuffersOES(n, renderbuffers);
        }
        
        public static void glDeleteRenderbuffersOES(int n, uint[] renderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glDeleteRenderbuffersOES(n, renderbuffers_);
        }
        
        /// <summary>
        /// delete named sampler objects
        /// <para>
        /// glDeleteSamplers deletes n sampler objects named by the elements of the array samplers. After a
        /// sampler object is deleted, its name is again unused. If a sampler object that is currently bound to
        /// a sampler unit is deleted, it is as though glBindSampler is called with unit set to the unit the
        /// sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the
        /// reserved name zero
        /// </para>
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        public static void glDeleteSamplers(int count, uint* samplers) {
            Pointers.glDeleteSamplers(count, samplers);
        }
        
        /// <summary>
        /// delete named sampler objects
        /// <para>
        /// glDeleteSamplers deletes n sampler objects named by the elements of the array samplers. After a
        /// sampler object is deleted, its name is again unused. If a sampler object that is currently bound to
        /// a sampler unit is deleted, it is as though glBindSampler is called with unit set to the unit the
        /// sampler is bound to and sampler zero. Unused names in samplers are silently ignored, as is the
        /// reserved name zero
        /// </para>
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler objects to be deleted.
        /// </param>
        /// <param name="samplers">
        /// Specifies an array of sampler objects to be deleted.
        /// </param>
        public static void glDeleteSamplers(int count, uint[] samplers) {
            fixed(uint* samplers_ = &samplers[0])
                Pointers.glDeleteSamplers(count, samplers_);
        }
        
        public static void glDeleteSemaphoresEXT(int n, uint* semaphores) {
            Pointers.glDeleteSemaphoresEXT(n, semaphores);
        }
        
        public static void glDeleteSemaphoresEXT(int n, uint[] semaphores) {
            fixed(uint* semaphores_ = &semaphores[0])
                Pointers.glDeleteSemaphoresEXT(n, semaphores_);
        }
        
        /// <summary>
        /// Deletes a shader object
        /// <para>
        /// glDeleteShader frees the memory and invalidates the name associated with the shader object specified
        /// by shader. This command effectively undoes the effects of a call to glCreateShader
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be deleted.
        /// </param>
        public static void glDeleteShader(uint shader) {
            Pointers.glDeleteShader(shader);
        }
        
        public static void glDeleteStatesNV(int n, uint* states) {
            Pointers.glDeleteStatesNV(n, states);
        }
        
        public static void glDeleteStatesNV(int n, uint[] states) {
            fixed(uint* states_ = &states[0])
                Pointers.glDeleteStatesNV(n, states_);
        }
        
        /// <summary>
        /// delete a sync object
        /// <para>
        /// glDeleteSync deletes the sync object specified by sync. If the fence command corresponding to the
        /// specified sync object has completed, or if no glWaitSync or glClientWaitSync commands are blocking
        /// on sync, the object is deleted immediately. Otherwise, sync is flagged for deletion and will be
        /// deleted when it is no longer associated with any fence command and is no longer blocking any
        /// glWaitSync or glClientWaitSync command. In either case, after glDeleteSync returns, the name sync is
        /// invalid and can no longer be used to refer to the sync object
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// The sync object to be deleted.
        /// </param>
        public static void glDeleteSync(IntPtr sync) {
            Pointers.glDeleteSync(sync);
        }
        
        /// <summary>
        /// delete a sync object
        /// <para>
        /// glDeleteSync deletes the sync object specified by sync. If the fence command corresponding to the
        /// specified sync object has completed, or if no glWaitSync or glClientWaitSync commands are blocking
        /// on sync, the object is deleted immediately. Otherwise, sync is flagged for deletion and will be
        /// deleted when it is no longer associated with any fence command and is no longer blocking any
        /// glWaitSync or glClientWaitSync command. In either case, after glDeleteSync returns, the name sync is
        /// invalid and can no longer be used to refer to the sync object
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// The sync object to be deleted.
        /// </param>
        public static void glDeleteSyncAPPLE(IntPtr sync) {
            Pointers.glDeleteSyncAPPLE(sync);
        }
        
        /// <summary>
        /// delete named textures
        /// <para>
        /// glDeleteTextures deletes n textures named by the elements of the array textures. After a texture is
        /// deleted, it has no contents or dimensionality, and its name is free for reuse (for example by
        /// glGenTextures). If a texture that is currently bound is deleted, the binding reverts to 0 (the
        /// default texture)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">
        /// Specifies an array of textures to be deleted.
        /// </param>
        public static void glDeleteTextures(int n, uint* textures) {
            Pointers.glDeleteTextures(n, textures);
        }
        
        /// <summary>
        /// delete named textures
        /// <para>
        /// glDeleteTextures deletes n textures named by the elements of the array textures. After a texture is
        /// deleted, it has no contents or dimensionality, and its name is free for reuse (for example by
        /// glGenTextures). If a texture that is currently bound is deleted, the binding reverts to 0 (the
        /// default texture)
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be deleted.
        /// </param>
        /// <param name="textures">
        /// Specifies an array of textures to be deleted.
        /// </param>
        public static void glDeleteTextures(int n, uint[] textures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glDeleteTextures(n, textures_);
        }
        
        public static void glDeleteTexturesEXT(int n, uint* textures) {
            Pointers.glDeleteTexturesEXT(n, textures);
        }
        
        public static void glDeleteTexturesEXT(int n, uint[] textures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glDeleteTexturesEXT(n, textures_);
        }
        
        /// <summary>
        /// delete transform feedback objects
        /// <para>
        /// glDeleteTransformFeedbacks deletes the n transform feedback objects whose names are stored in the
        /// array ids. Unused names in ids are ignored, as is the name zero. After a transform feedback object
        /// is deleted, its name is again unused and it has no contents. If an active transform feedback object
        /// is deleted, its name immediately becomes unused, but the underlying object is not deleted until it
        /// is no longer active
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        public static void glDeleteTransformFeedbacks(int n, uint* ids) {
            Pointers.glDeleteTransformFeedbacks(n, ids);
        }
        
        /// <summary>
        /// delete transform feedback objects
        /// <para>
        /// glDeleteTransformFeedbacks deletes the n transform feedback objects whose names are stored in the
        /// array ids. Unused names in ids are ignored, as is the name zero. After a transform feedback object
        /// is deleted, its name is again unused and it has no contents. If an active transform feedback object
        /// is deleted, its name immediately becomes unused, but the underlying object is not deleted until it
        /// is no longer active
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        public static void glDeleteTransformFeedbacks(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDeleteTransformFeedbacks(n, ids_);
        }
        
        /// <summary>
        /// delete transform feedback objects
        /// <para>
        /// glDeleteTransformFeedbacks deletes the n transform feedback objects whose names are stored in the
        /// array ids. Unused names in ids are ignored, as is the name zero. After a transform feedback object
        /// is deleted, its name is again unused and it has no contents. If an active transform feedback object
        /// is deleted, its name immediately becomes unused, but the underlying object is not deleted until it
        /// is no longer active
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        public static void glDeleteTransformFeedbacksNV(int n, uint* ids) {
            Pointers.glDeleteTransformFeedbacksNV(n, ids);
        }
        
        /// <summary>
        /// delete transform feedback objects
        /// <para>
        /// glDeleteTransformFeedbacks deletes the n transform feedback objects whose names are stored in the
        /// array ids. Unused names in ids are ignored, as is the name zero. After a transform feedback object
        /// is deleted, its name is again unused and it has no contents. If an active transform feedback object
        /// is deleted, its name immediately becomes unused, but the underlying object is not deleted until it
        /// is no longer active
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback objects to delete.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of names of transform feedback objects to delete.
        /// </param>
        public static void glDeleteTransformFeedbacksNV(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glDeleteTransformFeedbacksNV(n, ids_);
        }
        
        /// <summary>
        /// delete vertex array objects
        /// <para>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array addressed by
        /// arrays. Once a vertex array object is deleted it has no contents and its name is again unused. If a
        /// vertex array object that is currently bound is deleted, the binding for that object reverts to zero
        /// and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the
        /// value zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        public static void glDeleteVertexArrays(int n, uint* arrays) {
            Pointers.glDeleteVertexArrays(n, arrays);
        }
        
        /// <summary>
        /// delete vertex array objects
        /// <para>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array addressed by
        /// arrays. Once a vertex array object is deleted it has no contents and its name is again unused. If a
        /// vertex array object that is currently bound is deleted, the binding for that object reverts to zero
        /// and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the
        /// value zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        public static void glDeleteVertexArrays(int n, uint[] arrays) {
            fixed(uint* arrays_ = &arrays[0])
                Pointers.glDeleteVertexArrays(n, arrays_);
        }
        
        /// <summary>
        /// delete vertex array objects
        /// <para>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array addressed by
        /// arrays. Once a vertex array object is deleted it has no contents and its name is again unused. If a
        /// vertex array object that is currently bound is deleted, the binding for that object reverts to zero
        /// and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the
        /// value zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        public static void glDeleteVertexArraysAPPLE(int n, uint* arrays) {
            Pointers.glDeleteVertexArraysAPPLE(n, arrays);
        }
        
        /// <summary>
        /// delete vertex array objects
        /// <para>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array addressed by
        /// arrays. Once a vertex array object is deleted it has no contents and its name is again unused. If a
        /// vertex array object that is currently bound is deleted, the binding for that object reverts to zero
        /// and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the
        /// value zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        public static void glDeleteVertexArraysAPPLE(int n, uint[] arrays) {
            fixed(uint* arrays_ = &arrays[0])
                Pointers.glDeleteVertexArraysAPPLE(n, arrays_);
        }
        
        /// <summary>
        /// delete vertex array objects
        /// <para>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array addressed by
        /// arrays. Once a vertex array object is deleted it has no contents and its name is again unused. If a
        /// vertex array object that is currently bound is deleted, the binding for that object reverts to zero
        /// and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the
        /// value zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        public static void glDeleteVertexArraysOES(int n, uint* arrays) {
            Pointers.glDeleteVertexArraysOES(n, arrays);
        }
        
        /// <summary>
        /// delete vertex array objects
        /// <para>
        /// glDeleteVertexArrays deletes n vertex array objects whose names are stored in the array addressed by
        /// arrays. Once a vertex array object is deleted it has no contents and its name is again unused. If a
        /// vertex array object that is currently bound is deleted, the binding for that object reverts to zero
        /// and the default vertex array becomes current. Unused names in arrays are silently ignored, as is the
        /// value zero
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array objects to be deleted.
        /// </param>
        /// <param name="arrays">
        /// Specifies the address of an array containing the n names of the objects to be deleted.
        /// </param>
        public static void glDeleteVertexArraysOES(int n, uint[] arrays) {
            fixed(uint* arrays_ = &arrays[0])
                Pointers.glDeleteVertexArraysOES(n, arrays_);
        }
        
        public static void glDeleteVertexShaderEXT(uint id) {
            Pointers.glDeleteVertexShaderEXT(id);
        }
        
        public static void glDepthBoundsEXT(double zmin, double zmax) {
            Pointers.glDepthBoundsEXT(zmin, zmax);
        }
        
        public static void glDepthBoundsdNV(double zmin, double zmax) {
            Pointers.glDepthBoundsdNV(zmin, zmax);
        }
        
        /// <summary>
        /// specify the value used for depth buffer comparisons
        /// <para>
        /// glDepthFunc specifies the function used to compare each incoming pixel depth value with the depth
        /// value present in the depth buffer. The comparison is performed only if depth testing is enabled.
        /// (See glEnable and glDisable of GL_DEPTH_TEST.)
        /// </para>
        /// </summary>
        /// <param name="func">
        /// Specifies the depth comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL,
        /// GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, and GL_ALWAYS are accepted. The initial value is GL_LESS.
        /// </param>
        public static void glDepthFunc(int func) {
            Pointers.glDepthFunc(func);
        }
        
        /// <summary>
        /// enable or disable writing into the depth buffer
        /// <para>
        /// glDepthMask specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth
        /// buffer writing is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled
        /// </para>
        /// </summary>
        /// <param name="flag">
        /// Specifies whether the depth buffer is enabled for writing. If flag is GL_FALSE, depth buffer writing
        /// is disabled. Otherwise, it is enabled. Initially, depth buffer writing is enabled.
        /// </param>
        public static void glDepthMask(bool flag) {
            Pointers.glDepthMask(flag);
        }
        
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates
        /// <para>
        /// After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near
        /// and far clipping planes. glDepthRange specifies a linear mapping of the normalized depth coordinates
        /// in this range to window depth coordinates. Regardless of the actual depth buffer implementation,
        /// window coordinate depth values are treated as though they range from 0 through 1 (like color
        /// components). Thus, the values accepted by glDepthRange are both clamped to this range before they
        /// are accepted
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
        /// </param>
        /// <param name="f">
        /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
        /// </param>
        public static void glDepthRange(double n, double f) {
            Pointers.glDepthRange(n, f);
        }
        
        public static void glDepthRangeArrayfvNV(uint first, int count, float* v) {
            Pointers.glDepthRangeArrayfvNV(first, count, v);
        }
        
        public static void glDepthRangeArrayfvNV(uint first, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glDepthRangeArrayfvNV(first, count, v_);
        }
        
        public static void glDepthRangeArrayfvOES(uint first, int count, float* v) {
            Pointers.glDepthRangeArrayfvOES(first, count, v);
        }
        
        public static void glDepthRangeArrayfvOES(uint first, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glDepthRangeArrayfvOES(first, count, v_);
        }
        
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
        /// <para>
        /// After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near
        /// and far clipping planes. Each viewport has an independent depth range specified as a linear mapping
        /// of the normalized depth coordinates in this range to window depth coordinates. Regardless of the
        /// actual depth buffer implementation, window coordinate depth values are treated as though they range
        /// from 0 through 1 (like color components). glDepthRangeArray specifies a linear mapping of the
        /// normalized depth coordinates in this range to window depth coordinates for each viewport in the
        /// range [first, first + count). Thus, the values accepted by glDepthRangeArray are both clamped to
        /// this range before they are accepted
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose depth range to update.
        /// </param>
        /// <param name="count">
        /// Specifies the number of viewports whose depth range to update.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the near and far values for the depth range of each
        /// modified viewport.
        /// </param>
        public static void glDepthRangeArrayv(uint first, int count, double* v) {
            Pointers.glDepthRangeArrayv(first, count, v);
        }
        
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates for a specified set of viewports
        /// <para>
        /// After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near
        /// and far clipping planes. Each viewport has an independent depth range specified as a linear mapping
        /// of the normalized depth coordinates in this range to window depth coordinates. Regardless of the
        /// actual depth buffer implementation, window coordinate depth values are treated as though they range
        /// from 0 through 1 (like color components). glDepthRangeArray specifies a linear mapping of the
        /// normalized depth coordinates in this range to window depth coordinates for each viewport in the
        /// range [first, first + count). Thus, the values accepted by glDepthRangeArray are both clamped to
        /// this range before they are accepted
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose depth range to update.
        /// </param>
        /// <param name="count">
        /// Specifies the number of viewports whose depth range to update.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the near and far values for the depth range of each
        /// modified viewport.
        /// </param>
        public static void glDepthRangeArrayv(uint first, int count, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glDepthRangeArrayv(first, count, v_);
        }
        
        /// <summary>
        /// specify mapping of depth values from normalized device coordinates to window coordinates for a specified viewport
        /// <para>
        /// After clipping and division by w, depth coordinates range from -1 to 1, corresponding to the near
        /// and far clipping planes. Each viewport has an independent depth range specified as a linear mapping
        /// of the normalized depth coordinates in this range to window depth coordinates. Regardless of the
        /// actual depth buffer implementation, window coordinate depth values are treated as though they range
        /// from 0 through 1 (like color components). glDepthRangeIndexed specifies a linear mapping of the
        /// normalized depth coordinates in this range to window depth coordinates for a specified viewport.
        /// Thus, the values accepted by glDepthRangeIndexed are both clamped to this range before they are
        /// accepted
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the viewport whose depth range to update.
        /// </param>
        /// <param name="n">
        /// Specifies the mapping of the near clipping plane to window coordinates. The initial value is 0.
        /// </param>
        /// <param name="f">
        /// Specifies the mapping of the far clipping plane to window coordinates. The initial value is 1.
        /// </param>
        public static void glDepthRangeIndexed(uint index, double n, double f) {
            Pointers.glDepthRangeIndexed(index, n, f);
        }
        
        public static void glDepthRangeIndexedfNV(uint index, float n, float f) {
            Pointers.glDepthRangeIndexedfNV(index, n, f);
        }
        
        public static void glDepthRangeIndexedfOES(uint index, float n, float f) {
            Pointers.glDepthRangeIndexedfOES(index, n, f);
        }
        
        public static void glDepthRangedNV(double zNear, double zFar) {
            Pointers.glDepthRangedNV(zNear, zFar);
        }
        
        public static void glDepthRangef(float n, float f) {
            Pointers.glDepthRangef(n, f);
        }
        
        public static void glDepthRangefOES(float n, float f) {
            Pointers.glDepthRangefOES(n, f);
        }
        
        public static void glDepthRangex(IntPtr n, IntPtr f) {
            Pointers.glDepthRangex(n, f);
        }
        
        public static void glDepthRangexOES(IntPtr n, IntPtr f) {
            Pointers.glDepthRangexOES(n, f);
        }
        
        /// <summary>
        /// Detaches a shader object from a program object to which it is attached
        /// <para>
        /// glDetachShader detaches the shader object specified by shader from the program object specified by
        /// program. This command can be used to undo the effect of the command glAttachShader
        /// </para>
        /// </summary>
        /// <param name="containerObj">
        /// Specifies the program object from which to detach the shader object.
        /// </param>
        /// <param name="attachedObj">
        /// Specifies the shader object to be detached.
        /// </param>
        public static void glDetachObjectARB(uint containerObj, uint attachedObj) {
            Pointers.glDetachObjectARB(containerObj, attachedObj);
        }
        
        /// <summary>
        /// Detaches a shader object from a program object to which it is attached
        /// <para>
        /// glDetachShader detaches the shader object specified by shader from the program object specified by
        /// program. This command can be used to undo the effect of the command glAttachShader
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object from which to detach the shader object.
        /// </param>
        /// <param name="shader">
        /// Specifies the shader object to be detached.
        /// </param>
        public static void glDetachShader(uint program, uint shader) {
            Pointers.glDetachShader(program, shader);
        }
        
        public static void glDetailTexFuncSGIS(int target, int n, float* points) {
            Pointers.glDetailTexFuncSGIS(target, n, points);
        }
        
        public static void glDetailTexFuncSGIS(int target, int n, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glDetailTexFuncSGIS(target, n, points_);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        public static void glDisable(int cap) {
            Pointers.glDisable(cap);
        }
        
        /// <summary>
        /// enable or disable client-side capability
        /// <para>
        /// glEnableClientState and glDisableClientState enable or disable individual client-side capabilities.
        /// By default, all client-side capabilities are disabled. Both glEnableClientState and
        /// glDisableClientState take a single argument, cap, which can assume one of the following values:
        /// </para>
        /// </summary>
        /// <param name="array">
        /// Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY,
        /// GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY,
        /// GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted.
        /// </param>
        public static void glDisableClientState(int array) {
            Pointers.glDisableClientState(array);
        }
        
        public static void glDisableClientStateIndexedEXT(int array, uint index) {
            Pointers.glDisableClientStateIndexedEXT(array, index);
        }
        
        public static void glDisableClientStateiEXT(int array, uint index) {
            Pointers.glDisableClientStateiEXT(array, index);
        }
        
        public static void glDisableDriverControlQCOM(uint driverControl) {
            Pointers.glDisableDriverControlQCOM(driverControl);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glDisableIndexedEXT(int target, uint index) {
            Pointers.glDisableIndexedEXT(target, index);
        }
        
        public static void glDisableVariantClientStateEXT(uint id) {
            Pointers.glDisableVariantClientStateEXT(id);
        }
        
        public static void glDisableVertexArrayAttrib(uint vaobj, uint index) {
            Pointers.glDisableVertexArrayAttrib(vaobj, index);
        }
        
        public static void glDisableVertexArrayAttribEXT(uint vaobj, uint index) {
            Pointers.glDisableVertexArrayAttribEXT(vaobj, index);
        }
        
        public static void glDisableVertexArrayEXT(uint vaobj, int array) {
            Pointers.glDisableVertexArrayEXT(vaobj, array);
        }
        
        public static void glDisableVertexAttribAPPLE(uint index, int pname) {
            Pointers.glDisableVertexAttribAPPLE(index, pname);
        }
        
        public static void glDisableVertexAttribArray(uint index) {
            Pointers.glDisableVertexAttribArray(index);
        }
        
        public static void glDisableVertexAttribArrayARB(uint index) {
            Pointers.glDisableVertexAttribArrayARB(index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glDisablei(int target, uint index) {
            Pointers.glDisablei(target, index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glDisableiEXT(int target, uint index) {
            Pointers.glDisableiEXT(target, index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glDisableiNV(int target, uint index) {
            Pointers.glDisableiNV(target, index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glDisableiOES(int target, uint index) {
            Pointers.glDisableiOES(target, index);
        }
        
        public static void glDiscardFramebufferEXT(int target, int numAttachments, uint* attachments) {
            Pointers.glDiscardFramebufferEXT(target, numAttachments, attachments);
        }
        
        public static void glDiscardFramebufferEXT(int target, int numAttachments, uint[] attachments) {
            fixed(uint* attachments_ = &attachments[0])
                Pointers.glDiscardFramebufferEXT(target, numAttachments, attachments_);
        }
        
        /// <summary>
        /// launch one or more compute work groups
        /// <para>
        /// glDispatchCompute launches one or more compute work groups. Each work group is processed by the
        /// active program object for the compute shader stage. While the individual shader invocations within a
        /// work group are executed as a unit, work groups are executed completely independently and in
        /// unspecified order. num_groups_x, num_groups_y and num_groups_z specify the number of local work
        /// groups that will be dispatched in the X, Y and Z dimensions, respectively
        /// </para>
        /// </summary>
        /// <param name="num_groups_x">
        /// The number of work groups to be launched in the X dimension.
        /// </param>
        /// <param name="num_groups_y">
        /// The number of work groups to be launched in the Y dimension.
        /// </param>
        /// <param name="num_groups_z">
        /// The number of work groups to be launched in the Z dimension.
        /// </param>
        public static void glDispatchCompute(uint num_groups_x, uint num_groups_y, uint num_groups_z) {
            Pointers.glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
        }
        
        public static void glDispatchComputeGroupSizeARB(uint num_groups_x, uint num_groups_y, uint num_groups_z, uint group_size_x, uint group_size_y, uint group_size_z) {
            Pointers.glDispatchComputeGroupSizeARB(num_groups_x, num_groups_y, num_groups_z, group_size_x, group_size_y, group_size_z);
        }
        
        /// <summary>
        /// launch one or more compute work groups using parameters stored in a buffer
        /// <para>
        /// glDispatchComputeIndirect launches one or more compute work groups using parameters stored in the
        /// buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER target. Each work group is
        /// processed by the active program object for the compute shader stage. While the individual shader
        /// invocations within a work group are executed as a unit, work groups are executed completely
        /// independently and in unspecified order. indirect contains the offset into the data store of the
        /// buffer object bound to the GL_DISPATCH_INDIRECT_BUFFER target at which the parameters are stored
        /// </para>
        /// </summary>
        /// <param name="indirect">
        /// The offset into the buffer object currently bound to the GL_DISPATCH_INDIRECT_BUFFER buffer target
        /// at which the dispatch parameters are stored.
        /// </param>
        public static void glDispatchComputeIndirect(uint indirect) {
            Pointers.glDispatchComputeIndirect(indirect);
        }
        
        /// <summary>
        /// render primitives from array data
        /// <para>
        /// glDrawArrays specifies multiple geometric primitives with very few subroutine calls. Instead of
        /// calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or
        /// color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct
        /// a sequence of primitives with a single call to glDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        public static void glDrawArrays(int mode, int first, int count) {
            Pointers.glDrawArrays(mode, first, count);
        }
        
        /// <summary>
        /// render primitives from array data
        /// <para>
        /// glDrawArrays specifies multiple geometric primitives with very few subroutine calls. Instead of
        /// calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge flag, or
        /// color, you can prespecify separate arrays of vertices, normals, and colors and use them to construct
        /// a sequence of primitives with a single call to glDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        public static void glDrawArraysEXT(int mode, int first, int count) {
            Pointers.glDrawArraysEXT(mode, first, count);
        }
        
        /// <summary>
        /// render primitives from array data, taking parameters from memory
        /// <para>
        /// glDrawArraysIndirect specifies multiple geometric primitives with very few subroutine calls.
        /// glDrawArraysIndirect behaves similarly to glDrawArraysInstancedBaseInstance, execept that the
        /// parameters to glDrawArraysInstancedBaseInstance are stored in memory at the address given by
        /// indirect
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        public static void glDrawArraysIndirect(int mode, IntPtr indirect) {
            Pointers.glDrawArraysIndirect(mode, indirect);
        }
        
        /// <summary>
        /// draw multiple instances of a range of elements
        /// <para>
        /// glDrawArraysInstanced behaves identically to glDrawArrays except that primcount instances of the
        /// range of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawArraysInstanced(int mode, int first, int count, int instancecount) {
            Pointers.glDrawArraysInstanced(mode, first, count, instancecount);
        }
        
        /// <summary>
        /// draw multiple instances of a range of elements
        /// <para>
        /// glDrawArraysInstanced behaves identically to glDrawArrays except that primcount instances of the
        /// range of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawArraysInstancedANGLE(int mode, int first, int count, int primcount) {
            Pointers.glDrawArraysInstancedANGLE(mode, first, count, primcount);
        }
        
        /// <summary>
        /// draw multiple instances of a range of elements
        /// <para>
        /// glDrawArraysInstanced behaves identically to glDrawArrays except that primcount instances of the
        /// range of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawArraysInstancedARB(int mode, int first, int count, int primcount) {
            Pointers.glDrawArraysInstancedARB(mode, first, count, primcount);
        }
        
        /// <summary>
        /// draw multiple instances of a range of elements with offset applied to instanced attributes
        /// <para>
        /// glDrawArraysInstancedBaseInstance behaves identically to glDrawArrays except that primcount
        /// instances of the range of elements are executed and the value of the internal counter instanceID
        /// advances for each iteration. instanceID is an internal 32-bit integer counter that may be read by a
        /// vertex shader as gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        /// <param name="baseinstance">
        /// Specifies the base instance for use in fetching instanced vertex attributes.
        /// </param>
        public static void glDrawArraysInstancedBaseInstance(int mode, int first, int count, int instancecount, uint baseinstance) {
            Pointers.glDrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance);
        }
        
        /// <summary>
        /// draw multiple instances of a range of elements with offset applied to instanced attributes
        /// <para>
        /// glDrawArraysInstancedBaseInstance behaves identically to glDrawArrays except that primcount
        /// instances of the range of elements are executed and the value of the internal counter instanceID
        /// advances for each iteration. instanceID is an internal 32-bit integer counter that may be read by a
        /// vertex shader as gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        /// <param name="baseinstance">
        /// Specifies the base instance for use in fetching instanced vertex attributes.
        /// </param>
        public static void glDrawArraysInstancedBaseInstanceEXT(int mode, int first, int count, int instancecount, uint baseinstance) {
            Pointers.glDrawArraysInstancedBaseInstanceEXT(mode, first, count, instancecount, baseinstance);
        }
        
        /// <summary>
        /// draw multiple instances of a range of elements
        /// <para>
        /// glDrawArraysInstanced behaves identically to glDrawArrays except that primcount instances of the
        /// range of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawArraysInstancedEXT(int mode, int start, int count, int primcount) {
            Pointers.glDrawArraysInstancedEXT(mode, start, count, primcount);
        }
        
        /// <summary>
        /// draw multiple instances of a range of elements
        /// <para>
        /// glDrawArraysInstanced behaves identically to glDrawArrays except that primcount instances of the
        /// range of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="first">
        /// Specifies the starting index in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Specifies the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawArraysInstancedNV(int mode, int first, int count, int primcount) {
            Pointers.glDrawArraysInstancedNV(mode, first, count, primcount);
        }
        
        /// <summary>
        /// specify which color buffers are to be drawn into
        /// </summary>
        /// <param name="buf">
        /// For default framebuffer, the argument specifies up to four color buffers to be drawn into. Symbolic
        /// constants GL_NONE, GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT, GL_BACK_RIGHT, GL_FRONT, GL_BACK,
        /// GL_LEFT, GL_RIGHT, and GL_FRONT_AND_BACK are accepted. The initial value is GL_FRONT for
        /// single-buffered contexts, and GL_BACK for double-buffered contexts. For framebuffer objects,
        /// GL_COLOR_ATTACHMENT$m$ and GL_NONE enums are accepted, where $m$ is a value between 0 and
        /// GL_MAX_COLOR_ATTACHMENTS.
        /// </param>
        public static void glDrawBuffer(int buf) {
            Pointers.glDrawBuffer(buf);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffers(int n, uint* bufs) {
            Pointers.glDrawBuffers(n, bufs);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffers(int n, uint[] bufs) {
            fixed(uint* bufs_ = &bufs[0])
                Pointers.glDrawBuffers(n, bufs_);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffersARB(int n, uint* bufs) {
            Pointers.glDrawBuffersARB(n, bufs);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffersARB(int n, uint[] bufs) {
            fixed(uint* bufs_ = &bufs[0])
                Pointers.glDrawBuffersARB(n, bufs_);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffersATI(int n, uint* bufs) {
            Pointers.glDrawBuffersATI(n, bufs);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffersATI(int n, uint[] bufs) {
            fixed(uint* bufs_ = &bufs[0])
                Pointers.glDrawBuffersATI(n, bufs_);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffersEXT(int n, uint* bufs) {
            Pointers.glDrawBuffersEXT(n, bufs);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffers in bufs.
        /// </param>
        /// <param name="bufs">
        /// Points to an array of symbolic constants specifying the buffers into which fragment colors or data
        /// values will be written.
        /// </param>
        public static void glDrawBuffersEXT(int n, uint[] bufs) {
            fixed(uint* bufs_ = &bufs[0])
                Pointers.glDrawBuffersEXT(n, bufs_);
        }
        
        public static void glDrawBuffersIndexedEXT(int n, uint* location, int* indices) {
            Pointers.glDrawBuffersIndexedEXT(n, location, indices);
        }
        
        public static void glDrawBuffersIndexedEXT(int n, uint* location, int[] indices) {
            fixed(int* indices_ = &indices[0])
                Pointers.glDrawBuffersIndexedEXT(n, location, indices_);
        }
        
        public static void glDrawBuffersIndexedEXT(int n, uint[] location, int* indices) {
            fixed(uint* location_ = &location[0])
                Pointers.glDrawBuffersIndexedEXT(n, location_, indices);
        }
        
        public static void glDrawBuffersIndexedEXT(int n, uint[] location, int[] indices) {
            fixed(uint* location_ = &location[0])
            fixed(int* indices_ = &indices[0])
                Pointers.glDrawBuffersIndexedEXT(n, location_, indices_);
        }
        
        public static void glDrawBuffersNV(int n, uint* bufs) {
            Pointers.glDrawBuffersNV(n, bufs);
        }
        
        public static void glDrawBuffersNV(int n, uint[] bufs) {
            fixed(uint* bufs_ = &bufs[0])
                Pointers.glDrawBuffersNV(n, bufs_);
        }
        
        public static void glDrawCommandsAddressNV(int primitiveMode, ulong* indirects, int* sizes, uint count) {
            Pointers.glDrawCommandsAddressNV(primitiveMode, indirects, sizes, count);
        }
        
        public static void glDrawCommandsAddressNV(int primitiveMode, ulong* indirects, int[] sizes, uint count) {
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsAddressNV(primitiveMode, indirects, sizes_, count);
        }
        
        public static void glDrawCommandsAddressNV(int primitiveMode, ulong[] indirects, int* sizes, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
                Pointers.glDrawCommandsAddressNV(primitiveMode, indirects_, sizes, count);
        }
        
        public static void glDrawCommandsAddressNV(int primitiveMode, ulong[] indirects, int[] sizes, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsAddressNV(primitiveMode, indirects_, sizes_, count);
        }
        
        public static void glDrawCommandsNV(int primitiveMode, uint buffer, uint* indirects, int* sizes, uint count) {
            Pointers.glDrawCommandsNV(primitiveMode, buffer, indirects, sizes, count);
        }
        
        public static void glDrawCommandsNV(int primitiveMode, uint buffer, uint* indirects, int[] sizes, uint count) {
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsNV(primitiveMode, buffer, indirects, sizes_, count);
        }
        
        public static void glDrawCommandsNV(int primitiveMode, uint buffer, uint[] indirects, int* sizes, uint count) {
            fixed(uint* indirects_ = &indirects[0])
                Pointers.glDrawCommandsNV(primitiveMode, buffer, indirects_, sizes, count);
        }
        
        public static void glDrawCommandsNV(int primitiveMode, uint buffer, uint[] indirects, int[] sizes, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsNV(primitiveMode, buffer, indirects_, sizes_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint* fbos, uint count) {
            Pointers.glDrawCommandsStatesAddressNV(indirects, sizes, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint* states, uint[] fbos, uint count) {
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects, sizes, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint[] states, uint* fbos, uint count) {
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects, sizes, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int* sizes, uint[] states, uint[] fbos, uint count) {
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects, sizes, states_, fbos_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int[] sizes, uint* states, uint* fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects, sizes_, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int[] sizes, uint* states, uint[] fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects, sizes_, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int[] sizes, uint[] states, uint* fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects, sizes_, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong* indirects, int[] sizes, uint[] states, uint[] fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects, sizes_, states_, fbos_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int* sizes, uint* states, uint* fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int* sizes, uint* states, uint[] fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int* sizes, uint[] states, uint* fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int* sizes, uint[] states, uint[] fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes, states_, fbos_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int[] sizes, uint* states, uint* fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes_, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int[] sizes, uint* states, uint[] fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes_, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int[] sizes, uint[] states, uint* fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes_, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesAddressNV(ulong[] indirects, int[] sizes, uint[] states, uint[] fbos, uint count) {
            fixed(ulong* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesAddressNV(indirects_, sizes_, states_, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int* sizes, uint* states, uint* fbos, uint count) {
            Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int* sizes, uint* states, uint[] fbos, uint count) {
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int* sizes, uint[] states, uint* fbos, uint count) {
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int* sizes, uint[] states, uint[] fbos, uint count) {
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes, states_, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int[] sizes, uint* states, uint* fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes_, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int[] sizes, uint* states, uint[] fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes_, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int[] sizes, uint[] states, uint* fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes_, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint* indirects, int[] sizes, uint[] states, uint[] fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects, sizes_, states_, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int* sizes, uint* states, uint* fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int* sizes, uint* states, uint[] fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int* sizes, uint[] states, uint* fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int* sizes, uint[] states, uint[] fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes, states_, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int[] sizes, uint* states, uint* fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes_, states, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int[] sizes, uint* states, uint[] fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes_, states, fbos_, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int[] sizes, uint[] states, uint* fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes_, states_, fbos, count);
        }
        
        public static void glDrawCommandsStatesNV(uint buffer, uint[] indirects, int[] sizes, uint[] states, uint[] fbos, uint count) {
            fixed(uint* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glDrawCommandsStatesNV(buffer, indirects_, sizes_, states_, fbos_, count);
        }
        
        public static void glDrawElementArrayAPPLE(int mode, int first, int count) {
            Pointers.glDrawElementArrayAPPLE(mode, first, count);
        }
        
        public static void glDrawElementArrayATI(int mode, int count) {
            Pointers.glDrawElementArrayATI(mode, count);
        }
        
        /// <summary>
        /// render primitives from array data
        /// <para>
        /// glDrawElements specifies multiple geometric primitives with very few subroutine calls. Instead of
        /// calling a GL function to pass each individual vertex, normal, texture coordinate, edge flag, or
        /// color, you can prespecify separate arrays of vertices, normals, and so on, and use them to construct
        /// a sequence of primitives with a single call to glDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        public static void glDrawElements(int mode, int count, int type, IntPtr indices) {
            Pointers.glDrawElements(mode, count, type, indices);
        }
        
        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsBaseVertex behaves identically to glDrawElements except that the ith element
        /// transferred by the corresponding draw call will be taken from element indices[i] + basevertex of
        /// each enabled array. If the resulting value is larger than the maximum value representable by type,
        /// it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow
        /// conditions). The operation is undefined if the sum would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawElementsBaseVertex(int mode, int count, int type, IntPtr indices, int basevertex) {
            Pointers.glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
        }
        
        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsBaseVertex behaves identically to glDrawElements except that the ith element
        /// transferred by the corresponding draw call will be taken from element indices[i] + basevertex of
        /// each enabled array. If the resulting value is larger than the maximum value representable by type,
        /// it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow
        /// conditions). The operation is undefined if the sum would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawElementsBaseVertexEXT(int mode, int count, int type, IntPtr indices, int basevertex) {
            Pointers.glDrawElementsBaseVertexEXT(mode, count, type, indices, basevertex);
        }
        
        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsBaseVertex behaves identically to glDrawElements except that the ith element
        /// transferred by the corresponding draw call will be taken from element indices[i] + basevertex of
        /// each enabled array. If the resulting value is larger than the maximum value representable by type,
        /// it is as if the calculation were upconverted to 32-bit unsigned integers (with wrapping on overflow
        /// conditions). The operation is undefined if the sum would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawElementsBaseVertexOES(int mode, int count, int type, IntPtr indices, int basevertex) {
            Pointers.glDrawElementsBaseVertexOES(mode, count, type, indices, basevertex);
        }
        
        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>
        /// glDrawElementsIndirect specifies multiple indexed geometric primitives with very few subroutine
        /// calls. glDrawElementsIndirect behaves similarly to glDrawElementsInstancedBaseVertexBaseInstance,
        /// execpt that the parameters to glDrawElementsInstancedBaseVertexBaseInstance are stored in memory at
        /// the address given by indirect
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing the draw parameters.
        /// </param>
        public static void glDrawElementsIndirect(int mode, int type, IntPtr indirect) {
            Pointers.glDrawElementsIndirect(mode, type, indirect);
        }
        
        /// <summary>
        /// draw multiple instances of a set of elements
        /// <para>
        /// glDrawElementsInstanced behaves identically to glDrawElements except that primcount instances of the
        /// set of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawElementsInstanced(int mode, int count, int type, IntPtr indices, int instancecount) {
            Pointers.glDrawElementsInstanced(mode, count, type, indices, instancecount);
        }
        
        /// <summary>
        /// draw multiple instances of a set of elements
        /// <para>
        /// glDrawElementsInstanced behaves identically to glDrawElements except that primcount instances of the
        /// set of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawElementsInstancedANGLE(int mode, int count, int type, IntPtr indices, int primcount) {
            Pointers.glDrawElementsInstancedANGLE(mode, count, type, indices, primcount);
        }
        
        /// <summary>
        /// draw multiple instances of a set of elements
        /// <para>
        /// glDrawElementsInstanced behaves identically to glDrawElements except that primcount instances of the
        /// set of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawElementsInstancedARB(int mode, int count, int type, IntPtr indices, int primcount) {
            Pointers.glDrawElementsInstancedARB(mode, count, type, indices, primcount);
        }
        
        /// <summary>
        /// draw multiple instances of a set of elements with offset applied to instanced attributes
        /// <para>
        /// glDrawElementsInstancedBaseInstance behaves identically to glDrawElements except that primcount
        /// instances of the set of elements are executed and the value of the internal counter instanceID
        /// advances for each iteration. instanceID is an internal 32-bit integer counter that may be read by a
        /// vertex shader as gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        /// <param name="baseinstance">
        /// Specifies the base instance for use in fetching instanced vertex attributes.
        /// </param>
        public static void glDrawElementsInstancedBaseInstance(int mode, int count, int type, IntPtr indices, int instancecount, uint baseinstance) {
            Pointers.glDrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
        }
        
        /// <summary>
        /// draw multiple instances of a set of elements with offset applied to instanced attributes
        /// <para>
        /// glDrawElementsInstancedBaseInstance behaves identically to glDrawElements except that primcount
        /// instances of the set of elements are executed and the value of the internal counter instanceID
        /// advances for each iteration. instanceID is an internal 32-bit integer counter that may be read by a
        /// vertex shader as gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        /// <param name="baseinstance">
        /// Specifies the base instance for use in fetching instanced vertex attributes.
        /// </param>
        public static void glDrawElementsInstancedBaseInstanceEXT(int mode, int count, int type, IntPtr indices, int instancecount, uint baseinstance) {
            Pointers.glDrawElementsInstancedBaseInstanceEXT(mode, count, type, indices, instancecount, baseinstance);
        }
        
        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsInstancedBaseVertex behaves identically to glDrawElementsInstanced except that the ith
        /// element transferred by the corresponding draw call will be taken from element indices[i] +
        /// basevertex of each enabled array. If the resulting value is larger than the maximum value
        /// representable by type, it is as if the calculation were upconverted to 32-bit unsigned integers
        /// (with wrapping on overflow conditions). The operation is undefined if the sum would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the indexed geometry that should be drawn.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawElementsInstancedBaseVertex(int mode, int count, int type, IntPtr indices, int instancecount, int basevertex) {
            Pointers.glDrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
        }
        
        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsInstancedBaseVertexBaseInstance behaves identically to glDrawElementsInstanced except
        /// that the ith element transferred by the corresponding draw call will be taken from element
        /// indices[i] + basevertex of each enabled array. If the resulting value is larger than the maximum
        /// value representable by type, it is as if the calculation were upconverted to 32-bit unsigned
        /// integers (with wrapping on overflow conditions). The operation is undefined if the sum would be
        /// negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the indexed geometry that should be drawn.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        /// <param name="baseinstance">
        /// Specifies the base instance for use in fetching instanced vertex attributes.
        /// </param>
        public static void glDrawElementsInstancedBaseVertexBaseInstance(int mode, int count, int type, IntPtr indices, int instancecount, int basevertex, uint baseinstance) {
            Pointers.glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
        }
        
        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsInstancedBaseVertexBaseInstance behaves identically to glDrawElementsInstanced except
        /// that the ith element transferred by the corresponding draw call will be taken from element
        /// indices[i] + basevertex of each enabled array. If the resulting value is larger than the maximum
        /// value representable by type, it is as if the calculation were upconverted to 32-bit unsigned
        /// integers (with wrapping on overflow conditions). The operation is undefined if the sum would be
        /// negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the indexed geometry that should be drawn.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        /// <param name="baseinstance">
        /// Specifies the base instance for use in fetching instanced vertex attributes.
        /// </param>
        public static void glDrawElementsInstancedBaseVertexBaseInstanceEXT(int mode, int count, int type, IntPtr indices, int instancecount, int basevertex, uint baseinstance) {
            Pointers.glDrawElementsInstancedBaseVertexBaseInstanceEXT(mode, count, type, indices, instancecount, basevertex, baseinstance);
        }
        
        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsInstancedBaseVertex behaves identically to glDrawElementsInstanced except that the ith
        /// element transferred by the corresponding draw call will be taken from element indices[i] +
        /// basevertex of each enabled array. If the resulting value is larger than the maximum value
        /// representable by type, it is as if the calculation were upconverted to 32-bit unsigned integers
        /// (with wrapping on overflow conditions). The operation is undefined if the sum would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the indexed geometry that should be drawn.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawElementsInstancedBaseVertexEXT(int mode, int count, int type, IntPtr indices, int instancecount, int basevertex) {
            Pointers.glDrawElementsInstancedBaseVertexEXT(mode, count, type, indices, instancecount, basevertex);
        }
        
        /// <summary>
        /// render multiple instances of a set of primitives from array data with a per-element offset
        /// <para>
        /// glDrawElementsInstancedBaseVertex behaves identically to glDrawElementsInstanced except that the ith
        /// element transferred by the corresponding draw call will be taken from element indices[i] +
        /// basevertex of each enabled array. If the resulting value is larger than the maximum value
        /// representable by type, it is as if the calculation were upconverted to 32-bit unsigned integers
        /// (with wrapping on overflow conditions). The operation is undefined if the sum would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the indexed geometry that should be drawn.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawElementsInstancedBaseVertexOES(int mode, int count, int type, IntPtr indices, int instancecount, int basevertex) {
            Pointers.glDrawElementsInstancedBaseVertexOES(mode, count, type, indices, instancecount, basevertex);
        }
        
        /// <summary>
        /// draw multiple instances of a set of elements
        /// <para>
        /// glDrawElementsInstanced behaves identically to glDrawElements except that primcount instances of the
        /// set of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawElementsInstancedEXT(int mode, int count, int type, IntPtr indices, int primcount) {
            Pointers.glDrawElementsInstancedEXT(mode, count, type, indices, primcount);
        }
        
        /// <summary>
        /// draw multiple instances of a set of elements
        /// <para>
        /// glDrawElementsInstanced behaves identically to glDrawElements except that primcount instances of the
        /// set of elements are executed and the value of the internal counter instanceID advances for each
        /// iteration. instanceID is an internal 32-bit integer counter that may be read by a vertex shader as
        /// gl_InstanceID
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of instances of the specified range of indices to be rendered.
        /// </param>
        public static void glDrawElementsInstancedNV(int mode, int count, int type, IntPtr indices, int primcount) {
            Pointers.glDrawElementsInstancedNV(mode, count, type, indices, primcount);
        }
        
        public static void glDrawMeshArraysSUN(int mode, int first, int count, int width) {
            Pointers.glDrawMeshArraysSUN(mode, first, count, width);
        }
        
        /// <summary>
        /// write a block of pixels to the frame buffer
        /// <para>
        /// glDrawPixels reads pixel data from memory and writes it into the frame buffer relative to the
        /// current raster position, provided that the raster position is valid. Use glRasterPos or glWindowPos
        /// to set the current raster position; use glGet with argument GL_CURRENT_RASTER_POSITION_VALID to
        /// determine if the specified raster position is valid, and glGet with argument
        /// GL_CURRENT_RASTER_POSITION to query the raster position
        /// </para>
        /// </summary>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle to be written into the frame buffer.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle to be written into the frame buffer.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. Symbolic constants GL_COLOR_INDEX, GL_STENCIL_INDEX,
        /// GL_DEPTH_COMPONENT, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, and GL_LUMINANCE_ALPHA are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the data type for data. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the pixel data.
        /// </param>
        public static void glDrawPixels(int width, int height, int format, int type, IntPtr pixels) {
            Pointers.glDrawPixels(width, height, format, type, pixels);
        }
        
        public static void glDrawRangeElementArrayAPPLE(int mode, uint start, uint end, int first, int count) {
            Pointers.glDrawRangeElementArrayAPPLE(mode, start, end, first, count);
        }
        
        public static void glDrawRangeElementArrayATI(int mode, uint start, uint end, int count) {
            Pointers.glDrawRangeElementArrayATI(mode, start, end, count);
        }
        
        /// <summary>
        /// render primitives from array data
        /// <para>
        /// glDrawRangeElements is a restricted form of glDrawElements. mode, and count match the corresponding
        /// arguments to glDrawElements, with the additional constraint that all values in the arrays count must
        /// lie between start and end, inclusive
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        public static void glDrawRangeElements(int mode, uint start, uint end, int count, int type, IntPtr indices) {
            Pointers.glDrawRangeElements(mode, start, end, count, type, indices);
        }
        
        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>
        /// glDrawRangeElementsBaseVertex is a restricted form of glDrawElementsBaseVertex. mode, count and
        /// basevertex match the corresponding arguments to glDrawElementsBaseVertex, with the additional
        /// constraint that all values in the array indices must lie between start and end, inclusive, prior to
        /// adding basevertex. Index values lying outside the range [start, end] are treated in the same way as
        /// glDrawElementsBaseVertex. The ith element transferred by the corresponding draw call will be taken
        /// from element indices[i] + basevertex of each enabled array. If the resulting value is larger than
        /// the maximum value representable by type, it is as if the calculation were upconverted to 32-bit
        /// unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum
        /// would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawRangeElementsBaseVertex(int mode, uint start, uint end, int count, int type, IntPtr indices, int basevertex) {
            Pointers.glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
        }
        
        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>
        /// glDrawRangeElementsBaseVertex is a restricted form of glDrawElementsBaseVertex. mode, count and
        /// basevertex match the corresponding arguments to glDrawElementsBaseVertex, with the additional
        /// constraint that all values in the array indices must lie between start and end, inclusive, prior to
        /// adding basevertex. Index values lying outside the range [start, end] are treated in the same way as
        /// glDrawElementsBaseVertex. The ith element transferred by the corresponding draw call will be taken
        /// from element indices[i] + basevertex of each enabled array. If the resulting value is larger than
        /// the maximum value representable by type, it is as if the calculation were upconverted to 32-bit
        /// unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum
        /// would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawRangeElementsBaseVertexEXT(int mode, uint start, uint end, int count, int type, IntPtr indices, int basevertex) {
            Pointers.glDrawRangeElementsBaseVertexEXT(mode, start, end, count, type, indices, basevertex);
        }
        
        /// <summary>
        /// render primitives from array data with a per-element offset
        /// <para>
        /// glDrawRangeElementsBaseVertex is a restricted form of glDrawElementsBaseVertex. mode, count and
        /// basevertex match the corresponding arguments to glDrawElementsBaseVertex, with the additional
        /// constraint that all values in the array indices must lie between start and end, inclusive, prior to
        /// adding basevertex. Index values lying outside the range [start, end] are treated in the same way as
        /// glDrawElementsBaseVertex. The ith element transferred by the corresponding draw call will be taken
        /// from element indices[i] + basevertex of each enabled array. If the resulting value is larger than
        /// the maximum value representable by type, it is as if the calculation were upconverted to 32-bit
        /// unsigned integers (with wrapping on overflow conditions). The operation is undefined if the sum
        /// would be negative
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_TRIANGLES, GL_LINES_ADJACENCY,
        /// GL_LINE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, GL_TRIANGLE_STRIP_ADJACENCY and GL_PATCHES are
        /// accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a constant that should be added to each element of indices when chosing elements from the
        /// enabled vertex arrays.
        /// </param>
        public static void glDrawRangeElementsBaseVertexOES(int mode, uint start, uint end, int count, int type, IntPtr indices, int basevertex) {
            Pointers.glDrawRangeElementsBaseVertexOES(mode, start, end, count, type, indices, basevertex);
        }
        
        /// <summary>
        /// render primitives from array data
        /// <para>
        /// glDrawRangeElements is a restricted form of glDrawElements. mode, and count match the corresponding
        /// arguments to glDrawElements, with the additional constraint that all values in the arrays count must
        /// lie between start and end, inclusive
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="start">
        /// Specifies the minimum array index contained in indices.
        /// </param>
        /// <param name="end">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements to be rendered.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies the maximum array index contained in indices.
        /// </param>
        public static void glDrawRangeElementsEXT(int mode, uint start, uint end, int count, int type, IntPtr indices) {
            Pointers.glDrawRangeElementsEXT(mode, start, end, count, type, indices);
        }
        
        public static void glDrawTexfOES(float x, float y, float z, float width, float height) {
            Pointers.glDrawTexfOES(x, y, z, width, height);
        }
        
        public static void glDrawTexfvOES(float* coords) {
            Pointers.glDrawTexfvOES(coords);
        }
        
        public static void glDrawTexfvOES(float[] coords) {
            fixed(float* coords_ = &coords[0])
                Pointers.glDrawTexfvOES(coords_);
        }
        
        public static void glDrawTexiOES(int x, int y, int z, int width, int height) {
            Pointers.glDrawTexiOES(x, y, z, width, height);
        }
        
        public static void glDrawTexivOES(int* coords) {
            Pointers.glDrawTexivOES(coords);
        }
        
        public static void glDrawTexivOES(int[] coords) {
            fixed(int* coords_ = &coords[0])
                Pointers.glDrawTexivOES(coords_);
        }
        
        public static void glDrawTexsOES(short x, short y, short z, short width, short height) {
            Pointers.glDrawTexsOES(x, y, z, width, height);
        }
        
        public static void glDrawTexsvOES(short* coords) {
            Pointers.glDrawTexsvOES(coords);
        }
        
        public static void glDrawTexsvOES(short[] coords) {
            fixed(short* coords_ = &coords[0])
                Pointers.glDrawTexsvOES(coords_);
        }
        
        public static void glDrawTextureNV(uint texture, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) {
            Pointers.glDrawTextureNV(texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
        }
        
        public static void glDrawTexxOES(IntPtr x, IntPtr y, IntPtr z, IntPtr width, IntPtr height) {
            Pointers.glDrawTexxOES(x, y, z, width, height);
        }
        
        public static void glDrawTexxvOES(IntPtr* coords) {
            Pointers.glDrawTexxvOES(coords);
        }
        
        public static void glDrawTexxvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glDrawTexxvOES(coords_);
        }
        
        /// <summary>
        /// render primitives using a count derived from a transform feedback object
        /// <para>
        /// glDrawTransformFeedback draws primitives of a type specified by mode using a count retrieved from
        /// the transform feedback specified by id. Calling glDrawTransformFeedback is equivalent to calling
        /// glDrawArrays with mode as specified, first set to zero, and count set to the number of vertices
        /// captured on vertex stream zero the last time transform feedback was active on the transform feedback
        /// object named by id
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
        /// </param>
        public static void glDrawTransformFeedback(int mode, uint id) {
            Pointers.glDrawTransformFeedback(mode, id);
        }
        
        /// <summary>
        /// render primitives using a count derived from a transform feedback object
        /// <para>
        /// glDrawTransformFeedback draws primitives of a type specified by mode using a count retrieved from
        /// the transform feedback specified by id. Calling glDrawTransformFeedback is equivalent to calling
        /// glDrawArrays with mode as specified, first set to zero, and count set to the number of vertices
        /// captured on vertex stream zero the last time transform feedback was active on the transform feedback
        /// object named by id
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
        /// </param>
        public static void glDrawTransformFeedbackEXT(int mode, uint id) {
            Pointers.glDrawTransformFeedbackEXT(mode, id);
        }
        
        /// <summary>
        /// render multiple instances of primitives using a count derived from a transform feedback object
        /// <para>
        /// glDrawTransformFeedbackInstanced draws multiple copies of a range of primitives of a type specified
        /// by mode using a count retrieved from the transform feedback stream specified by stream of the
        /// transform feedback object specified by id. Calling glDrawTransformFeedbackInstanced is equivalent to
        /// calling glDrawArraysInstanced with mode and primcount as specified, first set to zero, and count set
        /// to the number of vertices captured on vertex stream zero the last time transform feedback was active
        /// on the transform feedback object named by id
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the geometry to render.
        /// </param>
        public static void glDrawTransformFeedbackInstanced(int mode, uint id, int instancecount) {
            Pointers.glDrawTransformFeedbackInstanced(mode, id, instancecount);
        }
        
        /// <summary>
        /// render multiple instances of primitives using a count derived from a transform feedback object
        /// <para>
        /// glDrawTransformFeedbackInstanced draws multiple copies of a range of primitives of a type specified
        /// by mode using a count retrieved from the transform feedback stream specified by stream of the
        /// transform feedback object specified by id. Calling glDrawTransformFeedbackInstanced is equivalent to
        /// calling glDrawArraysInstanced with mode and primcount as specified, first set to zero, and count set
        /// to the number of vertices captured on vertex stream zero the last time transform feedback was active
        /// on the transform feedback object named by id
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the geometry to render.
        /// </param>
        public static void glDrawTransformFeedbackInstancedEXT(int mode, uint id, int instancecount) {
            Pointers.glDrawTransformFeedbackInstancedEXT(mode, id, instancecount);
        }
        
        /// <summary>
        /// render primitives using a count derived from a transform feedback object
        /// <para>
        /// glDrawTransformFeedback draws primitives of a type specified by mode using a count retrieved from
        /// the transform feedback specified by id. Calling glDrawTransformFeedback is equivalent to calling
        /// glDrawArrays with mode as specified, first set to zero, and count set to the number of vertices
        /// captured on vertex stream zero the last time transform feedback was active on the transform feedback
        /// object named by id
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
        /// </param>
        public static void glDrawTransformFeedbackNV(int mode, uint id) {
            Pointers.glDrawTransformFeedbackNV(mode, id);
        }
        
        /// <summary>
        /// render primitives using a count derived from a specifed stream of a transform feedback object
        /// <para>
        /// glDrawTransformFeedbackStream draws primitives of a type specified by mode using a count retrieved
        /// from the transform feedback stream specified by stream of the transform feedback object specified by
        /// id. Calling glDrawTransformFeedbackStream is equivalent to calling glDrawArrays with mode as
        /// specified, first set to zero, and count set to the number of vertices captured on vertex stream
        /// stream the last time transform feedback was active on the transform feedback object named by id
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
        /// </param>
        /// <param name="stream">
        /// Specifies the index of the transform feedback stream from which to retrieve a primitive count.
        /// </param>
        public static void glDrawTransformFeedbackStream(int mode, uint id, uint stream) {
            Pointers.glDrawTransformFeedbackStream(mode, id, stream);
        }
        
        /// <summary>
        /// render multiple instances of primitives using a count derived from a specifed stream of a transform feedback object
        /// <para>
        /// glDrawTransformFeedbackStreamInstanced draws multiple copies of a range of primitives of a type
        /// specified by mode using a count retrieved from the transform feedback stream specified by stream of
        /// the transform feedback object specified by id. Calling glDrawTransformFeedbackStreamInstanced is
        /// equivalent to calling glDrawArraysInstanced with mode and primcount as specified, first set to zero,
        /// and count set to the number of vertices captured on vertex stream stream the last time transform
        /// feedback was active on the transform feedback object named by id
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="id">
        /// Specifies the name of a transform feedback object from which to retrieve a primitive count.
        /// </param>
        /// <param name="stream">
        /// Specifies the index of the transform feedback stream from which to retrieve a primitive count.
        /// </param>
        /// <param name="instancecount">
        /// Specifies the number of instances of the geometry to render.
        /// </param>
        public static void glDrawTransformFeedbackStreamInstanced(int mode, uint id, uint stream, int instancecount) {
            Pointers.glDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);
        }
        
        public static void glEGLImageTargetRenderbufferStorageOES(int target, IntPtr image) {
            Pointers.glEGLImageTargetRenderbufferStorageOES(target, image);
        }
        
        public static void glEGLImageTargetTexStorageEXT(int target, IntPtr image, int* attrib_list) {
            Pointers.glEGLImageTargetTexStorageEXT(target, image, attrib_list);
        }
        
        public static void glEGLImageTargetTexStorageEXT(int target, IntPtr image, int[] attrib_list) {
            fixed(int* attrib_list_ = &attrib_list[0])
                Pointers.glEGLImageTargetTexStorageEXT(target, image, attrib_list_);
        }
        
        public static void glEGLImageTargetTexture2DOES(int target, IntPtr image) {
            Pointers.glEGLImageTargetTexture2DOES(target, image);
        }
        
        public static void glEGLImageTargetTextureStorageEXT(uint texture, IntPtr image, int* attrib_list) {
            Pointers.glEGLImageTargetTextureStorageEXT(texture, image, attrib_list);
        }
        
        public static void glEGLImageTargetTextureStorageEXT(uint texture, IntPtr image, int[] attrib_list) {
            fixed(int* attrib_list_ = &attrib_list[0])
                Pointers.glEGLImageTargetTextureStorageEXT(texture, image, attrib_list_);
        }
        
        /// <summary>
        /// flag edges as either boundary or nonboundary
        /// <para>
        /// Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a
        /// glBegin/glEnd pair is marked as the start of either a boundary or nonboundary edge. If the current
        /// edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary
        /// edge. Otherwise, the vertex is marked as the start of a nonboundary edge. glEdgeFlag sets the edge
        /// flag bit to GL_TRUE if flag is GL_TRUE and to GL_FALSE otherwise
        /// </para>
        /// </summary>
        /// <param name="flag">
        /// Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE.
        /// </param>
        public static void glEdgeFlag(bool flag) {
            Pointers.glEdgeFlag(flag);
        }
        
        public static void glEdgeFlagFormatNV(int stride) {
            Pointers.glEdgeFlagFormatNV(stride);
        }
        
        /// <summary>
        /// define an array of edge flags
        /// <para>
        /// glEdgeFlagPointer specifies the location and data format of an array of boolean edge flags to use
        /// when rendering. stride specifies the byte stride from one edge flag to the next, allowing vertices
        /// and attributes to be packed into a single array or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive edge flags. If stride is 0, the edge flags are
        /// understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first edge flag in the array. The initial value is 0.
        /// </param>
        public static void glEdgeFlagPointer(int stride, IntPtr pointer) {
            Pointers.glEdgeFlagPointer(stride, pointer);
        }
        
        public static void glEdgeFlagPointerEXT(int stride, int count, bool* pointer) {
            Pointers.glEdgeFlagPointerEXT(stride, count, pointer);
        }
        
        public static void glEdgeFlagPointerEXT(int stride, int count, bool[] pointer) {
            fixed(bool* pointer_ = &pointer[0])
                Pointers.glEdgeFlagPointerEXT(stride, count, pointer_);
        }
        
        public static void glEdgeFlagPointerListIBM(int stride, bool[] pointer, int ptrstride) {
            Pointers.glEdgeFlagPointerListIBM(stride, pointer, ptrstride);
        }
        
        /// <summary>
        /// flag edges as either boundary or nonboundary
        /// <para>
        /// Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a
        /// glBegin/glEnd pair is marked as the start of either a boundary or nonboundary edge. If the current
        /// edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary
        /// edge. Otherwise, the vertex is marked as the start of a nonboundary edge. glEdgeFlag sets the edge
        /// flag bit to GL_TRUE if flag is GL_TRUE and to GL_FALSE otherwise
        /// </para>
        /// </summary>
        /// <param name="flag">
        /// Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE.
        /// </param>
        public static void glEdgeFlagv(bool* flag) {
            Pointers.glEdgeFlagv(flag);
        }
        
        /// <summary>
        /// flag edges as either boundary or nonboundary
        /// <para>
        /// Each vertex of a polygon, separate triangle, or separate quadrilateral specified between a
        /// glBegin/glEnd pair is marked as the start of either a boundary or nonboundary edge. If the current
        /// edge flag is true when the vertex is specified, the vertex is marked as the start of a boundary
        /// edge. Otherwise, the vertex is marked as the start of a nonboundary edge. glEdgeFlag sets the edge
        /// flag bit to GL_TRUE if flag is GL_TRUE and to GL_FALSE otherwise
        /// </para>
        /// </summary>
        /// <param name="flag">
        /// Specifies the current edge flag value, either GL_TRUE or GL_FALSE. The initial value is GL_TRUE.
        /// </param>
        public static void glEdgeFlagv(out bool flag) {
            fixed(bool* flag_ = &flag)
                Pointers.glEdgeFlagv(flag_);
        }
        
        public static void glElementPointerAPPLE(int type, IntPtr pointer) {
            Pointers.glElementPointerAPPLE(type, pointer);
        }
        
        public static void glElementPointerATI(int type, IntPtr pointer) {
            Pointers.glElementPointerATI(type, pointer);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        public static void glEnable(int cap) {
            Pointers.glEnable(cap);
        }
        
        /// <summary>
        /// enable or disable client-side capability
        /// <para>
        /// glEnableClientState and glDisableClientState enable or disable individual client-side capabilities.
        /// By default, all client-side capabilities are disabled. Both glEnableClientState and
        /// glDisableClientState take a single argument, cap, which can assume one of the following values:
        /// </para>
        /// </summary>
        /// <param name="array">
        /// Specifies the capability to enable. Symbolic constants GL_COLOR_ARRAY, GL_EDGE_FLAG_ARRAY,
        /// GL_FOG_COORD_ARRAY, GL_INDEX_ARRAY, GL_NORMAL_ARRAY, GL_SECONDARY_COLOR_ARRAY,
        /// GL_TEXTURE_COORD_ARRAY, and GL_VERTEX_ARRAY are accepted.
        /// </param>
        public static void glEnableClientState(int array) {
            Pointers.glEnableClientState(array);
        }
        
        public static void glEnableClientStateIndexedEXT(int array, uint index) {
            Pointers.glEnableClientStateIndexedEXT(array, index);
        }
        
        public static void glEnableClientStateiEXT(int array, uint index) {
            Pointers.glEnableClientStateiEXT(array, index);
        }
        
        public static void glEnableDriverControlQCOM(uint driverControl) {
            Pointers.glEnableDriverControlQCOM(driverControl);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glEnableIndexedEXT(int target, uint index) {
            Pointers.glEnableIndexedEXT(target, index);
        }
        
        public static void glEnableVariantClientStateEXT(uint id) {
            Pointers.glEnableVariantClientStateEXT(id);
        }
        
        public static void glEnableVertexArrayAttrib(uint vaobj, uint index) {
            Pointers.glEnableVertexArrayAttrib(vaobj, index);
        }
        
        public static void glEnableVertexArrayAttribEXT(uint vaobj, uint index) {
            Pointers.glEnableVertexArrayAttribEXT(vaobj, index);
        }
        
        public static void glEnableVertexArrayEXT(uint vaobj, int array) {
            Pointers.glEnableVertexArrayEXT(vaobj, array);
        }
        
        public static void glEnableVertexAttribAPPLE(uint index, int pname) {
            Pointers.glEnableVertexAttribAPPLE(index, pname);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be enabled or disabled.
        /// </param>
        public static void glEnableVertexAttribArray(uint index) {
            Pointers.glEnableVertexAttribArray(index);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be enabled or disabled.
        /// </param>
        public static void glEnableVertexAttribArrayARB(uint index) {
            Pointers.glEnableVertexAttribArrayARB(index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glEnablei(int target, uint index) {
            Pointers.glEnablei(target, index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glEnableiEXT(int target, uint index) {
            Pointers.glEnableiEXT(target, index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glEnableiNV(int target, uint index) {
            Pointers.glEnableiNV(target, index);
        }
        
        /// <summary>
        /// enable or disable server-side GL capabilities
        /// <para>
        /// glEnable and glDisable enable and disable various capabilities. Use glIsEnabled or glGet to
        /// determine the current setting of any capability. The initial value for each capability with the
        /// exception of GL_DITHER and GL_MULTISAMPLE is GL_FALSE. The initial value for GL_DITHER and
        /// GL_MULTISAMPLE is GL_TRUE
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the switch to disable (for glEnablei and glDisablei only).
        /// </param>
        public static void glEnableiOES(int target, uint index) {
            Pointers.glEnableiOES(target, index);
        }
        
        /// <summary>
        /// delimit the vertices of a primitive or a group of like primitives
        /// <para>
        /// glBegin and glEnd delimit the vertices that define a primitive or a group of like primitives.
        /// glBegin accepts a single argument that specifies in which of ten ways the vertices are interpreted.
        /// Taking n as an integer count starting at one, and N as the total number of vertices specified, the
        /// interpretations are as follows:
        /// </para>
        /// </summary>
        public static void glEnd() {
            Pointers.glEnd();
        }
        
        /// <summary>
        /// start conditional rendering
        /// <para>
        /// Conditional rendering is started using glBeginConditionalRender and ended using
        /// glEndConditionalRender. During conditional rendering, all vertex array commands, as well as glClear
        /// and glClearBuffer have no effect if the (GL_SAMPLES_PASSED) result of the query object id is zero,
        /// or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE. The results of commands setting the current
        /// vertex state, such as glVertexAttrib are undefined. If the (GL_SAMPLES_PASSED) result is non-zero or
        /// if the (GL_ANY_SAMPLES_PASSED) result is GL_TRUE, such commands are not discarded. The id parameter
        /// to glBeginConditionalRender must be the name of a query object previously returned from a call to
        /// glGenQueries. mode specifies how the results of the query object are to be interpreted. If mode is
        /// GL_QUERY_WAIT, the GL waits for the results of the query to be available and then uses the results
        /// to determine if subsequent rendering commands are discarded. If mode is GL_QUERY_NO_WAIT, the GL may
        /// choose to unconditionally execute the subsequent rendering commands without waiting for the query to
        /// complete
        /// </para>
        /// </summary>
        public static void glEndConditionalRender() {
            Pointers.glEndConditionalRender();
        }
        
        /// <summary>
        /// start conditional rendering
        /// <para>
        /// Conditional rendering is started using glBeginConditionalRender and ended using
        /// glEndConditionalRender. During conditional rendering, all vertex array commands, as well as glClear
        /// and glClearBuffer have no effect if the (GL_SAMPLES_PASSED) result of the query object id is zero,
        /// or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE. The results of commands setting the current
        /// vertex state, such as glVertexAttrib are undefined. If the (GL_SAMPLES_PASSED) result is non-zero or
        /// if the (GL_ANY_SAMPLES_PASSED) result is GL_TRUE, such commands are not discarded. The id parameter
        /// to glBeginConditionalRender must be the name of a query object previously returned from a call to
        /// glGenQueries. mode specifies how the results of the query object are to be interpreted. If mode is
        /// GL_QUERY_WAIT, the GL waits for the results of the query to be available and then uses the results
        /// to determine if subsequent rendering commands are discarded. If mode is GL_QUERY_NO_WAIT, the GL may
        /// choose to unconditionally execute the subsequent rendering commands without waiting for the query to
        /// complete
        /// </para>
        /// </summary>
        public static void glEndConditionalRenderNV() {
            Pointers.glEndConditionalRenderNV();
        }
        
        /// <summary>
        /// start conditional rendering
        /// <para>
        /// Conditional rendering is started using glBeginConditionalRender and ended using
        /// glEndConditionalRender. During conditional rendering, all vertex array commands, as well as glClear
        /// and glClearBuffer have no effect if the (GL_SAMPLES_PASSED) result of the query object id is zero,
        /// or if the (GL_ANY_SAMPLES_PASSED) result is GL_FALSE. The results of commands setting the current
        /// vertex state, such as glVertexAttrib are undefined. If the (GL_SAMPLES_PASSED) result is non-zero or
        /// if the (GL_ANY_SAMPLES_PASSED) result is GL_TRUE, such commands are not discarded. The id parameter
        /// to glBeginConditionalRender must be the name of a query object previously returned from a call to
        /// glGenQueries. mode specifies how the results of the query object are to be interpreted. If mode is
        /// GL_QUERY_WAIT, the GL waits for the results of the query to be available and then uses the results
        /// to determine if subsequent rendering commands are discarded. If mode is GL_QUERY_NO_WAIT, the GL may
        /// choose to unconditionally execute the subsequent rendering commands without waiting for the query to
        /// complete
        /// </para>
        /// </summary>
        public static void glEndConditionalRenderNVX() {
            Pointers.glEndConditionalRenderNVX();
        }
        
        public static void glEndFragmentShaderATI() {
            Pointers.glEndFragmentShaderATI();
        }
        
        /// <summary>
        /// create or replace a display list
        /// <para>
        /// Display lists are groups of GL commands that have been stored for subsequent execution. Display
        /// lists are created with glNewList. All subsequent commands are placed in the display list, in the
        /// order issued, until glEndList is called
        /// </para>
        /// </summary>
        public static void glEndList() {
            Pointers.glEndList();
        }
        
        public static void glEndOcclusionQueryNV() {
            Pointers.glEndOcclusionQueryNV();
        }
        
        public static void glEndPerfMonitorAMD(uint monitor) {
            Pointers.glEndPerfMonitorAMD(monitor);
        }
        
        public static void glEndPerfQueryINTEL(uint queryHandle) {
            Pointers.glEndPerfQueryINTEL(queryHandle);
        }
        
        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>
        /// glBeginQuery and glEndQuery delimit the boundaries of a query object. query must be a name
        /// previously returned from a call to glGenQueries. If a query object with name id does not yet exist
        /// it is created with the type determined by target. target must be one of GL_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
        /// GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQuery and the subsequent
        /// glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </param>
        public static void glEndQuery(int target) {
            Pointers.glEndQuery(target);
        }
        
        /// <summary>
        /// delimit the boundaries of a query object
        /// <para>
        /// glBeginQuery and glEndQuery delimit the boundaries of a query object. query must be a name
        /// previously returned from a call to glGenQueries. If a query object with name id does not yet exist
        /// it is created with the type determined by target. target must be one of GL_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
        /// GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQuery and the subsequent
        /// glEndQuery. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE, GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </param>
        public static void glEndQueryARB(int target) {
            Pointers.glEndQueryARB(target);
        }
        
        public static void glEndQueryEXT(int target) {
            Pointers.glEndQueryEXT(target);
        }
        
        /// <summary>
        /// delimit the boundaries of a query object on an indexed target
        /// <para>
        /// glBeginQueryIndexed and glEndQueryIndexed delimit the boundaries of a query object. query must be a
        /// name previously returned from a call to glGenQueries. If a query object with name id does not yet
        /// exist it is created with the type determined by target. target must be one of GL_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED, GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or
        /// GL_TIME_ELAPSED. The behavior of the query object depends on its type and is as follows
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target type of query object established between glBeginQueryIndexed and the subsequent
        /// glEndQueryIndexed. The symbolic constant must be one of GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_PRIMITIVES_GENERATED, GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, or GL_TIME_ELAPSED.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the query target upon which to begin the query.
        /// </param>
        public static void glEndQueryIndexed(int target, uint index) {
            Pointers.glEndQueryIndexed(target, index);
        }
        
        public static void glEndTilingQCOM(uint preserveMask) {
            Pointers.glEndTilingQCOM(preserveMask);
        }
        
        public static void glEndTilingQCOM(Enums.BufferBitQCOM preserveMask) {
            Pointers.glEndTilingQCOM((uint)preserveMask);
        }
        
        /// <summary>
        /// start transform feedback operation
        /// <para>
        /// Transform feedback mode captures the values of varying variables written by the vertex shader (or,
        /// if active, the geometry shader). Transform feedback is said to be active after a call to
        /// glBeginTransformFeedback until a subsequent call to glEndTransformFeedback. Transform feedback
        /// commands must be paired
        /// </para>
        /// </summary>
        public static void glEndTransformFeedback() {
            Pointers.glEndTransformFeedback();
        }
        
        /// <summary>
        /// start transform feedback operation
        /// <para>
        /// Transform feedback mode captures the values of varying variables written by the vertex shader (or,
        /// if active, the geometry shader). Transform feedback is said to be active after a call to
        /// glBeginTransformFeedback until a subsequent call to glEndTransformFeedback. Transform feedback
        /// commands must be paired
        /// </para>
        /// </summary>
        public static void glEndTransformFeedbackEXT() {
            Pointers.glEndTransformFeedbackEXT();
        }
        
        /// <summary>
        /// start transform feedback operation
        /// <para>
        /// Transform feedback mode captures the values of varying variables written by the vertex shader (or,
        /// if active, the geometry shader). Transform feedback is said to be active after a call to
        /// glBeginTransformFeedback until a subsequent call to glEndTransformFeedback. Transform feedback
        /// commands must be paired
        /// </para>
        /// </summary>
        public static void glEndTransformFeedbackNV() {
            Pointers.glEndTransformFeedbackNV();
        }
        
        public static void glEndVertexShaderEXT() {
            Pointers.glEndVertexShaderEXT();
        }
        
        public static void glEndVideoCaptureNV(uint video_capture_slot) {
            Pointers.glEndVideoCaptureNV(video_capture_slot);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord1d(double u) {
            Pointers.glEvalCoord1d(u);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord1dv(double* u) {
            Pointers.glEvalCoord1dv(u);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord1dv(out double u) {
            fixed(double* u_ = &u)
                Pointers.glEvalCoord1dv(u_);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord1f(float u) {
            Pointers.glEvalCoord1f(u);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord1fv(float* u) {
            Pointers.glEvalCoord1fv(u);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord1fv(out float u) {
            fixed(float* u_ = &u)
                Pointers.glEvalCoord1fv(u_);
        }
        
        public static void glEvalCoord1xOES(IntPtr u) {
            Pointers.glEvalCoord1xOES(u);
        }
        
        public static void glEvalCoord1xvOES(IntPtr* coords) {
            Pointers.glEvalCoord1xvOES(coords);
        }
        
        public static void glEvalCoord1xvOES(out IntPtr coords) {
            fixed(IntPtr* coords_ = &coords)
                Pointers.glEvalCoord1xvOES(coords_);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        /// <param name="v">
        /// Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2
        /// command. This argument is not present in a glEvalCoord1 command.
        /// </param>
        public static void glEvalCoord2d(double u, double v) {
            Pointers.glEvalCoord2d(u, v);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord2dv(double* u) {
            Pointers.glEvalCoord2dv(u);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord2dv(double[] u) {
            fixed(double* u_ = &u[0])
                Pointers.glEvalCoord2dv(u_);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        /// <param name="v">
        /// Specifies a value that is the domain coordinate v to the basis function defined in a previous glMap2
        /// command. This argument is not present in a glEvalCoord1 command.
        /// </param>
        public static void glEvalCoord2f(float u, float v) {
            Pointers.glEvalCoord2f(u, v);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord2fv(float* u) {
            Pointers.glEvalCoord2fv(u);
        }
        
        /// <summary>
        /// evaluate enabled one- and two-dimensional maps
        /// <para>
        /// glEvalCoord1 evaluates enabled one-dimensional maps at argument u. glEvalCoord2 does the same for
        /// two-dimensional maps using two domain values, u and v. To define a map, call glMap1 and glMap2; to
        /// enable and disable it, call glEnable and glDisable
        /// </para>
        /// </summary>
        /// <param name="u">
        /// Specifies a value that is the domain coordinate u to the basis function defined in a previous glMap1
        /// or glMap2 command.
        /// </param>
        public static void glEvalCoord2fv(float[] u) {
            fixed(float* u_ = &u[0])
                Pointers.glEvalCoord2fv(u_);
        }
        
        public static void glEvalCoord2xOES(IntPtr u, IntPtr v) {
            Pointers.glEvalCoord2xOES(u, v);
        }
        
        public static void glEvalCoord2xvOES(IntPtr* coords) {
            Pointers.glEvalCoord2xvOES(coords);
        }
        
        public static void glEvalCoord2xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glEvalCoord2xvOES(coords_);
        }
        
        public static void glEvalMapsNV(int target, int mode) {
            Pointers.glEvalMapsNV(target, mode);
        }
        
        /// <summary>
        /// compute a one- or two-dimensional grid of points or lines
        /// <para>
        /// glMapGrid and glEvalMesh are used in tandem to efficiently generate and evaluate a series of
        /// evenly-spaced map domain values. glEvalMesh steps through the integer domain of a one- or
        /// two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and
        /// glMap2. mode determines whether the resulting vertices are connected as points, lines, or filled
        /// polygons
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic
        /// constants GL_POINT and GL_LINE are accepted.
        /// </param>
        /// <param name="i1">
        /// Specify the first and last integer values for grid domain variable i.
        /// </param>
        /// <param name="i2">
        /// Specify the first and last integer values for grid domain variable i.
        /// </param>
        public static void glEvalMesh1(int mode, int i1, int i2) {
            Pointers.glEvalMesh1(mode, i1, i2);
        }
        
        /// <summary>
        /// compute a one- or two-dimensional grid of points or lines
        /// <para>
        /// glMapGrid and glEvalMesh are used in tandem to efficiently generate and evaluate a series of
        /// evenly-spaced map domain values. glEvalMesh steps through the integer domain of a one- or
        /// two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and
        /// glMap2. mode determines whether the resulting vertices are connected as points, lines, or filled
        /// polygons
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// In glEvalMesh1, specifies whether to compute a one-dimensional mesh of points or lines. Symbolic
        /// constants GL_POINT and GL_LINE are accepted.
        /// </param>
        /// <param name="i1">
        /// Specify the first and last integer values for grid domain variable i.
        /// </param>
        /// <param name="i2">
        /// Specify the first and last integer values for grid domain variable i.
        /// </param>
        /// <param name="j1">
        /// In glEvalMesh2, specifies whether to compute a two-dimensional mesh of points, lines, or polygons.
        /// Symbolic constants GL_POINT, GL_LINE, and GL_FILL are accepted.
        /// </param>
        /// <param name="j2">
        /// In glEvalMesh2, specifies whether to compute a two-dimensional mesh of points, lines, or polygons.
        /// Symbolic constants GL_POINT, GL_LINE, and GL_FILL are accepted.
        /// </param>
        public static void glEvalMesh2(int mode, int i1, int i2, int j1, int j2) {
            Pointers.glEvalMesh2(mode, i1, i2, j1, j2);
        }
        
        /// <summary>
        /// generate and evaluate a single point in a mesh
        /// <para>
        /// glMapGrid and glEvalMesh are used in tandem to efficiently generate and evaluate a series of evenly
        /// spaced map domain values. glEvalPoint can be used to evaluate a single grid point in the same
        /// gridspace that is traversed by glEvalMesh. Calling glEvalPoint1 is equivalent to calling
        /// glEvalCoord1( 	 	 	 	 i 	 &CenterDot; 	 &Delta; 	 u 	 	 + 	 	 u 	 1 	 	 ); where &Delta; u = u 2 - u
        /// 1 n
        /// </para>
        /// </summary>
        /// <param name="i">
        /// Specifies the integer value for grid domain variable i.
        /// </param>
        public static void glEvalPoint1(int i) {
            Pointers.glEvalPoint1(i);
        }
        
        /// <summary>
        /// generate and evaluate a single point in a mesh
        /// <para>
        /// glMapGrid and glEvalMesh are used in tandem to efficiently generate and evaluate a series of evenly
        /// spaced map domain values. glEvalPoint can be used to evaluate a single grid point in the same
        /// gridspace that is traversed by glEvalMesh. Calling glEvalPoint1 is equivalent to calling
        /// glEvalCoord1( 	 	 	 	 i 	 &CenterDot; 	 &Delta; 	 u 	 	 + 	 	 u 	 1 	 	 ); where &Delta; u = u 2 - u
        /// 1 n
        /// </para>
        /// </summary>
        /// <param name="i">
        /// Specifies the integer value for grid domain variable i.
        /// </param>
        /// <param name="j">
        /// Specifies the integer value for grid domain variable j (glEvalPoint2 only).
        /// </param>
        public static void glEvalPoint2(int i, int j) {
            Pointers.glEvalPoint2(i, j);
        }
        
        public static void glEvaluateDepthValuesARB() {
            Pointers.glEvaluateDepthValuesARB();
        }
        
        public static void glExecuteProgramNV(int target, uint id, float* _params) {
            Pointers.glExecuteProgramNV(target, id, _params);
        }
        
        public static void glExecuteProgramNV(int target, uint id, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glExecuteProgramNV(target, id, _params_);
        }
        
        public static void glExtGetBufferPointervQCOM(int target, IntPtr* _params) {
            Pointers.glExtGetBufferPointervQCOM(target, _params);
        }
        
        public static void glExtGetBufferPointervQCOM(int target, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glExtGetBufferPointervQCOM(target, _params_);
        }
        
        public static void glExtGetBuffersQCOM(uint* buffers, int maxBuffers, int* numBuffers) {
            Pointers.glExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
        }
        
        public static void glExtGetBuffersQCOM(uint* buffers, int maxBuffers, out int numBuffers) {
            fixed(int* numBuffers_ = &numBuffers)
                Pointers.glExtGetBuffersQCOM(buffers, maxBuffers, numBuffers_);
        }
        
        public static void glExtGetBuffersQCOM(uint[] buffers, int maxBuffers, int* numBuffers) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glExtGetBuffersQCOM(buffers_, maxBuffers, numBuffers);
        }
        
        public static void glExtGetBuffersQCOM(uint[] buffers, int maxBuffers, out int numBuffers) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(int* numBuffers_ = &numBuffers)
                Pointers.glExtGetBuffersQCOM(buffers_, maxBuffers, numBuffers_);
        }
        
        public static void glExtGetFramebuffersQCOM(uint* framebuffers, int maxFramebuffers, int* numFramebuffers) {
            Pointers.glExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
        }
        
        public static void glExtGetFramebuffersQCOM(uint* framebuffers, int maxFramebuffers, out int numFramebuffers) {
            fixed(int* numFramebuffers_ = &numFramebuffers)
                Pointers.glExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers_);
        }
        
        public static void glExtGetFramebuffersQCOM(uint[] framebuffers, int maxFramebuffers, int* numFramebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glExtGetFramebuffersQCOM(framebuffers_, maxFramebuffers, numFramebuffers);
        }
        
        public static void glExtGetFramebuffersQCOM(uint[] framebuffers, int maxFramebuffers, out int numFramebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
            fixed(int* numFramebuffers_ = &numFramebuffers)
                Pointers.glExtGetFramebuffersQCOM(framebuffers_, maxFramebuffers, numFramebuffers_);
        }
        
        public static void glExtGetProgramBinarySourceQCOM(uint program, int shadertype, StringBuilder source, int* length) {
            Pointers.glExtGetProgramBinarySourceQCOM(program, shadertype, source, length);
        }
        
        public static void glExtGetProgramBinarySourceQCOM(uint program, int shadertype, StringBuilder source, int[] length) {
            fixed(int* length_ = &length[0])
                Pointers.glExtGetProgramBinarySourceQCOM(program, shadertype, source, length_);
        }
        
        public static void glExtGetProgramBinarySourceQCOM(uint program, Enums.ShaderType shadertype, StringBuilder source, int* length) {
            Pointers.glExtGetProgramBinarySourceQCOM(program, (int)shadertype, source, length);
        }
        
        public static void glExtGetProgramBinarySourceQCOM(uint program, Enums.ShaderType shadertype, StringBuilder source, int[] length) {
            fixed(int* length_ = &length[0])
                Pointers.glExtGetProgramBinarySourceQCOM(program, (int)shadertype, source, length_);
        }
        
        public static void glExtGetProgramsQCOM(uint* programs, int maxPrograms, int* numPrograms) {
            Pointers.glExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
        }
        
        public static void glExtGetProgramsQCOM(uint* programs, int maxPrograms, out int numPrograms) {
            fixed(int* numPrograms_ = &numPrograms)
                Pointers.glExtGetProgramsQCOM(programs, maxPrograms, numPrograms_);
        }
        
        public static void glExtGetProgramsQCOM(uint[] programs, int maxPrograms, int* numPrograms) {
            fixed(uint* programs_ = &programs[0])
                Pointers.glExtGetProgramsQCOM(programs_, maxPrograms, numPrograms);
        }
        
        public static void glExtGetProgramsQCOM(uint[] programs, int maxPrograms, out int numPrograms) {
            fixed(uint* programs_ = &programs[0])
            fixed(int* numPrograms_ = &numPrograms)
                Pointers.glExtGetProgramsQCOM(programs_, maxPrograms, numPrograms_);
        }
        
        public static void glExtGetRenderbuffersQCOM(uint* renderbuffers, int maxRenderbuffers, int* numRenderbuffers) {
            Pointers.glExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
        }
        
        public static void glExtGetRenderbuffersQCOM(uint* renderbuffers, int maxRenderbuffers, out int numRenderbuffers) {
            fixed(int* numRenderbuffers_ = &numRenderbuffers)
                Pointers.glExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers_);
        }
        
        public static void glExtGetRenderbuffersQCOM(uint[] renderbuffers, int maxRenderbuffers, int* numRenderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glExtGetRenderbuffersQCOM(renderbuffers_, maxRenderbuffers, numRenderbuffers);
        }
        
        public static void glExtGetRenderbuffersQCOM(uint[] renderbuffers, int maxRenderbuffers, out int numRenderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
            fixed(int* numRenderbuffers_ = &numRenderbuffers)
                Pointers.glExtGetRenderbuffersQCOM(renderbuffers_, maxRenderbuffers, numRenderbuffers_);
        }
        
        public static void glExtGetShadersQCOM(uint* shaders, int maxShaders, int* numShaders) {
            Pointers.glExtGetShadersQCOM(shaders, maxShaders, numShaders);
        }
        
        public static void glExtGetShadersQCOM(uint* shaders, int maxShaders, out int numShaders) {
            fixed(int* numShaders_ = &numShaders)
                Pointers.glExtGetShadersQCOM(shaders, maxShaders, numShaders_);
        }
        
        public static void glExtGetShadersQCOM(uint[] shaders, int maxShaders, int* numShaders) {
            fixed(uint* shaders_ = &shaders[0])
                Pointers.glExtGetShadersQCOM(shaders_, maxShaders, numShaders);
        }
        
        public static void glExtGetShadersQCOM(uint[] shaders, int maxShaders, out int numShaders) {
            fixed(uint* shaders_ = &shaders[0])
            fixed(int* numShaders_ = &numShaders)
                Pointers.glExtGetShadersQCOM(shaders_, maxShaders, numShaders_);
        }
        
        public static void glExtGetTexLevelParameterivQCOM(uint texture, int face, int level, int pname, int* _params) {
            Pointers.glExtGetTexLevelParameterivQCOM(texture, face, level, pname, _params);
        }
        
        public static void glExtGetTexLevelParameterivQCOM(uint texture, int face, int level, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glExtGetTexLevelParameterivQCOM(texture, face, level, pname, _params_);
        }
        
        public static void glExtGetTexSubImageQCOM(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr texels) {
            Pointers.glExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
        }
        
        public static void glExtGetTexturesQCOM(uint* textures, int maxTextures, int* numTextures) {
            Pointers.glExtGetTexturesQCOM(textures, maxTextures, numTextures);
        }
        
        public static void glExtGetTexturesQCOM(uint* textures, int maxTextures, int[] numTextures) {
            fixed(int* numTextures_ = &numTextures[0])
                Pointers.glExtGetTexturesQCOM(textures, maxTextures, numTextures_);
        }
        
        public static void glExtGetTexturesQCOM(uint[] textures, int maxTextures, int* numTextures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glExtGetTexturesQCOM(textures_, maxTextures, numTextures);
        }
        
        public static void glExtGetTexturesQCOM(uint[] textures, int maxTextures, int[] numTextures) {
            fixed(uint* textures_ = &textures[0])
            fixed(int* numTextures_ = &numTextures[0])
                Pointers.glExtGetTexturesQCOM(textures_, maxTextures, numTextures_);
        }
        
        public static bool glExtIsProgramBinaryQCOM(uint program) {
            return Pointers.glExtIsProgramBinaryQCOM(program);
        }
        
        public static void glExtTexObjectStateOverrideiQCOM(int target, int pname, int param) {
            Pointers.glExtTexObjectStateOverrideiQCOM(target, pname, param);
        }
        
        public static void glExtractComponentEXT(uint res, uint src, uint num) {
            Pointers.glExtractComponentEXT(res, src, num);
        }
        
        /// <summary>
        /// controls feedback mode
        /// <para>
        /// The glFeedbackBuffer function controls feedback. Feedback, like selection, is a GL mode. The mode is
        /// selected by calling glRenderMode with GL_FEEDBACK. When the GL is in feedback mode, no pixels are
        /// produced by rasterization. Instead, information about primitives that would have been rasterized is
        /// fed back to the application using the GL
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the maximum number of values that can be written into buffer.
        /// </param>
        /// <param name="type">
        /// Specifies a symbolic constant that describes the information that will be returned for each vertex.
        /// GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.
        /// </param>
        /// <param name="buffer">
        /// Specifies a symbolic constant that describes the information that will be returned for each vertex.
        /// GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.
        /// </param>
        public static void glFeedbackBuffer(int size, int type, float* buffer) {
            Pointers.glFeedbackBuffer(size, type, buffer);
        }
        
        /// <summary>
        /// controls feedback mode
        /// <para>
        /// The glFeedbackBuffer function controls feedback. Feedback, like selection, is a GL mode. The mode is
        /// selected by calling glRenderMode with GL_FEEDBACK. When the GL is in feedback mode, no pixels are
        /// produced by rasterization. Instead, information about primitives that would have been rasterized is
        /// fed back to the application using the GL
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the maximum number of values that can be written into buffer.
        /// </param>
        /// <param name="type">
        /// Specifies a symbolic constant that describes the information that will be returned for each vertex.
        /// GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.
        /// </param>
        /// <param name="buffer">
        /// Specifies a symbolic constant that describes the information that will be returned for each vertex.
        /// GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, and GL_4D_COLOR_TEXTURE are accepted.
        /// </param>
        public static void glFeedbackBuffer(int size, int type, float[] buffer) {
            fixed(float* buffer_ = &buffer[0])
                Pointers.glFeedbackBuffer(size, type, buffer_);
        }
        
        public static void glFeedbackBufferxOES(int n, int type, IntPtr* buffer) {
            Pointers.glFeedbackBufferxOES(n, type, buffer);
        }
        
        public static void glFeedbackBufferxOES(int n, int type, IntPtr[] buffer) {
            fixed(IntPtr* buffer_ = &buffer[0])
                Pointers.glFeedbackBufferxOES(n, type, buffer_);
        }
        
        /// <summary>
        /// create a new sync object and insert it into the GL command stream
        /// <para>
        /// glFenceSync creates a new fence sync object, inserts a fence command into the GL command stream and
        /// associates it with that sync object, and returns a non-zero name corresponding to the sync object
        /// </para>
        /// </summary>
        /// <param name="condition">
        /// Specifies the condition that must be met to set the sync object's state to signaled. condition must
        /// be GL_SYNC_GPU_COMMANDS_COMPLETE.
        /// </param>
        /// <param name="flags">
        /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are
        /// presently defined for this operation and flags must be zero. flags is a placeholder for anticipated
        /// future extensions of fence sync object capabilities.
        /// </param>
        public static IntPtr glFenceSync(int condition, uint flags) {
            return Pointers.glFenceSync(condition, flags);
        }
        
        /// <summary>
        /// create a new sync object and insert it into the GL command stream
        /// <para>
        /// glFenceSync creates a new fence sync object, inserts a fence command into the GL command stream and
        /// associates it with that sync object, and returns a non-zero name corresponding to the sync object
        /// </para>
        /// </summary>
        /// <param name="condition">
        /// Specifies the condition that must be met to set the sync object's state to signaled. condition must
        /// be GL_SYNC_GPU_COMMANDS_COMPLETE.
        /// </param>
        /// <param name="flags">
        /// Specifies a bitwise combination of flags controlling the behavior of the sync object. No flags are
        /// presently defined for this operation and flags must be zero. flags is a placeholder for anticipated
        /// future extensions of fence sync object capabilities.
        /// </param>
        public static IntPtr glFenceSyncAPPLE(int condition, uint flags) {
            return Pointers.glFenceSyncAPPLE(condition, flags);
        }
        
        public static void glFinalCombinerInputNV(int variable, int input, int mapping, int componentUsage) {
            Pointers.glFinalCombinerInputNV(variable, input, mapping, componentUsage);
        }
        
        /// <summary>
        /// block until all GL execution is complete
        /// <para>
        /// glFinish does not return until the effects of all previously called GL commands are complete. Such
        /// effects include all changes to GL state, all changes to connection state, and all changes to the
        /// frame buffer contents
        /// </para>
        /// </summary>
        public static void glFinish() {
            Pointers.glFinish();
        }
        
        public static int glFinishAsyncSGIX(uint* markerp) {
            return Pointers.glFinishAsyncSGIX(markerp);
        }
        
        public static int glFinishAsyncSGIX(out uint markerp) {
            fixed(uint* markerp_ = &markerp)
                return Pointers.glFinishAsyncSGIX(markerp_);
        }
        
        public static void glFinishFenceAPPLE(uint fence) {
            Pointers.glFinishFenceAPPLE(fence);
        }
        
        public static void glFinishFenceNV(uint fence) {
            Pointers.glFinishFenceNV(fence);
        }
        
        public static void glFinishObjectAPPLE(int _object, int name) {
            Pointers.glFinishObjectAPPLE(_object, name);
        }
        
        public static void glFinishTextureSUNX() {
            Pointers.glFinishTextureSUNX();
        }
        
        /// <summary>
        /// force execution of GL commands in finite time
        /// <para>
        /// Different GL implementations buffer commands in several different locations, including network
        /// buffers and the graphics accelerator itself. glFlush empties all of these buffers, causing all
        /// issued commands to be executed as quickly as they are accepted by the actual rendering engine.
        /// Though this execution may not be completed in any particular time period, it does complete in finite
        /// time
        /// </para>
        /// </summary>
        public static void glFlush() {
            Pointers.glFlush();
        }
        
        /// <summary>
        /// indicate modifications to a range of a mapped buffer
        /// <para>
        /// glFlushMappedBufferRange indicates that modifications have been made to a range of a mapped buffer
        /// object. The buffer object must previously have been mapped with the GL_MAP_FLUSH_EXPLICIT_BIT flag
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be
        /// one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </param>
        public static void glFlushMappedBufferRange(int target, uint offset, uint length) {
            Pointers.glFlushMappedBufferRange(target, offset, length);
        }
        
        /// <summary>
        /// indicate modifications to a range of a mapped buffer
        /// <para>
        /// glFlushMappedBufferRange indicates that modifications have been made to a range of a mapped buffer
        /// object. The buffer object must previously have been mapped with the GL_MAP_FLUSH_EXPLICIT_BIT flag
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be
        /// one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </param>
        /// <param name="size">
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </param>
        public static void glFlushMappedBufferRangeAPPLE(int target, uint offset, uint size) {
            Pointers.glFlushMappedBufferRangeAPPLE(target, offset, size);
        }
        
        /// <summary>
        /// indicate modifications to a range of a mapped buffer
        /// <para>
        /// glFlushMappedBufferRange indicates that modifications have been made to a range of a mapped buffer
        /// object. The buffer object must previously have been mapped with the GL_MAP_FLUSH_EXPLICIT_BIT flag
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glFlushMappedBufferRange, which must be
        /// one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the start of the buffer subrange, in basic machine units.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the buffer subrange, in basic machine units.
        /// </param>
        public static void glFlushMappedBufferRangeEXT(int target, uint offset, uint length) {
            Pointers.glFlushMappedBufferRangeEXT(target, offset, length);
        }
        
        public static void glFlushMappedNamedBufferRange(uint buffer, uint offset, uint length) {
            Pointers.glFlushMappedNamedBufferRange(buffer, offset, length);
        }
        
        public static void glFlushMappedNamedBufferRangeEXT(uint buffer, uint offset, uint length) {
            Pointers.glFlushMappedNamedBufferRangeEXT(buffer, offset, length);
        }
        
        public static void glFlushPixelDataRangeNV(int target) {
            Pointers.glFlushPixelDataRangeNV(target);
        }
        
        public static void glFlushRasterSGIX() {
            Pointers.glFlushRasterSGIX();
        }
        
        public static void glFlushStaticDataIBM(int target) {
            Pointers.glFlushStaticDataIBM(target);
        }
        
        public static void glFlushVertexArrayRangeAPPLE(int length, IntPtr pointer) {
            Pointers.glFlushVertexArrayRangeAPPLE(length, pointer);
        }
        
        public static void glFlushVertexArrayRangeNV() {
            Pointers.glFlushVertexArrayRangeNV();
        }
        
        public static void glFogCoordFormatNV(int type, int stride) {
            Pointers.glFogCoordFormatNV(type, stride);
        }
        
        /// <summary>
        /// define an array of fog coordinates
        /// <para>
        /// glFogCoordPointer specifies the location and data format of an array of fog coordinates to use when
        /// rendering. type specifies the data type of each fog coordinate, and stride specifies the byte stride
        /// from one fog coordinate to the next, allowing vertices and attributes to be packed into a single
        /// array or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are
        /// accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements
        /// are understood to be tightly packed. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial
        /// value is 0.
        /// </param>
        public static void glFogCoordPointer(int type, int stride, IntPtr pointer) {
            Pointers.glFogCoordPointer(type, stride, pointer);
        }
        
        /// <summary>
        /// define an array of fog coordinates
        /// <para>
        /// glFogCoordPointer specifies the location and data format of an array of fog coordinates to use when
        /// rendering. type specifies the data type of each fog coordinate, and stride specifies the byte stride
        /// from one fog coordinate to the next, allowing vertices and attributes to be packed into a single
        /// array or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the data type of each fog coordinate. Symbolic constants GL_FLOAT, or GL_DOUBLE are
        /// accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive fog coordinates. If stride is 0, the array elements
        /// are understood to be tightly packed. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first coordinate of the first fog coordinate in the array. The initial
        /// value is 0.
        /// </param>
        public static void glFogCoordPointerEXT(int type, int stride, IntPtr pointer) {
            Pointers.glFogCoordPointerEXT(type, stride, pointer);
        }
        
        public static void glFogCoordPointerListIBM(int type, int stride, IntPtr* pointer, int ptrstride) {
            Pointers.glFogCoordPointerListIBM(type, stride, pointer, ptrstride);
        }
        
        public static void glFogCoordPointerListIBM(int type, int stride, IntPtr[] pointer, int ptrstride) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glFogCoordPointerListIBM(type, stride, pointer_, ptrstride);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoordd(double coord) {
            Pointers.glFogCoordd(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoorddEXT(double coord) {
            Pointers.glFogCoorddEXT(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoorddv(double* coord) {
            Pointers.glFogCoorddv(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoorddv(out double coord) {
            fixed(double* coord_ = &coord)
                Pointers.glFogCoorddv(coord_);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoorddvEXT(double* coord) {
            Pointers.glFogCoorddvEXT(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoorddvEXT(out double coord) {
            fixed(double* coord_ = &coord)
                Pointers.glFogCoorddvEXT(coord_);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoordf(float coord) {
            Pointers.glFogCoordf(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoordfEXT(float coord) {
            Pointers.glFogCoordfEXT(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoordfv(float* coord) {
            Pointers.glFogCoordfv(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoordfv(out float coord) {
            fixed(float* coord_ = &coord)
                Pointers.glFogCoordfv(coord_);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoordfvEXT(float* coord) {
            Pointers.glFogCoordfvEXT(coord);
        }
        
        /// <summary>
        /// set the current fog coordinates
        /// <para>
        /// glFogCoord specifies the fog coordinate that is associated with each vertex and the current raster
        /// position. The value specified is interpolated and used in computing the fog color (see glFog)
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specify the fog distance.
        /// </param>
        public static void glFogCoordfvEXT(out float coord) {
            fixed(float* coord_ = &coord)
                Pointers.glFogCoordfvEXT(coord_);
        }
        
        public static void glFogCoordhNV(short fog) {
            Pointers.glFogCoordhNV(fog);
        }
        
        public static void glFogCoordhvNV(short* fog) {
            Pointers.glFogCoordhvNV(fog);
        }
        
        public static void glFogCoordhvNV(out short fog) {
            fixed(short* fog_ = &fog)
                Pointers.glFogCoordhvNV(fog_);
        }
        
        public static void glFogFuncSGIS(int n, float* points) {
            Pointers.glFogFuncSGIS(n, points);
        }
        
        public static void glFogFuncSGIS(int n, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glFogFuncSGIS(n, points_);
        }
        
        /// <summary>
        /// specify fog parameters
        /// <para>
        /// Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel
        /// blocks, but not buffer clear operations. To enable and disable fog, call glEnable and glDisable with
        /// argument GL_FOG
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END,
        /// GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname will be set to.
        /// </param>
        public static void glFogf(int pname, float param) {
            Pointers.glFogf(pname, param);
        }
        
        /// <summary>
        /// specify fog parameters
        /// <para>
        /// Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel
        /// blocks, but not buffer clear operations. To enable and disable fog, call glEnable and glDisable with
        /// argument GL_FOG
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END,
        /// GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX,
        /// GL_FOG_COLOR, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        public static void glFogfv(int pname, float* _params) {
            Pointers.glFogfv(pname, _params);
        }
        
        /// <summary>
        /// specify fog parameters
        /// <para>
        /// Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel
        /// blocks, but not buffer clear operations. To enable and disable fog, call glEnable and glDisable with
        /// argument GL_FOG
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END,
        /// GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX,
        /// GL_FOG_COLOR, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        public static void glFogfv(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glFogfv(pname, _params_);
        }
        
        /// <summary>
        /// specify fog parameters
        /// <para>
        /// Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel
        /// blocks, but not buffer clear operations. To enable and disable fog, call glEnable and glDisable with
        /// argument GL_FOG
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END,
        /// GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname will be set to.
        /// </param>
        public static void glFogi(int pname, int param) {
            Pointers.glFogi(pname, param);
        }
        
        /// <summary>
        /// specify fog parameters
        /// <para>
        /// Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel
        /// blocks, but not buffer clear operations. To enable and disable fog, call glEnable and glDisable with
        /// argument GL_FOG
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END,
        /// GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX,
        /// GL_FOG_COLOR, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        public static void glFogiv(int pname, int* _params) {
            Pointers.glFogiv(pname, _params);
        }
        
        /// <summary>
        /// specify fog parameters
        /// <para>
        /// Fog is initially disabled. While enabled, fog affects rasterized geometry, bitmaps, and pixel
        /// blocks, but not buffer clear operations. To enable and disable fog, call glEnable and glDisable with
        /// argument GL_FOG
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END,
        /// GL_FOG_INDEX, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a fog parameter. GL_FOG_MODE, GL_FOG_DENSITY, GL_FOG_START, GL_FOG_END, GL_FOG_INDEX,
        /// GL_FOG_COLOR, and GL_FOG_COORD_SRC are accepted.
        /// </param>
        public static void glFogiv(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glFogiv(pname, _params_);
        }
        
        public static void glFogx(int pname, IntPtr param) {
            Pointers.glFogx(pname, param);
        }
        
        public static void glFogxOES(int pname, IntPtr param) {
            Pointers.glFogxOES(pname, param);
        }
        
        public static void glFogxv(int pname, IntPtr* param) {
            Pointers.glFogxv(pname, param);
        }
        
        public static void glFogxv(int pname, IntPtr[] param) {
            fixed(IntPtr* param_ = &param[0])
                Pointers.glFogxv(pname, param_);
        }
        
        public static void glFogxvOES(int pname, IntPtr* param) {
            Pointers.glFogxvOES(pname, param);
        }
        
        public static void glFogxvOES(int pname, IntPtr[] param) {
            fixed(IntPtr* param_ = &param[0])
                Pointers.glFogxvOES(pname, param_);
        }
        
        public static void glFragmentColorMaterialSGIX(int face, int mode) {
            Pointers.glFragmentColorMaterialSGIX(face, mode);
        }
        
        public static void glFragmentCoverageColorNV(uint color) {
            Pointers.glFragmentCoverageColorNV(color);
        }
        
        public static void glFragmentLightModelfSGIX(int pname, float param) {
            Pointers.glFragmentLightModelfSGIX(pname, param);
        }
        
        public static void glFragmentLightModelfvSGIX(int pname, float* _params) {
            Pointers.glFragmentLightModelfvSGIX(pname, _params);
        }
        
        public static void glFragmentLightModelfvSGIX(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glFragmentLightModelfvSGIX(pname, _params_);
        }
        
        public static void glFragmentLightModeliSGIX(int pname, int param) {
            Pointers.glFragmentLightModeliSGIX(pname, param);
        }
        
        public static void glFragmentLightModelivSGIX(int pname, int* _params) {
            Pointers.glFragmentLightModelivSGIX(pname, _params);
        }
        
        public static void glFragmentLightModelivSGIX(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glFragmentLightModelivSGIX(pname, _params_);
        }
        
        public static void glFragmentLightfSGIX(int light, int pname, float param) {
            Pointers.glFragmentLightfSGIX(light, pname, param);
        }
        
        public static void glFragmentLightfvSGIX(int light, int pname, float* _params) {
            Pointers.glFragmentLightfvSGIX(light, pname, _params);
        }
        
        public static void glFragmentLightfvSGIX(int light, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glFragmentLightfvSGIX(light, pname, _params_);
        }
        
        public static void glFragmentLightiSGIX(int light, int pname, int param) {
            Pointers.glFragmentLightiSGIX(light, pname, param);
        }
        
        public static void glFragmentLightivSGIX(int light, int pname, int* _params) {
            Pointers.glFragmentLightivSGIX(light, pname, _params);
        }
        
        public static void glFragmentLightivSGIX(int light, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glFragmentLightivSGIX(light, pname, _params_);
        }
        
        public static void glFragmentMaterialfSGIX(int face, int pname, float param) {
            Pointers.glFragmentMaterialfSGIX(face, pname, param);
        }
        
        public static void glFragmentMaterialfvSGIX(int face, int pname, float* _params) {
            Pointers.glFragmentMaterialfvSGIX(face, pname, _params);
        }
        
        public static void glFragmentMaterialfvSGIX(int face, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glFragmentMaterialfvSGIX(face, pname, _params_);
        }
        
        public static void glFragmentMaterialiSGIX(int face, int pname, int param) {
            Pointers.glFragmentMaterialiSGIX(face, pname, param);
        }
        
        public static void glFragmentMaterialivSGIX(int face, int pname, int* _params) {
            Pointers.glFragmentMaterialivSGIX(face, pname, _params);
        }
        
        public static void glFragmentMaterialivSGIX(int face, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glFragmentMaterialivSGIX(face, pname, _params_);
        }
        
        public static void glFrameTerminatorGREMEDY() {
            Pointers.glFrameTerminatorGREMEDY();
        }
        
        public static void glFrameZoomSGIX(int factor) {
            Pointers.glFrameZoomSGIX(factor);
        }
        
        public static void glFramebufferDrawBufferEXT(uint framebuffer, int mode) {
            Pointers.glFramebufferDrawBufferEXT(framebuffer, mode);
        }
        
        public static void glFramebufferDrawBuffersEXT(uint framebuffer, int n, uint* bufs) {
            Pointers.glFramebufferDrawBuffersEXT(framebuffer, n, bufs);
        }
        
        public static void glFramebufferDrawBuffersEXT(uint framebuffer, int n, uint[] bufs) {
            fixed(uint* bufs_ = &bufs[0])
                Pointers.glFramebufferDrawBuffersEXT(framebuffer, n, bufs_);
        }
        
        public static void glFramebufferFetchBarrierEXT() {
            Pointers.glFramebufferFetchBarrierEXT();
        }
        
        public static void glFramebufferFetchBarrierQCOM() {
            Pointers.glFramebufferFetchBarrierQCOM();
        }
        
        public static void glFramebufferFoveationConfigQCOM(uint framebuffer, uint numLayers, uint focalPointsPerLayer, uint requestedFeatures, uint* providedFeatures) {
            Pointers.glFramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures);
        }
        
        public static void glFramebufferFoveationConfigQCOM(uint framebuffer, uint numLayers, uint focalPointsPerLayer, uint requestedFeatures, out uint providedFeatures) {
            fixed(uint* providedFeatures_ = &providedFeatures)
                Pointers.glFramebufferFoveationConfigQCOM(framebuffer, numLayers, focalPointsPerLayer, requestedFeatures, providedFeatures_);
        }
        
        public static void glFramebufferFoveationParametersQCOM(uint framebuffer, uint layer, uint focalPoint, float focalX, float focalY, float gainX, float gainY, float foveaArea) {
            Pointers.glFramebufferFoveationParametersQCOM(framebuffer, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
        }
        
        /// <summary>
        /// set a named parameter of a framebuffer object
        /// <para>
        /// glFramebufferParameteri and glNamedFramebufferParameteri modify the value of the parameter named
        /// pname in the specified framebuffer object. There are no modifiable parameters of the default draw
        /// and read framebuffer, so they are not valid targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for glFramebufferParameteri.
        /// </param>
        /// <param name="pname">
        /// Specifies the framebuffer parameter to be modified.
        /// </param>
        /// <param name="param">
        /// The new value for the parameter named pname.
        /// </param>
        public static void glFramebufferParameteri(int target, int pname, int param) {
            Pointers.glFramebufferParameteri(target, pname, param);
        }
        
        public static void glFramebufferPixelLocalStorageSizeEXT(uint target, int size) {
            Pointers.glFramebufferPixelLocalStorageSizeEXT(target, size);
        }
        
        public static void glFramebufferReadBufferEXT(uint framebuffer, int mode) {
            Pointers.glFramebufferReadBufferEXT(framebuffer, mode);
        }
        
        /// <summary>
        /// attach a renderbuffer as a logical buffer of a framebuffer object
        /// <para>
        /// glFramebufferRenderbuffer and glNamedFramebufferRenderbuffer attaches a renderbuffer as one of the
        /// logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the default
        /// draw and read framebuffer, so they are not valid targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="renderbuffertarget">
        /// Specifies the renderbuffer target. Must be GL_RENDERBUFFER.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </param>
        public static void glFramebufferRenderbuffer(int target, int attachment, int renderbuffertarget, uint renderbuffer) {
            Pointers.glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
        }
        
        /// <summary>
        /// attach a renderbuffer as a logical buffer of a framebuffer object
        /// <para>
        /// glFramebufferRenderbuffer and glNamedFramebufferRenderbuffer attaches a renderbuffer as one of the
        /// logical buffers of the specified framebuffer object. Renderbuffers cannot be attached to the default
        /// draw and read framebuffer, so they are not valid targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for glFramebufferRenderbuffer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="renderbuffertarget">
        /// Specifies the renderbuffer target. Must be GL_RENDERBUFFER.
        /// </param>
        /// <param name="renderbuffer">
        /// Specifies the name of an existing renderbuffer object of type renderbuffertarget to attach.
        /// </param>
        public static void glFramebufferRenderbufferEXT(int target, int attachment, int renderbuffertarget, uint renderbuffer) {
            Pointers.glFramebufferRenderbufferEXT(target, attachment, renderbuffertarget, renderbuffer);
        }
        
        public static void glFramebufferRenderbufferOES(int target, int attachment, int renderbuffertarget, uint renderbuffer) {
            Pointers.glFramebufferRenderbufferOES(target, attachment, renderbuffertarget, renderbuffer);
        }
        
        public static void glFramebufferSampleLocationsfvARB(int target, uint start, int count, float* v) {
            Pointers.glFramebufferSampleLocationsfvARB(target, start, count, v);
        }
        
        public static void glFramebufferSampleLocationsfvARB(int target, uint start, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glFramebufferSampleLocationsfvARB(target, start, count, v_);
        }
        
        public static void glFramebufferSampleLocationsfvNV(int target, uint start, int count, float* v) {
            Pointers.glFramebufferSampleLocationsfvNV(target, start, count, v);
        }
        
        public static void glFramebufferSampleLocationsfvNV(int target, uint start, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glFramebufferSampleLocationsfvNV(target, start, count, v_);
        }
        
        public static void glFramebufferSamplePositionsfvAMD(int target, uint numsamples, uint pixelindex, float* values) {
            Pointers.glFramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values);
        }
        
        public static void glFramebufferSamplePositionsfvAMD(int target, uint numsamples, uint pixelindex, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glFramebufferSamplePositionsfvAMD(target, numsamples, pixelindex, values_);
        }
        
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>
        /// These commands attach a selected mipmap level or image of a texture object as one of the logical
        /// buffers of the specified framebuffer object. Textures cannot be attached to the default draw and
        /// read framebuffer, so they are not valid targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for all commands except
        /// glNamedFramebufferTexture.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of an existing texture object to attach.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of the texture object to attach.
        /// </param>
        public static void glFramebufferTexture(int target, int attachment, uint texture, int level) {
            Pointers.glFramebufferTexture(target, attachment, texture, level);
        }
        
        public static void glFramebufferTexture1D(int target, int attachment, int textarget, uint texture, int level) {
            Pointers.glFramebufferTexture1D(target, attachment, textarget, texture, level);
        }
        
        public static void glFramebufferTexture1DEXT(int target, int attachment, int textarget, uint texture, int level) {
            Pointers.glFramebufferTexture1DEXT(target, attachment, textarget, texture, level);
        }
        
        public static void glFramebufferTexture2D(int target, int attachment, int textarget, uint texture, int level) {
            Pointers.glFramebufferTexture2D(target, attachment, textarget, texture, level);
        }
        
        public static void glFramebufferTexture2DEXT(int target, int attachment, int textarget, uint texture, int level) {
            Pointers.glFramebufferTexture2DEXT(target, attachment, textarget, texture, level);
        }
        
        public static void glFramebufferTexture2DDownsampleIMG(int target, int attachment, int textarget, uint texture, int level, int xscale, int yscale) {
            Pointers.glFramebufferTexture2DDownsampleIMG(target, attachment, textarget, texture, level, xscale, yscale);
        }
        
        public static void glFramebufferTexture2DMultisampleEXT(int target, int attachment, int textarget, uint texture, int level, int samples) {
            Pointers.glFramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
        }
        
        public static void glFramebufferTexture2DMultisampleIMG(int target, int attachment, int textarget, uint texture, int level, int samples) {
            Pointers.glFramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
        }
        
        public static void glFramebufferTexture2DOES(int target, int attachment, int textarget, uint texture, int level) {
            Pointers.glFramebufferTexture2DOES(target, attachment, textarget, texture, level);
        }
        
        public static void glFramebufferTexture3D(int target, int attachment, int textarget, uint texture, int level, int zoffset) {
            Pointers.glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
        }
        
        public static void glFramebufferTexture3DEXT(int target, int attachment, int textarget, uint texture, int level, int zoffset) {
            Pointers.glFramebufferTexture3DEXT(target, attachment, textarget, texture, level, zoffset);
        }
        
        public static void glFramebufferTexture3DOES(int target, int attachment, int textarget, uint texture, int level, int zoffset) {
            Pointers.glFramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
        }
        
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>
        /// These commands attach a selected mipmap level or image of a texture object as one of the logical
        /// buffers of the specified framebuffer object. Textures cannot be attached to the default draw and
        /// read framebuffer, so they are not valid targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for all commands except
        /// glNamedFramebufferTexture.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of an existing texture object to attach.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of the texture object to attach.
        /// </param>
        public static void glFramebufferTextureARB(int target, int attachment, uint texture, int level) {
            Pointers.glFramebufferTextureARB(target, attachment, texture, level);
        }
        
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>
        /// These commands attach a selected mipmap level or image of a texture object as one of the logical
        /// buffers of the specified framebuffer object. Textures cannot be attached to the default draw and
        /// read framebuffer, so they are not valid targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for all commands except
        /// glNamedFramebufferTexture.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of an existing texture object to attach.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of the texture object to attach.
        /// </param>
        public static void glFramebufferTextureEXT(int target, int attachment, uint texture, int level) {
            Pointers.glFramebufferTextureEXT(target, attachment, texture, level);
        }
        
        public static void glFramebufferTextureFaceARB(int target, int attachment, uint texture, int level, int face) {
            Pointers.glFramebufferTextureFaceARB(target, attachment, texture, level, face);
        }
        
        public static void glFramebufferTextureFaceEXT(int target, int attachment, uint texture, int level, int face) {
            Pointers.glFramebufferTextureFaceEXT(target, attachment, texture, level, face);
        }
        
        /// <summary>
        /// attach a single layer of a texture object as a logical buffer of a framebuffer object
        /// <para>
        /// glFramebufferTextureLayer and glNamedFramebufferTextureLayer attach a single layer of a
        /// three-dimensional or array texture object as one of the logical buffers of the specified framebuffer
        /// object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid
        /// targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of an existing texture object to attach.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of the texture object to attach.
        /// </param>
        /// <param name="layer">
        /// Specifies the layer of the texture object to attach.
        /// </param>
        public static void glFramebufferTextureLayer(int target, int attachment, uint texture, int level, int layer) {
            Pointers.glFramebufferTextureLayer(target, attachment, texture, level, layer);
        }
        
        /// <summary>
        /// attach a single layer of a texture object as a logical buffer of a framebuffer object
        /// <para>
        /// glFramebufferTextureLayer and glNamedFramebufferTextureLayer attach a single layer of a
        /// three-dimensional or array texture object as one of the logical buffers of the specified framebuffer
        /// object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid
        /// targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of an existing texture object to attach.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of the texture object to attach.
        /// </param>
        /// <param name="layer">
        /// Specifies the layer of the texture object to attach.
        /// </param>
        public static void glFramebufferTextureLayerARB(int target, int attachment, uint texture, int level, int layer) {
            Pointers.glFramebufferTextureLayerARB(target, attachment, texture, level, layer);
        }
        
        /// <summary>
        /// attach a single layer of a texture object as a logical buffer of a framebuffer object
        /// <para>
        /// glFramebufferTextureLayer and glNamedFramebufferTextureLayer attach a single layer of a
        /// three-dimensional or array texture object as one of the logical buffers of the specified framebuffer
        /// object. Textures cannot be attached to the default draw and read framebuffer, so they are not valid
        /// targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for glFramebufferTextureLayer.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of an existing texture object to attach.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of the texture object to attach.
        /// </param>
        /// <param name="layer">
        /// Specifies the layer of the texture object to attach.
        /// </param>
        public static void glFramebufferTextureLayerEXT(int target, int attachment, uint texture, int level, int layer) {
            Pointers.glFramebufferTextureLayerEXT(target, attachment, texture, level, layer);
        }
        
        public static void glFramebufferTextureLayerDownsampleIMG(int target, int attachment, uint texture, int level, int layer, int xscale, int yscale) {
            Pointers.glFramebufferTextureLayerDownsampleIMG(target, attachment, texture, level, layer, xscale, yscale);
        }
        
        public static void glFramebufferTextureMultisampleMultiviewOVR(int target, int attachment, uint texture, int level, int samples, int baseViewIndex, int numViews) {
            Pointers.glFramebufferTextureMultisampleMultiviewOVR(target, attachment, texture, level, samples, baseViewIndex, numViews);
        }
        
        public static void glFramebufferTextureMultiviewOVR(int target, int attachment, uint texture, int level, int baseViewIndex, int numViews) {
            Pointers.glFramebufferTextureMultiviewOVR(target, attachment, texture, level, baseViewIndex, numViews);
        }
        
        /// <summary>
        /// attach a level of a texture object as a logical buffer of a framebuffer object
        /// <para>
        /// These commands attach a selected mipmap level or image of a texture object as one of the logical
        /// buffers of the specified framebuffer object. Textures cannot be attached to the default draw and
        /// read framebuffer, so they are not valid targets of these commands
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer is bound for all commands except
        /// glNamedFramebufferTexture.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment point of the framebuffer.
        /// </param>
        /// <param name="texture">
        /// Specifies the name of an existing texture object to attach.
        /// </param>
        /// <param name="level">
        /// Specifies the mipmap level of the texture object to attach.
        /// </param>
        public static void glFramebufferTextureOES(int target, int attachment, uint texture, int level) {
            Pointers.glFramebufferTextureOES(target, attachment, texture, level);
        }
        
        public static void glFreeObjectBufferATI(uint buffer) {
            Pointers.glFreeObjectBufferATI(buffer);
        }
        
        /// <summary>
        /// define front- and back-facing polygons
        /// <para>
        /// In a scene composed entirely of opaque closed surfaces, back-facing polygons are never visible.
        /// Eliminating these invisible polygons has the obvious benefit of speeding up the rendering of the
        /// image. To enable and disable elimination of back-facing polygons, call glEnable and glDisable with
        /// argument GL_CULL_FACE
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies the orientation of front-facing polygons. GL_CW and GL_CCW are accepted. The initial value
        /// is GL_CCW.
        /// </param>
        public static void glFrontFace(int mode) {
            Pointers.glFrontFace(mode);
        }
        
        /// <summary>
        /// multiply the current matrix by a perspective matrix
        /// <para>
        /// glFrustum describes a perspective matrix that produces a perspective projection. The current matrix
        /// (see glMatrixMode) is multiplied by this matrix and the result replaces the current matrix, as if
        /// glMultMatrix were called with the following matrix as its argument:
        /// </para>
        /// </summary>
        /// <param name="left">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="right">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="top">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="zNear">
        /// Specify the distances to the near and far depth clipping planes. Both distances must be positive.
        /// </param>
        /// <param name="zFar">
        /// Specify the distances to the near and far depth clipping planes. Both distances must be positive.
        /// </param>
        public static void glFrustum(double left, double right, double bottom, double top, double zNear, double zFar) {
            Pointers.glFrustum(left, right, bottom, top, zNear, zFar);
        }
        
        public static void glFrustumf(float l, float r, float b, float t, float n, float f) {
            Pointers.glFrustumf(l, r, b, t, n, f);
        }
        
        public static void glFrustumfOES(float l, float r, float b, float t, float n, float f) {
            Pointers.glFrustumfOES(l, r, b, t, n, f);
        }
        
        public static void glFrustumx(IntPtr l, IntPtr r, IntPtr b, IntPtr t, IntPtr n, IntPtr f) {
            Pointers.glFrustumx(l, r, b, t, n, f);
        }
        
        public static void glFrustumxOES(IntPtr l, IntPtr r, IntPtr b, IntPtr t, IntPtr n, IntPtr f) {
            Pointers.glFrustumxOES(l, r, b, t, n, f);
        }
        
        public static uint glGenAsyncMarkersSGIX(int range) {
            return Pointers.glGenAsyncMarkersSGIX(range);
        }
        
        /// <summary>
        /// generate buffer object names
        /// <para>
        /// glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenBuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        public static void glGenBuffers(int n, uint* buffers) {
            Pointers.glGenBuffers(n, buffers);
        }
        
        /// <summary>
        /// generate buffer object names
        /// <para>
        /// glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenBuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        public static void glGenBuffers(int n, uint[] buffers) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glGenBuffers(n, buffers_);
        }
        
        public static uint glGenBuffer() {
            var buffers_ = new uint[1];
            glGenBuffers(1, buffers_);
            return buffers_[0];
        }
        
        /// <summary>
        /// generate buffer object names
        /// <para>
        /// glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenBuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        public static void glGenBuffersARB(int n, uint* buffers) {
            Pointers.glGenBuffersARB(n, buffers);
        }
        
        /// <summary>
        /// generate buffer object names
        /// <para>
        /// glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenBuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of buffer object names to be generated.
        /// </param>
        /// <param name="buffers">
        /// Specifies an array in which the generated buffer object names are stored.
        /// </param>
        public static void glGenBuffersARB(int n, uint[] buffers) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glGenBuffersARB(n, buffers_);
        }
        
        public static uint glGenBuffersARB() {
            var buffers_ = new uint[1];
            glGenBuffersARB(1, buffers_);
            return buffers_[0];
        }
        
        public static void glGenFencesAPPLE(int n, uint* fences) {
            Pointers.glGenFencesAPPLE(n, fences);
        }
        
        public static void glGenFencesAPPLE(int n, uint[] fences) {
            fixed(uint* fences_ = &fences[0])
                Pointers.glGenFencesAPPLE(n, fences_);
        }
        
        public static uint glGenFencesAPPLE() {
            var fences_ = new uint[1];
            glGenFencesAPPLE(1, fences_);
            return fences_[0];
        }
        
        public static void glGenFencesNV(int n, uint* fences) {
            Pointers.glGenFencesNV(n, fences);
        }
        
        public static void glGenFencesNV(int n, uint[] fences) {
            fixed(uint* fences_ = &fences[0])
                Pointers.glGenFencesNV(n, fences_);
        }
        
        public static uint glGenFencesNV() {
            var fences_ = new uint[1];
            glGenFencesNV(1, fences_);
            return fences_[0];
        }
        
        public static uint glGenFragmentShadersATI(uint range) {
            return Pointers.glGenFragmentShadersATI(range);
        }
        
        /// <summary>
        /// generate framebuffer object names
        /// <para>
        /// glGenFramebuffers returns n framebuffer object names in ids. There is no guarantee that the names
        /// form a contiguous set of integers; however, it is guaranteed that none of the returned names was in
        /// use immediately before the call to glGenFramebuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        public static void glGenFramebuffers(int n, uint* framebuffers) {
            Pointers.glGenFramebuffers(n, framebuffers);
        }
        
        /// <summary>
        /// generate framebuffer object names
        /// <para>
        /// glGenFramebuffers returns n framebuffer object names in ids. There is no guarantee that the names
        /// form a contiguous set of integers; however, it is guaranteed that none of the returned names was in
        /// use immediately before the call to glGenFramebuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        public static void glGenFramebuffers(int n, uint[] framebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glGenFramebuffers(n, framebuffers_);
        }
        
        public static uint glGenFramebuffer() {
            var framebuffers_ = new uint[1];
            glGenFramebuffers(1, framebuffers_);
            return framebuffers_[0];
        }
        
        /// <summary>
        /// generate framebuffer object names
        /// <para>
        /// glGenFramebuffers returns n framebuffer object names in ids. There is no guarantee that the names
        /// form a contiguous set of integers; however, it is guaranteed that none of the returned names was in
        /// use immediately before the call to glGenFramebuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        public static void glGenFramebuffersEXT(int n, uint* framebuffers) {
            Pointers.glGenFramebuffersEXT(n, framebuffers);
        }
        
        /// <summary>
        /// generate framebuffer object names
        /// <para>
        /// glGenFramebuffers returns n framebuffer object names in ids. There is no guarantee that the names
        /// form a contiguous set of integers; however, it is guaranteed that none of the returned names was in
        /// use immediately before the call to glGenFramebuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of framebuffer object names to generate.
        /// </param>
        /// <param name="framebuffers">
        /// Specifies an array in which the generated framebuffer object names are stored.
        /// </param>
        public static void glGenFramebuffersEXT(int n, uint[] framebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glGenFramebuffersEXT(n, framebuffers_);
        }
        
        public static uint glGenFramebuffersEXT() {
            var framebuffers_ = new uint[1];
            glGenFramebuffersEXT(1, framebuffers_);
            return framebuffers_[0];
        }
        
        public static void glGenFramebuffersOES(int n, uint* framebuffers) {
            Pointers.glGenFramebuffersOES(n, framebuffers);
        }
        
        public static void glGenFramebuffersOES(int n, uint[] framebuffers) {
            fixed(uint* framebuffers_ = &framebuffers[0])
                Pointers.glGenFramebuffersOES(n, framebuffers_);
        }
        
        public static uint glGenFramebuffersOES() {
            var framebuffers_ = new uint[1];
            glGenFramebuffersOES(1, framebuffers_);
            return framebuffers_[0];
        }
        
        /// <summary>
        /// generate a contiguous set of empty display lists
        /// <para>
        /// glGenLists has one argument, range. It returns an integer n such that range contiguous empty display
        /// lists, named n, n + 1 , ... , n + range - 1 , are created. If range is 0, if there is no group of
        /// range contiguous names available, or if any error is generated, no display lists are generated, and
        /// 0 is returned
        /// </para>
        /// </summary>
        /// <param name="range">
        /// Specifies the number of contiguous empty display lists to be generated.
        /// </param>
        public static uint glGenLists(int range) {
            return Pointers.glGenLists(range);
        }
        
        public static void glGenNamesAMD(int identifier, uint num, uint* names) {
            Pointers.glGenNamesAMD(identifier, num, names);
        }
        
        public static void glGenNamesAMD(int identifier, uint num, uint[] names) {
            fixed(uint* names_ = &names[0])
                Pointers.glGenNamesAMD(identifier, num, names_);
        }
        
        public static void glGenOcclusionQueriesNV(int n, uint* ids) {
            Pointers.glGenOcclusionQueriesNV(n, ids);
        }
        
        public static void glGenOcclusionQueriesNV(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glGenOcclusionQueriesNV(n, ids_);
        }
        
        public static uint glGenOcclusionQueriesNV() {
            var ids_ = new uint[1];
            glGenOcclusionQueriesNV(1, ids_);
            return ids_[0];
        }
        
        public static uint glGenPathsNV(int range) {
            return Pointers.glGenPathsNV(range);
        }
        
        public static void glGenPerfMonitorsAMD(int n, uint* monitors) {
            Pointers.glGenPerfMonitorsAMD(n, monitors);
        }
        
        public static void glGenPerfMonitorsAMD(int n, uint[] monitors) {
            fixed(uint* monitors_ = &monitors[0])
                Pointers.glGenPerfMonitorsAMD(n, monitors_);
        }
        
        public static uint glGenPerfMonitorsAMD() {
            var monitors_ = new uint[1];
            glGenPerfMonitorsAMD(1, monitors_);
            return monitors_[0];
        }
        
        /// <summary>
        /// reserve program pipeline object names
        /// <para>
        /// glGenProgramPipelines returns n previously unused program pipeline object names in pipelines. These
        /// names are marked as used, for the purposes of glGenProgramPipelines only, but they acquire program
        /// pipeline state only when they are first bound
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        public static void glGenProgramPipelines(int n, uint* pipelines) {
            Pointers.glGenProgramPipelines(n, pipelines);
        }
        
        /// <summary>
        /// reserve program pipeline object names
        /// <para>
        /// glGenProgramPipelines returns n previously unused program pipeline object names in pipelines. These
        /// names are marked as used, for the purposes of glGenProgramPipelines only, but they acquire program
        /// pipeline state only when they are first bound
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of program pipeline object names to reserve.
        /// </param>
        /// <param name="pipelines">
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        public static void glGenProgramPipelines(int n, uint[] pipelines) {
            fixed(uint* pipelines_ = &pipelines[0])
                Pointers.glGenProgramPipelines(n, pipelines_);
        }
        
        public static uint glGenProgramPipeline() {
            var pipelines_ = new uint[1];
            glGenProgramPipelines(1, pipelines_);
            return pipelines_[0];
        }
        
        public static void glGenProgramPipelinesEXT(int n, uint* pipelines) {
            Pointers.glGenProgramPipelinesEXT(n, pipelines);
        }
        
        public static void glGenProgramPipelinesEXT(int n, uint[] pipelines) {
            fixed(uint* pipelines_ = &pipelines[0])
                Pointers.glGenProgramPipelinesEXT(n, pipelines_);
        }
        
        public static uint glGenProgramPipelinesEXT() {
            var pipelines_ = new uint[1];
            glGenProgramPipelinesEXT(1, pipelines_);
            return pipelines_[0];
        }
        
        public static void glGenProgramsARB(int n, uint* programs) {
            Pointers.glGenProgramsARB(n, programs);
        }
        
        public static void glGenProgramsARB(int n, uint[] programs) {
            fixed(uint* programs_ = &programs[0])
                Pointers.glGenProgramsARB(n, programs_);
        }
        
        public static uint glGenProgramsARB() {
            var programs_ = new uint[1];
            glGenProgramsARB(1, programs_);
            return programs_[0];
        }
        
        public static void glGenProgramsNV(int n, uint* programs) {
            Pointers.glGenProgramsNV(n, programs);
        }
        
        public static void glGenProgramsNV(int n, uint[] programs) {
            fixed(uint* programs_ = &programs[0])
                Pointers.glGenProgramsNV(n, programs_);
        }
        
        public static uint glGenProgramsNV() {
            var programs_ = new uint[1];
            glGenProgramsNV(1, programs_);
            return programs_[0];
        }
        
        /// <summary>
        /// generate query object names
        /// <para>
        /// glGenQueries returns n query object names in ids. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenQueries
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        public static void glGenQueries(int n, uint* ids) {
            Pointers.glGenQueries(n, ids);
        }
        
        /// <summary>
        /// generate query object names
        /// <para>
        /// glGenQueries returns n query object names in ids. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenQueries
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        public static void glGenQueries(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glGenQueries(n, ids_);
        }
        
        public static uint glGenQuerie() {
            var ids_ = new uint[1];
            glGenQueries(1, ids_);
            return ids_[0];
        }
        
        /// <summary>
        /// generate query object names
        /// <para>
        /// glGenQueries returns n query object names in ids. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenQueries
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        public static void glGenQueriesARB(int n, uint* ids) {
            Pointers.glGenQueriesARB(n, ids);
        }
        
        /// <summary>
        /// generate query object names
        /// <para>
        /// glGenQueries returns n query object names in ids. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenQueries
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of query object names to be generated.
        /// </param>
        /// <param name="ids">
        /// Specifies an array in which the generated query object names are stored.
        /// </param>
        public static void glGenQueriesARB(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glGenQueriesARB(n, ids_);
        }
        
        public static uint glGenQueriesARB() {
            var ids_ = new uint[1];
            glGenQueriesARB(1, ids_);
            return ids_[0];
        }
        
        public static void glGenQueriesEXT(int n, uint* ids) {
            Pointers.glGenQueriesEXT(n, ids);
        }
        
        public static void glGenQueriesEXT(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glGenQueriesEXT(n, ids_);
        }
        
        public static uint glGenQueriesEXT() {
            var ids_ = new uint[1];
            glGenQueriesEXT(1, ids_);
            return ids_[0];
        }
        
        public static void glGenQueryResourceTagNV(int n, int* tagIds) {
            Pointers.glGenQueryResourceTagNV(n, tagIds);
        }
        
        public static void glGenQueryResourceTagNV(int n, int[] tagIds) {
            fixed(int* tagIds_ = &tagIds[0])
                Pointers.glGenQueryResourceTagNV(n, tagIds_);
        }
        
        public static int glGenQueryResourceTagNV() {
            var tagIds_ = new int[1];
            glGenQueryResourceTagNV(1, tagIds_);
            return tagIds_[0];
        }
        
        /// <summary>
        /// generate renderbuffer object names
        /// <para>
        /// glGenRenderbuffers returns n renderbuffer object names in renderbuffers. There is no guarantee that
        /// the names form a contiguous set of integers; however, it is guaranteed that none of the returned
        /// names was in use immediately before the call to glGenRenderbuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        public static void glGenRenderbuffers(int n, uint* renderbuffers) {
            Pointers.glGenRenderbuffers(n, renderbuffers);
        }
        
        /// <summary>
        /// generate renderbuffer object names
        /// <para>
        /// glGenRenderbuffers returns n renderbuffer object names in renderbuffers. There is no guarantee that
        /// the names form a contiguous set of integers; however, it is guaranteed that none of the returned
        /// names was in use immediately before the call to glGenRenderbuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        public static void glGenRenderbuffers(int n, uint[] renderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glGenRenderbuffers(n, renderbuffers_);
        }
        
        public static uint glGenRenderbuffer() {
            var renderbuffers_ = new uint[1];
            glGenRenderbuffers(1, renderbuffers_);
            return renderbuffers_[0];
        }
        
        /// <summary>
        /// generate renderbuffer object names
        /// <para>
        /// glGenRenderbuffers returns n renderbuffer object names in renderbuffers. There is no guarantee that
        /// the names form a contiguous set of integers; however, it is guaranteed that none of the returned
        /// names was in use immediately before the call to glGenRenderbuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        public static void glGenRenderbuffersEXT(int n, uint* renderbuffers) {
            Pointers.glGenRenderbuffersEXT(n, renderbuffers);
        }
        
        /// <summary>
        /// generate renderbuffer object names
        /// <para>
        /// glGenRenderbuffers returns n renderbuffer object names in renderbuffers. There is no guarantee that
        /// the names form a contiguous set of integers; however, it is guaranteed that none of the returned
        /// names was in use immediately before the call to glGenRenderbuffers
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of renderbuffer object names to generate.
        /// </param>
        /// <param name="renderbuffers">
        /// Specifies an array in which the generated renderbuffer object names are stored.
        /// </param>
        public static void glGenRenderbuffersEXT(int n, uint[] renderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glGenRenderbuffersEXT(n, renderbuffers_);
        }
        
        public static uint glGenRenderbuffersEXT() {
            var renderbuffers_ = new uint[1];
            glGenRenderbuffersEXT(1, renderbuffers_);
            return renderbuffers_[0];
        }
        
        public static void glGenRenderbuffersOES(int n, uint* renderbuffers) {
            Pointers.glGenRenderbuffersOES(n, renderbuffers);
        }
        
        public static void glGenRenderbuffersOES(int n, uint[] renderbuffers) {
            fixed(uint* renderbuffers_ = &renderbuffers[0])
                Pointers.glGenRenderbuffersOES(n, renderbuffers_);
        }
        
        public static uint glGenRenderbuffersOES() {
            var renderbuffers_ = new uint[1];
            glGenRenderbuffersOES(1, renderbuffers_);
            return renderbuffers_[0];
        }
        
        /// <summary>
        /// generate sampler object names
        /// <para>
        /// glGenSamplers returns n sampler object names in samplers. There is no guarantee that the names form
        /// a contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenSamplers
        /// </para>
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        public static void glGenSamplers(int count, uint* samplers) {
            Pointers.glGenSamplers(count, samplers);
        }
        
        /// <summary>
        /// generate sampler object names
        /// <para>
        /// glGenSamplers returns n sampler object names in samplers. There is no guarantee that the names form
        /// a contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenSamplers
        /// </para>
        /// </summary>
        /// <param name="count">
        /// Specifies the number of sampler object names to generate.
        /// </param>
        /// <param name="samplers">
        /// Specifies an array in which the generated sampler object names are stored.
        /// </param>
        public static void glGenSamplers(int count, uint[] samplers) {
            fixed(uint* samplers_ = &samplers[0])
                Pointers.glGenSamplers(count, samplers_);
        }
        
        public static uint glGenSampler() {
            var samplers_ = new uint[1];
            glGenSamplers(1, samplers_);
            return samplers_[0];
        }
        
        public static void glGenSemaphoresEXT(int n, uint* semaphores) {
            Pointers.glGenSemaphoresEXT(n, semaphores);
        }
        
        public static void glGenSemaphoresEXT(int n, uint[] semaphores) {
            fixed(uint* semaphores_ = &semaphores[0])
                Pointers.glGenSemaphoresEXT(n, semaphores_);
        }
        
        public static uint glGenSemaphoresEXT() {
            var semaphores_ = new uint[1];
            glGenSemaphoresEXT(1, semaphores_);
            return semaphores_[0];
        }
        
        public static uint glGenSymbolsEXT(int datatype, int storagetype, int range, uint components) {
            return Pointers.glGenSymbolsEXT(datatype, storagetype, range, components);
        }
        
        /// <summary>
        /// generate texture names
        /// <para>
        /// glGenTextures returns n texture names in textures. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenTextures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        public static void glGenTextures(int n, uint* textures) {
            Pointers.glGenTextures(n, textures);
        }
        
        /// <summary>
        /// generate texture names
        /// <para>
        /// glGenTextures returns n texture names in textures. There is no guarantee that the names form a
        /// contiguous set of integers; however, it is guaranteed that none of the returned names was in use
        /// immediately before the call to glGenTextures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of texture names to be generated.
        /// </param>
        /// <param name="textures">
        /// Specifies an array in which the generated texture names are stored.
        /// </param>
        public static void glGenTextures(int n, uint[] textures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glGenTextures(n, textures_);
        }
        
        public static uint glGenTexture() {
            var textures_ = new uint[1];
            glGenTextures(1, textures_);
            return textures_[0];
        }
        
        public static void glGenTexturesEXT(int n, uint* textures) {
            Pointers.glGenTexturesEXT(n, textures);
        }
        
        public static void glGenTexturesEXT(int n, uint[] textures) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glGenTexturesEXT(n, textures_);
        }
        
        public static uint glGenTexturesEXT() {
            var textures_ = new uint[1];
            glGenTexturesEXT(1, textures_);
            return textures_[0];
        }
        
        /// <summary>
        /// reserve transform feedback object names
        /// <para>
        /// glGenTransformFeedbacks returns n previously unused transform feedback object names in ids. These
        /// names are marked as used, for the purposes of glGenTransformFeedbacks only, but they acquire
        /// transform feedback state only when they are first bound
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        public static void glGenTransformFeedbacks(int n, uint* ids) {
            Pointers.glGenTransformFeedbacks(n, ids);
        }
        
        /// <summary>
        /// reserve transform feedback object names
        /// <para>
        /// glGenTransformFeedbacks returns n previously unused transform feedback object names in ids. These
        /// names are marked as used, for the purposes of glGenTransformFeedbacks only, but they acquire
        /// transform feedback state only when they are first bound
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        public static void glGenTransformFeedbacks(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glGenTransformFeedbacks(n, ids_);
        }
        
        public static uint glGenTransformFeedback() {
            var ids_ = new uint[1];
            glGenTransformFeedbacks(1, ids_);
            return ids_[0];
        }
        
        /// <summary>
        /// reserve transform feedback object names
        /// <para>
        /// glGenTransformFeedbacks returns n previously unused transform feedback object names in ids. These
        /// names are marked as used, for the purposes of glGenTransformFeedbacks only, but they acquire
        /// transform feedback state only when they are first bound
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        public static void glGenTransformFeedbacksNV(int n, uint* ids) {
            Pointers.glGenTransformFeedbacksNV(n, ids);
        }
        
        /// <summary>
        /// reserve transform feedback object names
        /// <para>
        /// glGenTransformFeedbacks returns n previously unused transform feedback object names in ids. These
        /// names are marked as used, for the purposes of glGenTransformFeedbacks only, but they acquire
        /// transform feedback state only when they are first bound
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of transform feedback object names to reserve.
        /// </param>
        /// <param name="ids">
        /// Specifies an array of into which the reserved names will be written.
        /// </param>
        public static void glGenTransformFeedbacksNV(int n, uint[] ids) {
            fixed(uint* ids_ = &ids[0])
                Pointers.glGenTransformFeedbacksNV(n, ids_);
        }
        
        public static uint glGenTransformFeedbacksNV() {
            var ids_ = new uint[1];
            glGenTransformFeedbacksNV(1, ids_);
            return ids_[0];
        }
        
        /// <summary>
        /// generate vertex array object names
        /// <para>
        /// glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that the
        /// names form a contiguous set of integers; however, it is guaranteed that none of the returned names
        /// was in use immediately before the call to glGenVertexArrays
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        public static void glGenVertexArrays(int n, uint* arrays) {
            Pointers.glGenVertexArrays(n, arrays);
        }
        
        /// <summary>
        /// generate vertex array object names
        /// <para>
        /// glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that the
        /// names form a contiguous set of integers; however, it is guaranteed that none of the returned names
        /// was in use immediately before the call to glGenVertexArrays
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        public static void glGenVertexArrays(int n, uint[] arrays) {
            fixed(uint* arrays_ = &arrays[0])
                Pointers.glGenVertexArrays(n, arrays_);
        }
        
        public static uint glGenVertexArray() {
            var arrays_ = new uint[1];
            glGenVertexArrays(1, arrays_);
            return arrays_[0];
        }
        
        /// <summary>
        /// generate vertex array object names
        /// <para>
        /// glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that the
        /// names form a contiguous set of integers; however, it is guaranteed that none of the returned names
        /// was in use immediately before the call to glGenVertexArrays
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        public static void glGenVertexArraysAPPLE(int n, uint* arrays) {
            Pointers.glGenVertexArraysAPPLE(n, arrays);
        }
        
        /// <summary>
        /// generate vertex array object names
        /// <para>
        /// glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that the
        /// names form a contiguous set of integers; however, it is guaranteed that none of the returned names
        /// was in use immediately before the call to glGenVertexArrays
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        public static void glGenVertexArraysAPPLE(int n, uint[] arrays) {
            fixed(uint* arrays_ = &arrays[0])
                Pointers.glGenVertexArraysAPPLE(n, arrays_);
        }
        
        public static uint glGenVertexArraysAPPLE() {
            var arrays_ = new uint[1];
            glGenVertexArraysAPPLE(1, arrays_);
            return arrays_[0];
        }
        
        /// <summary>
        /// generate vertex array object names
        /// <para>
        /// glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that the
        /// names form a contiguous set of integers; however, it is guaranteed that none of the returned names
        /// was in use immediately before the call to glGenVertexArrays
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        public static void glGenVertexArraysOES(int n, uint* arrays) {
            Pointers.glGenVertexArraysOES(n, arrays);
        }
        
        /// <summary>
        /// generate vertex array object names
        /// <para>
        /// glGenVertexArrays returns n vertex array object names in arrays. There is no guarantee that the
        /// names form a contiguous set of integers; however, it is guaranteed that none of the returned names
        /// was in use immediately before the call to glGenVertexArrays
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of vertex array object names to generate.
        /// </param>
        /// <param name="arrays">
        /// Specifies an array in which the generated vertex array object names are stored.
        /// </param>
        public static void glGenVertexArraysOES(int n, uint[] arrays) {
            fixed(uint* arrays_ = &arrays[0])
                Pointers.glGenVertexArraysOES(n, arrays_);
        }
        
        public static uint glGenVertexArraysOES() {
            var arrays_ = new uint[1];
            glGenVertexArraysOES(1, arrays_);
            return arrays_[0];
        }
        
        public static uint glGenVertexShadersEXT(uint range) {
            return Pointers.glGenVertexShadersEXT(range);
        }
        
        /// <summary>
        /// generate mipmaps for a specified texture object
        /// <para>
        /// glGenerateMipmap and glGenerateTextureMipmap generates mipmaps for the specified texture object. For
        /// glGenerateMipmap, the texture object is that bound to to target. For glGenerateTextureMipmap,
        /// texture is the name of the texture object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of
        /// GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
        /// GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY.
        /// </param>
        public static void glGenerateMipmap(int target) {
            Pointers.glGenerateMipmap(target);
        }
        
        /// <summary>
        /// generate mipmaps for a specified texture object
        /// <para>
        /// glGenerateMipmap and glGenerateTextureMipmap generates mipmaps for the specified texture object. For
        /// glGenerateMipmap, the texture object is that bound to to target. For glGenerateTextureMipmap,
        /// texture is the name of the texture object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glGenerateMipmap. Must be one of
        /// GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
        /// GL_TEXTURE_CUBE_MAP, or GL_TEXTURE_CUBE_MAP_ARRAY.
        /// </param>
        public static void glGenerateMipmapEXT(int target) {
            Pointers.glGenerateMipmapEXT(target);
        }
        
        public static void glGenerateMipmapOES(int target) {
            Pointers.glGenerateMipmapOES(target);
        }
        
        public static void glGenerateMultiTexMipmapEXT(int texunit, int target) {
            Pointers.glGenerateMultiTexMipmapEXT(texunit, target);
        }
        
        public static void glGenerateTextureMipmap(uint texture) {
            Pointers.glGenerateTextureMipmap(texture);
        }
        
        public static void glGenerateTextureMipmapEXT(uint texture, int target) {
            Pointers.glGenerateTextureMipmapEXT(texture, target);
        }
        
        /// <summary>
        /// retrieve information about the set of active atomic counter buffers for a program
        /// <para>
        /// glGetActiveAtomicCounterBufferiv retrieves information about the set of active atomic counter
        /// buffers for a program object. program is the name of a program object for which the command
        /// glLinkProgram has been issued in the past. It is not necessary for program to have been linked
        /// successfully. The link may have failed because the number of active atomic counters exceeded the
        /// limits
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object from which to retrieve information.
        /// </param>
        /// <param name="bufferIndex">
        /// Specifies index of an active atomic counter buffer.
        /// </param>
        /// <param name="pname">
        /// Specifies which parameter of the atomic counter buffer to retrieve.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </param>
        public static void glGetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, int pname, int* _params) {
            Pointers.glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, _params);
        }
        
        /// <summary>
        /// retrieve information about the set of active atomic counter buffers for a program
        /// <para>
        /// glGetActiveAtomicCounterBufferiv retrieves information about the set of active atomic counter
        /// buffers for a program object. program is the name of a program object for which the command
        /// glLinkProgram has been issued in the past. It is not necessary for program to have been linked
        /// successfully. The link may have failed because the number of active atomic counters exceeded the
        /// limits
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object from which to retrieve information.
        /// </param>
        /// <param name="bufferIndex">
        /// Specifies index of an active atomic counter buffer.
        /// </param>
        /// <param name="pname">
        /// Specifies which parameter of the atomic counter buffer to retrieve.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </param>
        public static void glGetActiveAtomicCounterBufferiv(uint program, uint bufferIndex, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetActiveAtomicCounterBufferiv(program, bufferIndex, pname, _params_);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, int* type, StringBuilder name) {
            Pointers.glGetActiveAttrib(program, index, bufSize, length, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, int* length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttrib(program, index, bufSize, length, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, int* length, out int size, int* type, StringBuilder name) {
            fixed(int* size_ = &size)
                Pointers.glGetActiveAttrib(program, index, bufSize, length, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, int* length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttrib(program, index, bufSize, length, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, out int length, int* size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveAttrib(program, index, bufSize, length_, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, out int length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttrib(program, index, bufSize, length_, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, out int length, out int size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
                Pointers.glGetActiveAttrib(program, index, bufSize, length_, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttrib(uint program, uint index, int bufSize, out int length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttrib(program, index, bufSize, length_, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, int* size, int* type, StringBuilder name) {
            Pointers.glGetActiveAttribARB(programObj, index, maxLength, length, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttribARB(programObj, index, maxLength, length, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, out int size, int* type, StringBuilder name) {
            fixed(int* size_ = &size)
                Pointers.glGetActiveAttribARB(programObj, index, maxLength, length, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, int* length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttribARB(programObj, index, maxLength, length, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, out int length, int* size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveAttribARB(programObj, index, maxLength, length_, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, out int length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttribARB(programObj, index, maxLength, length_, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, out int length, out int size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
                Pointers.glGetActiveAttribARB(programObj, index, maxLength, length_, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active attribute variable for the specified program object
        /// <para>
        /// glGetActiveAttrib returns information about an active attribute variable in the program object
        /// specified by program. The number of active attributes can be obtained by calling glGetProgram with
        /// the value GL_ACTIVE_ATTRIBUTES. A value of 0 for index selects the first active attribute variable.
        /// Permissible values for index range from zero to the number of active attribute variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the attribute variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the attribute variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the attribute variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveAttribARB(uint programObj, uint index, int maxLength, out int length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveAttribARB(programObj, index, maxLength, length_, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine
        /// <para>
        /// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the program
        /// object given in program. index specifies the index of the shader subroutine uniform within the
        /// shader stage given by stage, and must between zero and the value of GL_ACTIVE_SUBROUTINES minus one
        /// for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query the subroutine name.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        public static void glGetActiveSubroutineName(uint program, int shadertype, uint index, int bufsize, int* length, StringBuilder name) {
            Pointers.glGetActiveSubroutineName(program, shadertype, index, bufsize, length, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine
        /// <para>
        /// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the program
        /// object given in program. index specifies the index of the shader subroutine uniform within the
        /// shader stage given by stage, and must between zero and the value of GL_ACTIVE_SUBROUTINES minus one
        /// for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query the subroutine name.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        public static void glGetActiveSubroutineName(uint program, int shadertype, uint index, int bufsize, out int length, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveSubroutineName(program, shadertype, index, bufsize, length_, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine
        /// <para>
        /// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the program
        /// object given in program. index specifies the index of the shader subroutine uniform within the
        /// shader stage given by stage, and must between zero and the value of GL_ACTIVE_SUBROUTINES minus one
        /// for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query the subroutine name.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        public static void glGetActiveSubroutineName(uint program, Enums.ShaderType shadertype, uint index, int bufsize, int* length, StringBuilder name) {
            Pointers.glGetActiveSubroutineName(program, (int)shadertype, index, bufsize, length, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine
        /// <para>
        /// glGetActiveSubroutineName queries the name of an active shader subroutine uniform from the program
        /// object given in program. index specifies the index of the shader subroutine uniform within the
        /// shader stage given by stage, and must between zero and the value of GL_ACTIVE_SUBROUTINES minus one
        /// for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query the subroutine name.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable which is to receive the length of the shader subroutine uniform
        /// name.
        /// </param>
        public static void glGetActiveSubroutineName(uint program, Enums.ShaderType shadertype, uint index, int bufsize, out int length, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveSubroutineName(program, (int)shadertype, index, bufsize, length_, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage for which
        /// which the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        public static void glGetActiveSubroutineUniformName(uint program, int shadertype, uint index, int bufsize, int* length, StringBuilder name) {
            Pointers.glGetActiveSubroutineUniformName(program, shadertype, index, bufsize, length, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage for which
        /// which the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        public static void glGetActiveSubroutineUniformName(uint program, int shadertype, uint index, int bufsize, out int length, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveSubroutineUniformName(program, shadertype, index, bufsize, length_, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage for which
        /// which the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        public static void glGetActiveSubroutineUniformName(uint program, Enums.ShaderType shadertype, uint index, int bufsize, int* length, StringBuilder name) {
            Pointers.glGetActiveSubroutineUniformName(program, (int)shadertype, index, bufsize, length, name);
        }
        
        /// <summary>
        /// query the name of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniformName retrieves the name of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage for which
        /// which the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="bufsize">
        /// Specifies the size of the buffer whose address is given in name.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        /// <param name="name">
        /// Specifies the address of a variable into which is written the number of characters copied into name.
        /// </param>
        public static void glGetActiveSubroutineUniformName(uint program, Enums.ShaderType shadertype, uint index, int bufsize, out int length, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveSubroutineUniformName(program, (int)shadertype, index, bufsize, length_, name);
        }
        
        /// <summary>
        /// query a property of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniform queries a parameter of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage which which
        /// the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader subroutine uniform to query. pname must be
        /// GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a into which the queried value or values will be placed.
        /// </param>
        public static void glGetActiveSubroutineUniformiv(uint program, int shadertype, uint index, int pname, int* values) {
            Pointers.glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values);
        }
        
        /// <summary>
        /// query a property of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniform queries a parameter of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage which which
        /// the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader subroutine uniform to query. pname must be
        /// GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a into which the queried value or values will be placed.
        /// </param>
        public static void glGetActiveSubroutineUniformiv(uint program, int shadertype, uint index, int pname, int[] values) {
            fixed(int* values_ = &values[0])
                Pointers.glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values_);
        }
        
        /// <summary>
        /// query a property of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniform queries a parameter of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage which which
        /// the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader subroutine uniform to query. pname must be
        /// GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a into which the queried value or values will be placed.
        /// </param>
        public static void glGetActiveSubroutineUniformiv(uint program, Enums.ShaderType shadertype, uint index, int pname, int* values) {
            Pointers.glGetActiveSubroutineUniformiv(program, (int)shadertype, index, pname, values);
        }
        
        /// <summary>
        /// query a property of an active shader subroutine uniform
        /// <para>
        /// glGetActiveSubroutineUniform queries a parameter of an active shader subroutine uniform. program
        /// contains the name of the program containing the uniform. shadertype specifies the stage which which
        /// the uniform location, given by index, is valid. index must be between zero and the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORMS minus one for the shader stage
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing the subroutine.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the shader subroutine uniform.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader subroutine uniform to query. pname must be
        /// GL_NUM_COMPATIBLE_SUBROUTINES, GL_COMPATIBLE_SUBROUTINES, GL_UNIFORM_SIZE or GL_UNIFORM_NAME_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a into which the queried value or values will be placed.
        /// </param>
        public static void glGetActiveSubroutineUniformiv(uint program, Enums.ShaderType shadertype, uint index, int pname, int[] values) {
            fixed(int* values_ = &values[0])
                Pointers.glGetActiveSubroutineUniformiv(program, (int)shadertype, index, pname, values_);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, int* type, StringBuilder name) {
            Pointers.glGetActiveUniform(program, index, bufSize, length, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, int* length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniform(program, index, bufSize, length, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, int* length, out int size, int* type, StringBuilder name) {
            fixed(int* size_ = &size)
                Pointers.glGetActiveUniform(program, index, bufSize, length, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, int* length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniform(program, index, bufSize, length, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, out int length, int* size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveUniform(program, index, bufSize, length_, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, out int length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniform(program, index, bufSize, length_, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, out int length, out int size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
                Pointers.glGetActiveUniform(program, index, bufSize, length_, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniform(uint program, uint index, int bufSize, out int length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniform(program, index, bufSize, length_, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, int* size, int* type, StringBuilder name) {
            Pointers.glGetActiveUniformARB(programObj, index, maxLength, length, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniformARB(programObj, index, maxLength, length, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, out int size, int* type, StringBuilder name) {
            fixed(int* size_ = &size)
                Pointers.glGetActiveUniformARB(programObj, index, maxLength, length, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, int* length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniformARB(programObj, index, maxLength, length, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, out int length, int* size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveUniformARB(programObj, index, maxLength, length_, size, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, out int length, int* size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniformARB(programObj, index, maxLength, length_, size, (int*)type_, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, out int length, out int size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
                Pointers.glGetActiveUniformARB(programObj, index, maxLength, length_, size_, type, name);
        }
        
        /// <summary>
        /// Returns information about an active uniform variable for the specified program object
        /// <para>
        /// glGetActiveUniform returns information about an active uniform variable in the program object
        /// specified by program. The number of active uniform variables can be obtained by calling glGetProgram
        /// with the value GL_ACTIVE_UNIFORMS. A value of 0 for index selects the first active uniform variable.
        /// Permissible values for index range from zero to the number of active uniform variables minus one
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the uniform variable to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the maximum number of characters OpenGL is allowed to write in the character buffer
        /// indicated by name.
        /// </param>
        /// <param name="length">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        /// <param name="size">
        /// Returns the size of the uniform variable.
        /// </param>
        /// <param name="type">
        /// Returns the data type of the uniform variable.
        /// </param>
        /// <param name="name">
        /// Returns the number of characters actually written by OpenGL in the string indicated by name
        /// (excluding the null terminator) if a value other than NULL is passed.
        /// </param>
        public static void glGetActiveUniformARB(uint programObj, uint index, int maxLength, out int length, out int size, out Enums.AttributeType type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
            fixed(Enums.AttributeType* type_ = &type)
                Pointers.glGetActiveUniformARB(programObj, index, maxLength, length_, size_, (int*)type_, name);
        }
        
        /// <summary>
        /// retrieve the name of an active uniform block
        /// <para>
        /// glGetActiveUniformBlockName retrieves the name of the active uniform block at uniformBlockIndex
        /// within program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of characters that were written to
        /// uniformBlockName.
        /// </param>
        /// <param name="uniformBlockName">
        /// Specifies the address of a variable to receive the number of characters that were written to
        /// uniformBlockName.
        /// </param>
        public static void glGetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, int* length, StringBuilder uniformBlockName) {
            Pointers.glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
        }
        
        /// <summary>
        /// retrieve the name of an active uniform block
        /// <para>
        /// glGetActiveUniformBlockName retrieves the name of the active uniform block at uniformBlockIndex
        /// within program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer addressed by uniformBlockName.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of characters that were written to
        /// uniformBlockName.
        /// </param>
        /// <param name="uniformBlockName">
        /// Specifies the address of a variable to receive the number of characters that were written to
        /// uniformBlockName.
        /// </param>
        public static void glGetActiveUniformBlockName(uint program, uint uniformBlockIndex, int bufSize, out int length, StringBuilder uniformBlockName) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length_, uniformBlockName);
        }
        
        /// <summary>
        /// query information about an active uniform block
        /// <para>
        /// glGetActiveUniformBlockiv retrieves information about an active uniform block within program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        public static void glGetActiveUniformBlockiv(uint program, uint uniformBlockIndex, int pname, int* _params) {
            Pointers.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, _params);
        }
        
        /// <summary>
        /// query information about an active uniform block
        /// <para>
        /// glGetActiveUniformBlockiv retrieves information about an active uniform block within program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// Specifies the index of the uniform block within program.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to query.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable to receive the result of the query.
        /// </param>
        public static void glGetActiveUniformBlockiv(uint program, uint uniformBlockIndex, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, _params_);
        }
        
        /// <summary>
        /// query the name of an active uniform
        /// <para>
        /// glGetActiveUniformName returns the name of the active uniform at uniformIndex within program. If
        /// uniformName is not NULL, up to bufSize characters (including a nul-terminator) will be written into
        /// the array whose address is specified by uniformName. If length is not NULL, the number of characters
        /// that were (or would have been) written into uniformName (not including the nul-terminator) will be
        /// placed in the variable whose address is specified in length. If length is NULL, no length is
        /// returned. The length of the longest uniform name in program is given by the value of
        /// GL_ACTIVE_UNIFORM_MAX_LENGTH, which can be queried with glGetProgram
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program containing the active uniform index uniformIndex.
        /// </param>
        /// <param name="uniformIndex">
        /// Specifies the index of the active uniform whose name to query.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in
        /// uniformName.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable that will receive the number of characters that were or would
        /// have been written to the buffer addressed by uniformName.
        /// </param>
        /// <param name="uniformName">
        /// Specifies the address of a variable that will receive the number of characters that were or would
        /// have been written to the buffer addressed by uniformName.
        /// </param>
        public static void glGetActiveUniformName(uint program, uint uniformIndex, int bufSize, int* length, StringBuilder uniformName) {
            Pointers.glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
        }
        
        /// <summary>
        /// query the name of an active uniform
        /// <para>
        /// glGetActiveUniformName returns the name of the active uniform at uniformIndex within program. If
        /// uniformName is not NULL, up to bufSize characters (including a nul-terminator) will be written into
        /// the array whose address is specified by uniformName. If length is not NULL, the number of characters
        /// that were (or would have been) written into uniformName (not including the nul-terminator) will be
        /// placed in the variable whose address is specified in length. If length is NULL, no length is
        /// returned. The length of the longest uniform name in program is given by the value of
        /// GL_ACTIVE_UNIFORM_MAX_LENGTH, which can be queried with glGetProgram
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program containing the active uniform index uniformIndex.
        /// </param>
        /// <param name="uniformIndex">
        /// Specifies the index of the active uniform whose name to query.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer, in units of GLchar, of the buffer whose address is specified in
        /// uniformName.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable that will receive the number of characters that were or would
        /// have been written to the buffer addressed by uniformName.
        /// </param>
        /// <param name="uniformName">
        /// Specifies the address of a variable that will receive the number of characters that were or would
        /// have been written to the buffer addressed by uniformName.
        /// </param>
        public static void glGetActiveUniformName(uint program, uint uniformIndex, int bufSize, out int length, StringBuilder uniformName) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveUniformName(program, uniformIndex, bufSize, length_, uniformName);
        }
        
        /// <summary>
        /// Returns information about several active uniform variables for the specified program object
        /// <para>
        /// glGetActiveUniformsiv queries the value of the parameter named pname for each of the uniforms within
        /// program whose indices are specified in the array of uniformCount unsigned integers uniformIndices.
        /// Upon success, the value of the parameter for each uniform is written into the corresponding entry in
        /// the array whose address is given in params. If an error is generated, nothing is written into params
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of
        /// parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the
        /// corresponding element of params.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        public static void glGetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, int pname, int* _params) {
            Pointers.glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, _params);
        }
        
        /// <summary>
        /// Returns information about several active uniform variables for the specified program object
        /// <para>
        /// glGetActiveUniformsiv queries the value of the parameter named pname for each of the uniforms within
        /// program whose indices are specified in the array of uniformCount unsigned integers uniformIndices.
        /// Upon success, the value of the parameter for each uniform is written into the corresponding entry in
        /// the array whose address is given in params. If an error is generated, nothing is written into params
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of
        /// parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the
        /// corresponding element of params.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        public static void glGetActiveUniformsiv(uint program, int uniformCount, uint* uniformIndices, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, _params_);
        }
        
        /// <summary>
        /// Returns information about several active uniform variables for the specified program object
        /// <para>
        /// glGetActiveUniformsiv queries the value of the parameter named pname for each of the uniforms within
        /// program whose indices are specified in the array of uniformCount unsigned integers uniformIndices.
        /// Upon success, the value of the parameter for each uniform is written into the corresponding entry in
        /// the array whose address is given in params. If an error is generated, nothing is written into params
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of
        /// parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the
        /// corresponding element of params.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        public static void glGetActiveUniformsiv(uint program, int uniformCount, uint[] uniformIndices, int pname, int* _params) {
            fixed(uint* uniformIndices_ = &uniformIndices[0])
                Pointers.glGetActiveUniformsiv(program, uniformCount, uniformIndices_, pname, _params);
        }
        
        /// <summary>
        /// Returns information about several active uniform variables for the specified program object
        /// <para>
        /// glGetActiveUniformsiv queries the value of the parameter named pname for each of the uniforms within
        /// program whose indices are specified in the array of uniformCount unsigned integers uniformIndices.
        /// Upon success, the value of the parameter for each uniform is written into the corresponding entry in
        /// the array whose address is given in params. If an error is generated, nothing is written into params
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies both the number of elements in the array of indices uniformIndices and the number of
        /// parameters written to params upon successful return.
        /// </param>
        /// <param name="uniformIndices">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the property of each uniform in uniformIndices that should be written into the
        /// corresponding element of params.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of an array of uniformCount integers containing the indices of uniforms within
        /// program whose parameter pname should be queried.
        /// </param>
        public static void glGetActiveUniformsiv(uint program, int uniformCount, uint[] uniformIndices, int pname, int[] _params) {
            fixed(uint* uniformIndices_ = &uniformIndices[0])
            fixed(int* _params_ = &_params[0])
                Pointers.glGetActiveUniformsiv(program, uniformCount, uniformIndices_, pname, _params_);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, int* type, StringBuilder name) {
            Pointers.glGetActiveVaryingNV(program, index, bufSize, length, size, type, name);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, int* length, int* size, out int type, StringBuilder name) {
            fixed(int* type_ = &type)
                Pointers.glGetActiveVaryingNV(program, index, bufSize, length, size, type_, name);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, int* length, out int size, int* type, StringBuilder name) {
            fixed(int* size_ = &size)
                Pointers.glGetActiveVaryingNV(program, index, bufSize, length, size_, type, name);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, int* length, out int size, out int type, StringBuilder name) {
            fixed(int* size_ = &size)
            fixed(int* type_ = &type)
                Pointers.glGetActiveVaryingNV(program, index, bufSize, length, size_, type_, name);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, out int length, int* size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetActiveVaryingNV(program, index, bufSize, length_, size, type, name);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, out int length, int* size, out int type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* type_ = &type)
                Pointers.glGetActiveVaryingNV(program, index, bufSize, length_, size, type_, name);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, out int length, out int size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
                Pointers.glGetActiveVaryingNV(program, index, bufSize, length_, size_, type, name);
        }
        
        public static void glGetActiveVaryingNV(uint program, uint index, int bufSize, out int length, out int size, out int type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
            fixed(int* type_ = &type)
                Pointers.glGetActiveVaryingNV(program, index, bufSize, length_, size_, type_, name);
        }
        
        public static void glGetArrayObjectfvATI(int array, int pname, float* _params) {
            Pointers.glGetArrayObjectfvATI(array, pname, _params);
        }
        
        public static void glGetArrayObjectfvATI(int array, int pname, out float _params) {
            fixed(float* _params_ = &_params)
                Pointers.glGetArrayObjectfvATI(array, pname, _params_);
        }
        
        public static void glGetArrayObjectivATI(int array, int pname, int* _params) {
            Pointers.glGetArrayObjectivATI(array, pname, _params);
        }
        
        public static void glGetArrayObjectivATI(int array, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetArrayObjectivATI(array, pname, _params_);
        }
        
        public static void glGetAttachedObjectsARB(uint containerObj, int maxCount, int* count, uint* obj) {
            Pointers.glGetAttachedObjectsARB(containerObj, maxCount, count, obj);
        }
        
        public static void glGetAttachedObjectsARB(uint containerObj, int maxCount, int* count, uint[] obj) {
            fixed(uint* obj_ = &obj[0])
                Pointers.glGetAttachedObjectsARB(containerObj, maxCount, count, obj_);
        }
        
        public static void glGetAttachedObjectsARB(uint containerObj, int maxCount, out int count, uint* obj) {
            fixed(int* count_ = &count)
                Pointers.glGetAttachedObjectsARB(containerObj, maxCount, count_, obj);
        }
        
        public static void glGetAttachedObjectsARB(uint containerObj, int maxCount, out int count, uint[] obj) {
            fixed(int* count_ = &count)
            fixed(uint* obj_ = &obj[0])
                Pointers.glGetAttachedObjectsARB(containerObj, maxCount, count_, obj_);
        }
        
        /// <summary>
        /// Returns the handles of the shader objects attached to a program object
        /// <para>
        /// glGetAttachedShaders returns the names of the shader objects attached to program. The names of
        /// shader objects that are attached to program will be returned in shaders. The actual number of shader
        /// names written into shaders is returned in count. If no shader objects are attached to program, count
        /// is set to 0. The maximum number of shader names that may be returned in shaders is specified by
        /// maxCount
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        public static void glGetAttachedShaders(uint program, int maxCount, int* count, uint* shaders) {
            Pointers.glGetAttachedShaders(program, maxCount, count, shaders);
        }
        
        /// <summary>
        /// Returns the handles of the shader objects attached to a program object
        /// <para>
        /// glGetAttachedShaders returns the names of the shader objects attached to program. The names of
        /// shader objects that are attached to program will be returned in shaders. The actual number of shader
        /// names written into shaders is returned in count. If no shader objects are attached to program, count
        /// is set to 0. The maximum number of shader names that may be returned in shaders is specified by
        /// maxCount
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        public static void glGetAttachedShaders(uint program, int maxCount, int* count, uint[] shaders) {
            fixed(uint* shaders_ = &shaders[0])
                Pointers.glGetAttachedShaders(program, maxCount, count, shaders_);
        }
        
        /// <summary>
        /// Returns the handles of the shader objects attached to a program object
        /// <para>
        /// glGetAttachedShaders returns the names of the shader objects attached to program. The names of
        /// shader objects that are attached to program will be returned in shaders. The actual number of shader
        /// names written into shaders is returned in count. If no shader objects are attached to program, count
        /// is set to 0. The maximum number of shader names that may be returned in shaders is specified by
        /// maxCount
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        public static void glGetAttachedShaders(uint program, int maxCount, out int count, uint* shaders) {
            fixed(int* count_ = &count)
                Pointers.glGetAttachedShaders(program, maxCount, count_, shaders);
        }
        
        /// <summary>
        /// Returns the handles of the shader objects attached to a program object
        /// <para>
        /// glGetAttachedShaders returns the names of the shader objects attached to program. The names of
        /// shader objects that are attached to program will be returned in shaders. The actual number of shader
        /// names written into shaders is returned in count. If no shader objects are attached to program, count
        /// is set to 0. The maximum number of shader names that may be returned in shaders is specified by
        /// maxCount
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="maxCount">
        /// Specifies the size of the array for storing the returned object names.
        /// </param>
        /// <param name="count">
        /// Returns the number of names actually returned in shaders.
        /// </param>
        /// <param name="shaders">
        /// Specifies an array that is used to return the names of attached shader objects.
        /// </param>
        public static void glGetAttachedShaders(uint program, int maxCount, out int count, uint[] shaders) {
            fixed(int* count_ = &count)
            fixed(uint* shaders_ = &shaders[0])
                Pointers.glGetAttachedShaders(program, maxCount, count_, shaders_);
        }
        
        /// <summary>
        /// Returns the location of an attribute variable
        /// <para>
        /// glGetAttribLocation queries the previously linked program object specified by program for the
        /// attribute variable specified by name and returns the index of the generic vertex attribute that is
        /// bound to that attribute variable. If name is a matrix attribute variable, the index of the first
        /// column of the matrix is returned. If the named attribute variable is not an active attribute in the
        /// specified program object or if name starts with the reserved prefix &quot;gl_&quot;, a value of -1
        /// is returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the attribute variable whose location is
        /// to be queried.
        /// </param>
        public static int glGetAttribLocation(uint program, string name) {
            return Pointers.glGetAttribLocation(program, name);
        }
        
        /// <summary>
        /// Returns the location of an attribute variable
        /// <para>
        /// glGetAttribLocation queries the previously linked program object specified by program for the
        /// attribute variable specified by name and returns the index of the generic vertex attribute that is
        /// bound to that attribute variable. If name is a matrix attribute variable, the index of the first
        /// column of the matrix is returned. If the named attribute variable is not an active attribute in the
        /// specified program object or if name starts with the reserved prefix &quot;gl_&quot;, a value of -1
        /// is returned
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the attribute variable whose location is
        /// to be queried.
        /// </param>
        public static int glGetAttribLocationARB(uint programObj, string name) {
            return Pointers.glGetAttribLocationARB(programObj, name);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetBooleanIndexedvEXT(int target, uint index, bool* data) {
            Pointers.glGetBooleanIndexedvEXT(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetBooleanIndexedvEXT(int target, uint index, bool[] data) {
            fixed(bool* data_ = &data[0])
                Pointers.glGetBooleanIndexedvEXT(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetBooleani_v(int target, uint index, bool* data) {
            Pointers.glGetBooleani_v(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetBooleani_v(int target, uint index, bool[] data) {
            fixed(bool* data_ = &data[0])
                Pointers.glGetBooleani_v(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetBooleanv(int pname, bool* data) {
            Pointers.glGetBooleanv(pname, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetBooleanv(int pname, bool[] data) {
            fixed(bool* data_ = &data[0])
                Pointers.glGetBooleanv(pname, data_);
        }
        
        public static bool glGetBooleanv(int pname) {
            bool data;
            glGetBooleanv(pname, &data);
            return data;
        }
        
        public static void glGetBufferParameteri64v(int target, int pname, long* _params) {
            Pointers.glGetBufferParameteri64v(target, pname, _params);
        }
        
        public static void glGetBufferParameteri64v(int target, int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetBufferParameteri64v(target, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a buffer object
        /// <para>
        /// These functions return in data a selected parameter of the specified buffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferParameteriv and
        /// glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the buffer object parameter to query.
        /// </param>
        /// <param name="_params">
        /// Returns the requested parameter.
        /// </param>
        public static void glGetBufferParameteriv(int target, int pname, int* _params) {
            Pointers.glGetBufferParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a buffer object
        /// <para>
        /// These functions return in data a selected parameter of the specified buffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferParameteriv and
        /// glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the buffer object parameter to query.
        /// </param>
        /// <param name="_params">
        /// Returns the requested parameter.
        /// </param>
        public static void glGetBufferParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetBufferParameteriv(target, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a buffer object
        /// <para>
        /// These functions return in data a selected parameter of the specified buffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferParameteriv and
        /// glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the buffer object parameter to query.
        /// </param>
        /// <param name="_params">
        /// Returns the requested parameter.
        /// </param>
        public static void glGetBufferParameterivARB(int target, int pname, int* _params) {
            Pointers.glGetBufferParameterivARB(target, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a buffer object
        /// <para>
        /// These functions return in data a selected parameter of the specified buffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferParameteriv and
        /// glGetBufferParameteri64v. Must be one of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the buffer object parameter to query.
        /// </param>
        /// <param name="_params">
        /// Returns the requested parameter.
        /// </param>
        public static void glGetBufferParameterivARB(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetBufferParameterivARB(target, pname, _params_);
        }
        
        public static void glGetBufferParameterui64vNV(int target, int pname, ulong* _params) {
            Pointers.glGetBufferParameterui64vNV(target, pname, _params);
        }
        
        public static void glGetBufferParameterui64vNV(int target, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetBufferParameterui64vNV(target, pname, _params_);
        }
        
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>
        /// glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be
        /// GL_BUFFER_MAP_POINTER. The single buffer map pointer is returned in params. A NULL pointer is
        /// returned if the buffer object's data store is not currently mapped; or if the requesting context did
        /// not map the buffer object's data store, and the implementation is unable to support mappings on
        /// multiple clients
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetBufferPointerv(int target, int pname, IntPtr* _params) {
            Pointers.glGetBufferPointerv(target, pname, _params);
        }
        
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>
        /// glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be
        /// GL_BUFFER_MAP_POINTER. The single buffer map pointer is returned in params. A NULL pointer is
        /// returned if the buffer object's data store is not currently mapped; or if the requesting context did
        /// not map the buffer object's data store, and the implementation is unable to support mappings on
        /// multiple clients
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetBufferPointerv(int target, int pname, out IntPtr _params) {
            fixed(IntPtr* _params_ = &_params)
                Pointers.glGetBufferPointerv(target, pname, _params_);
        }
        
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>
        /// glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be
        /// GL_BUFFER_MAP_POINTER. The single buffer map pointer is returned in params. A NULL pointer is
        /// returned if the buffer object's data store is not currently mapped; or if the requesting context did
        /// not map the buffer object's data store, and the implementation is unable to support mappings on
        /// multiple clients
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetBufferPointervARB(int target, int pname, IntPtr* _params) {
            Pointers.glGetBufferPointervARB(target, pname, _params);
        }
        
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>
        /// glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be
        /// GL_BUFFER_MAP_POINTER. The single buffer map pointer is returned in params. A NULL pointer is
        /// returned if the buffer object's data store is not currently mapped; or if the requesting context did
        /// not map the buffer object's data store, and the implementation is unable to support mappings on
        /// multiple clients
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetBufferPointervARB(int target, int pname, out IntPtr _params) {
            fixed(IntPtr* _params_ = &_params)
                Pointers.glGetBufferPointervARB(target, pname, _params_);
        }
        
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>
        /// glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be
        /// GL_BUFFER_MAP_POINTER. The single buffer map pointer is returned in params. A NULL pointer is
        /// returned if the buffer object's data store is not currently mapped; or if the requesting context did
        /// not map the buffer object's data store, and the implementation is unable to support mappings on
        /// multiple clients
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetBufferPointervOES(int target, int pname, IntPtr* _params) {
            Pointers.glGetBufferPointervOES(target, pname, _params);
        }
        
        /// <summary>
        /// return the pointer to a mapped buffer object's data store
        /// <para>
        /// glGetBufferPointerv and glGetNamedBufferPointerv return the buffer pointer pname, which must be
        /// GL_BUFFER_MAP_POINTER. The single buffer map pointer is returned in params. A NULL pointer is
        /// returned if the buffer object's data store is not currently mapped; or if the requesting context did
        /// not map the buffer object's data store, and the implementation is unable to support mappings on
        /// multiple clients
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferPointerv, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the pointer to be returned. Must be GL_BUFFER_MAP_POINTER.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetBufferPointervOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetBufferPointervOES(target, pname, _params_);
        }
        
        /// <summary>
        /// returns a subset of a buffer object's data store
        /// <para>
        /// glGetBufferSubData and glGetNamedBufferSubData return some or all of the data contents of the data
        /// store of the specified buffer object. Data starting at byte offset offset and extending for size
        /// bytes is copied from the buffer object's data store to the memory pointed to by data. An error is
        /// thrown if the buffer object is currently mapped, or if offset and size together define a range
        /// beyond the bounds of the buffer object's data store
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferSubData, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store from which data will be returned, measured
        /// in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being returned.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the location where buffer object data is returned.
        /// </param>
        public static void glGetBufferSubData(int target, uint offset, uint size, IntPtr data) {
            Pointers.glGetBufferSubData(target, offset, size, data);
        }
        
        /// <summary>
        /// returns a subset of a buffer object's data store
        /// <para>
        /// glGetBufferSubData and glGetNamedBufferSubData return some or all of the data contents of the data
        /// store of the specified buffer object. Data starting at byte offset offset and extending for size
        /// bytes is copied from the buffer object's data store to the memory pointed to by data. An error is
        /// thrown if the buffer object is currently mapped, or if offset and size together define a range
        /// beyond the bounds of the buffer object's data store
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glGetBufferSubData, which must be one
        /// of the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the offset into the buffer object's data store from which data will be returned, measured
        /// in bytes.
        /// </param>
        /// <param name="size">
        /// Specifies the size in bytes of the data store region being returned.
        /// </param>
        /// <param name="data">
        /// Specifies a pointer to the location where buffer object data is returned.
        /// </param>
        public static void glGetBufferSubDataARB(int target, IntPtr offset, uint size, IntPtr data) {
            Pointers.glGetBufferSubDataARB(target, offset, size, data);
        }
        
        /// <summary>
        /// return the coefficients of the specified clipping plane
        /// <para>
        /// glGetClipPlane returns in equation the four coefficients of the plane equation for plane
        /// </para>
        /// </summary>
        /// <param name="plane">
        /// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at
        /// least six clipping planes are supported. They are identified by symbolic names of the form
        /// GL_CLIP_PLANE i where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
        /// </param>
        /// <param name="equation">
        /// Returns four double-precision values that are the coefficients of the plane equation of plane in eye
        /// coordinates. The initial value is (0, 0, 0, 0).
        /// </param>
        public static void glGetClipPlane(int plane, double* equation) {
            Pointers.glGetClipPlane(plane, equation);
        }
        
        /// <summary>
        /// return the coefficients of the specified clipping plane
        /// <para>
        /// glGetClipPlane returns in equation the four coefficients of the plane equation for plane
        /// </para>
        /// </summary>
        /// <param name="plane">
        /// Specifies a clipping plane. The number of clipping planes depends on the implementation, but at
        /// least six clipping planes are supported. They are identified by symbolic names of the form
        /// GL_CLIP_PLANE i where i ranges from 0 to the value of GL_MAX_CLIP_PLANES - 1.
        /// </param>
        /// <param name="equation">
        /// Returns four double-precision values that are the coefficients of the plane equation of plane in eye
        /// coordinates. The initial value is (0, 0, 0, 0).
        /// </param>
        public static void glGetClipPlane(int plane, double[] equation) {
            fixed(double* equation_ = &equation[0])
                Pointers.glGetClipPlane(plane, equation_);
        }
        
        public static void glGetClipPlanef(int plane, float* equation) {
            Pointers.glGetClipPlanef(plane, equation);
        }
        
        public static void glGetClipPlanef(int plane, float[] equation) {
            fixed(float* equation_ = &equation[0])
                Pointers.glGetClipPlanef(plane, equation_);
        }
        
        public static void glGetClipPlanefOES(int plane, float* equation) {
            Pointers.glGetClipPlanefOES(plane, equation);
        }
        
        public static void glGetClipPlanefOES(int plane, float[] equation) {
            fixed(float* equation_ = &equation[0])
                Pointers.glGetClipPlanefOES(plane, equation_);
        }
        
        public static void glGetClipPlanex(int plane, IntPtr* equation) {
            Pointers.glGetClipPlanex(plane, equation);
        }
        
        public static void glGetClipPlanex(int plane, IntPtr[] equation) {
            fixed(IntPtr* equation_ = &equation[0])
                Pointers.glGetClipPlanex(plane, equation_);
        }
        
        public static void glGetClipPlanexOES(int plane, IntPtr* equation) {
            Pointers.glGetClipPlanexOES(plane, equation);
        }
        
        public static void glGetClipPlanexOES(int plane, IntPtr[] equation) {
            fixed(IntPtr* equation_ = &equation[0])
                Pointers.glGetClipPlanexOES(plane, equation_);
        }
        
        /// <summary>
        /// retrieve contents of a color lookup table
        /// <para>
        /// glGetColorTable returns in table the contents of the color table specified by target. No pixel
        /// transfer operations are performed, but pixel storage modes that are applicable to glReadPixels are
        /// performed
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="table">
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        public static void glGetColorTable(int target, int format, int type, IntPtr table) {
            Pointers.glGetColorTable(target, format, type, table);
        }
        
        /// <summary>
        /// retrieve contents of a color lookup table
        /// <para>
        /// glGetColorTable returns in table the contents of the color table specified by target. No pixel
        /// transfer operations are performed, but pixel storage modes that are applicable to glReadPixels are
        /// performed
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE, or GL_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in table. The possible values are GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, GL_BGR, GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="data">
        /// The type of the pixel data in table. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE, GL_BITMAP,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        public static void glGetColorTableEXT(int target, int format, int type, IntPtr data) {
            Pointers.glGetColorTableEXT(target, format, type, data);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameterfv(int target, int pname, float* _params) {
            Pointers.glGetColorTableParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetColorTableParameterfv(target, pname, _params_);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameterfvEXT(int target, int pname, float* _params) {
            Pointers.glGetColorTableParameterfvEXT(target, pname, _params);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameterfvEXT(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetColorTableParameterfvEXT(target, pname, _params_);
        }
        
        public static void glGetColorTableParameterfvSGI(int target, int pname, float* _params) {
            Pointers.glGetColorTableParameterfvSGI(target, pname, _params);
        }
        
        public static void glGetColorTableParameterfvSGI(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetColorTableParameterfvSGI(target, pname, _params_);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameteriv(int target, int pname, int* _params) {
            Pointers.glGetColorTableParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetColorTableParameteriv(target, pname, _params_);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameterivEXT(int target, int pname, int* _params) {
            Pointers.glGetColorTableParameterivEXT(target, pname, _params);
        }
        
        /// <summary>
        /// get color lookup table parameters
        /// <para>
        /// Returns parameters specific to color table target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The target color table. Must be GL_COLOR_TABLE, GL_POST_CONVOLUTION_COLOR_TABLE,
        /// GL_POST_COLOR_MATRIX_COLOR_TABLE, GL_PROXY_COLOR_TABLE, GL_PROXY_POST_CONVOLUTION_COLOR_TABLE, or
        /// GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE.
        /// </param>
        /// <param name="pname">
        /// The symbolic name of a color lookup table parameter. Must be one of GL_COLOR_TABLE_BIAS,
        /// GL_COLOR_TABLE_SCALE, GL_COLOR_TABLE_FORMAT, GL_COLOR_TABLE_WIDTH, GL_COLOR_TABLE_RED_SIZE,
        /// GL_COLOR_TABLE_GREEN_SIZE, GL_COLOR_TABLE_BLUE_SIZE, GL_COLOR_TABLE_ALPHA_SIZE,
        /// GL_COLOR_TABLE_LUMINANCE_SIZE, or GL_COLOR_TABLE_INTENSITY_SIZE.
        /// </param>
        /// <param name="_params">
        /// A pointer to an array where the values of the parameter will be stored.
        /// </param>
        public static void glGetColorTableParameterivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetColorTableParameterivEXT(target, pname, _params_);
        }
        
        public static void glGetColorTableParameterivSGI(int target, int pname, int* _params) {
            Pointers.glGetColorTableParameterivSGI(target, pname, _params);
        }
        
        public static void glGetColorTableParameterivSGI(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetColorTableParameterivSGI(target, pname, _params_);
        }
        
        public static void glGetColorTableSGI(int target, int format, int type, IntPtr table) {
            Pointers.glGetColorTableSGI(target, format, type, table);
        }
        
        public static void glGetCombinerInputParameterfvNV(int stage, int portion, int variable, int pname, float* _params) {
            Pointers.glGetCombinerInputParameterfvNV(stage, portion, variable, pname, _params);
        }
        
        public static void glGetCombinerInputParameterfvNV(int stage, int portion, int variable, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetCombinerInputParameterfvNV(stage, portion, variable, pname, _params_);
        }
        
        public static void glGetCombinerInputParameterivNV(int stage, int portion, int variable, int pname, int* _params) {
            Pointers.glGetCombinerInputParameterivNV(stage, portion, variable, pname, _params);
        }
        
        public static void glGetCombinerInputParameterivNV(int stage, int portion, int variable, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetCombinerInputParameterivNV(stage, portion, variable, pname, _params_);
        }
        
        public static void glGetCombinerOutputParameterfvNV(int stage, int portion, int pname, float* _params) {
            Pointers.glGetCombinerOutputParameterfvNV(stage, portion, pname, _params);
        }
        
        public static void glGetCombinerOutputParameterfvNV(int stage, int portion, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetCombinerOutputParameterfvNV(stage, portion, pname, _params_);
        }
        
        public static void glGetCombinerOutputParameterivNV(int stage, int portion, int pname, int* _params) {
            Pointers.glGetCombinerOutputParameterivNV(stage, portion, pname, _params);
        }
        
        public static void glGetCombinerOutputParameterivNV(int stage, int portion, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetCombinerOutputParameterivNV(stage, portion, pname, _params_);
        }
        
        public static void glGetCombinerStageParameterfvNV(int stage, int pname, float* _params) {
            Pointers.glGetCombinerStageParameterfvNV(stage, pname, _params);
        }
        
        public static void glGetCombinerStageParameterfvNV(int stage, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetCombinerStageParameterfvNV(stage, pname, _params_);
        }
        
        public static uint glGetCommandHeaderNV(int tokenID, uint size) {
            return Pointers.glGetCommandHeaderNV(tokenID, size);
        }
        
        public static void glGetCompressedMultiTexImageEXT(int texunit, int target, int lod, IntPtr img) {
            Pointers.glGetCompressedMultiTexImageEXT(texunit, target, lod, img);
        }
        
        /// <summary>
        /// return a compressed texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glGetCompressedTexImage and
        /// glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D,
        /// GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are
        /// accepted.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level
        /// $n$ is the $n$-th mipmap reduction image.
        /// </param>
        /// <param name="img">
        /// Returns the compressed texture image.
        /// </param>
        public static void glGetCompressedTexImage(int target, int level, IntPtr img) {
            Pointers.glGetCompressedTexImage(target, level, img);
        }
        
        /// <summary>
        /// return a compressed texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glGetCompressedTexImage and
        /// glGetnCompressedTexImage functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D,
        /// GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Z, and GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_TEXTURE_RECTANGLE are
        /// accepted.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level
        /// $n$ is the $n$-th mipmap reduction image.
        /// </param>
        /// <param name="img">
        /// Returns the compressed texture image.
        /// </param>
        public static void glGetCompressedTexImageARB(int target, int level, IntPtr img) {
            Pointers.glGetCompressedTexImageARB(target, level, img);
        }
        
        public static void glGetCompressedTextureImage(uint texture, int level, int bufSize, IntPtr pixels) {
            Pointers.glGetCompressedTextureImage(texture, level, bufSize, pixels);
        }
        
        public static void glGetCompressedTextureImageEXT(uint texture, int target, int lod, IntPtr img) {
            Pointers.glGetCompressedTextureImageEXT(texture, target, lod, img);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="texture">
        /// Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
        /// GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or
        /// GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage. Must be a multiple of the compressed block's width,
        /// unless the offset is zero and the size equals the texture image size.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage. Must be a multiple of the compressed block's height,
        /// unless the offset is zero and the size equals the texture image size.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage. Must be a multiple of the compressed block's depth,
        /// unless the offset is zero and the size equals the texture image size.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer to receive the retrieved pixel data.
        /// </param>
        /// <param name="pixels">
        /// Returns the texture subimage. Should be a pointer to an array of the type specified by type.
        /// </param>
        public static void glGetCompressedTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int bufSize, IntPtr pixels) {
            Pointers.glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
        }
        
        /// <summary>
        /// get current 1D or 2D convolution filter kernel
        /// <para>
        /// glGetConvolutionFilter returns the current 1D or 2D convolution filter kernel as an image. The one-
        /// or two-dimensional image is placed in image according to the specifications in format and type. No
        /// pixel transfer operations are performed on this image, but the relevant pixel storage modes are
        /// applied
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The filter to be retrieved. Must be one of GL_CONVOLUTION_1D or GL_CONVOLUTION_2D.
        /// </param>
        /// <param name="format">
        /// Format of the output image. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR,
        /// GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// Data type of components in the output image. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="image">
        /// Pointer to storage for the output image.
        /// </param>
        public static void glGetConvolutionFilter(int target, int format, int type, IntPtr image) {
            Pointers.glGetConvolutionFilter(target, format, type, image);
        }
        
        public static void glGetConvolutionFilterEXT(int target, int format, int type, IntPtr image) {
            Pointers.glGetConvolutionFilterEXT(target, format, type, image);
        }
        
        /// <summary>
        /// get convolution parameters
        /// <para>
        /// glGetConvolutionParameter retrieves convolution parameters. target determines which convolution
        /// filter is queried. pname determines which parameter is returned:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D,
        /// GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE,
        /// GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS,
        /// GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or
        /// GL_MAX_CONVOLUTION_HEIGHT.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        public static void glGetConvolutionParameterfv(int target, int pname, float* _params) {
            Pointers.glGetConvolutionParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// get convolution parameters
        /// <para>
        /// glGetConvolutionParameter retrieves convolution parameters. target determines which convolution
        /// filter is queried. pname determines which parameter is returned:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D,
        /// GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE,
        /// GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS,
        /// GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or
        /// GL_MAX_CONVOLUTION_HEIGHT.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        public static void glGetConvolutionParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetConvolutionParameterfv(target, pname, _params_);
        }
        
        public static void glGetConvolutionParameterfvEXT(int target, int pname, float* _params) {
            Pointers.glGetConvolutionParameterfvEXT(target, pname, _params);
        }
        
        public static void glGetConvolutionParameterfvEXT(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetConvolutionParameterfvEXT(target, pname, _params_);
        }
        
        /// <summary>
        /// get convolution parameters
        /// <para>
        /// glGetConvolutionParameter retrieves convolution parameters. target determines which convolution
        /// filter is queried. pname determines which parameter is returned:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D,
        /// GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE,
        /// GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS,
        /// GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or
        /// GL_MAX_CONVOLUTION_HEIGHT.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        public static void glGetConvolutionParameteriv(int target, int pname, int* _params) {
            Pointers.glGetConvolutionParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// get convolution parameters
        /// <para>
        /// glGetConvolutionParameter retrieves convolution parameters. target determines which convolution
        /// filter is queried. pname determines which parameter is returned:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The filter whose parameters are to be retrieved. Must be one of GL_CONVOLUTION_1D,
        /// GL_CONVOLUTION_2D, or GL_SEPARABLE_2D.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_CONVOLUTION_BORDER_MODE,
        /// GL_CONVOLUTION_BORDER_COLOR, GL_CONVOLUTION_FILTER_SCALE, GL_CONVOLUTION_FILTER_BIAS,
        /// GL_CONVOLUTION_FORMAT, GL_CONVOLUTION_WIDTH, GL_CONVOLUTION_HEIGHT, GL_MAX_CONVOLUTION_WIDTH, or
        /// GL_MAX_CONVOLUTION_HEIGHT.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the parameters to be retrieved.
        /// </param>
        public static void glGetConvolutionParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetConvolutionParameteriv(target, pname, _params_);
        }
        
        public static void glGetConvolutionParameterivEXT(int target, int pname, int* _params) {
            Pointers.glGetConvolutionParameterivEXT(target, pname, _params);
        }
        
        public static void glGetConvolutionParameterivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetConvolutionParameterivEXT(target, pname, _params_);
        }
        
        public static void glGetConvolutionParameterxvOES(int target, int pname, IntPtr* _params) {
            Pointers.glGetConvolutionParameterxvOES(target, pname, _params);
        }
        
        public static void glGetConvolutionParameterxvOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetConvolutionParameterxvOES(target, pname, _params_);
        }
        
        public static void glGetCoverageModulationTableNV(int bufsize, float* v) {
            Pointers.glGetCoverageModulationTableNV(bufsize, v);
        }
        
        public static void glGetCoverageModulationTableNV(int bufsize, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glGetCoverageModulationTableNV(bufsize, v_);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int* types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int* sources, int[] types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources, types_, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int* types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLog(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLog(count, bufSize, sources_, types_, ids_, severities_, lengths_, messageLog);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint* severities, uint* ids, int* lengths, StringBuilder message) {
            return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint* severities, uint* ids, int[] lengths, StringBuilder message) {
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids, lengths_, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint* severities, uint[] ids, int* lengths, StringBuilder message) {
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids_, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint* severities, uint[] ids, int[] lengths, StringBuilder message) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities, ids_, lengths_, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint[] severities, uint* ids, int* lengths, StringBuilder message) {
            fixed(uint* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities_, ids, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint[] severities, uint* ids, int[] lengths, StringBuilder message) {
            fixed(uint* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities_, ids, lengths_, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint[] severities, uint[] ids, int* lengths, StringBuilder message) {
            fixed(uint* severities_ = &severities[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities_, ids_, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int* categories, uint[] severities, uint[] ids, int[] lengths, StringBuilder message) {
            fixed(uint* severities_ = &severities[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories, severities_, ids_, lengths_, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint* severities, uint* ids, int* lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities, ids, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint* severities, uint* ids, int[] lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities, ids, lengths_, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint* severities, uint[] ids, int* lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities, ids_, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint* severities, uint[] ids, int[] lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities, ids_, lengths_, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint[] severities, uint* ids, int* lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
            fixed(uint* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities_, ids, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint[] severities, uint* ids, int[] lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
            fixed(uint* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities_, ids, lengths_, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint[] severities, uint[] ids, int* lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
            fixed(uint* severities_ = &severities[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities_, ids_, lengths, message);
        }
        
        public static uint glGetDebugMessageLogAMD(uint count, int bufsize, int[] categories, uint[] severities, uint[] ids, int[] lengths, StringBuilder message) {
            fixed(int* categories_ = &categories[0])
            fixed(uint* severities_ = &severities[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogAMD(count, bufsize, categories_, severities_, ids_, lengths_, message);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int* types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int* sources, int[] types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources, types_, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int* types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogARB(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogARB(count, bufSize, sources_, types_, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int* types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int* sources, int[] types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources, types_, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int* types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types, ids_, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint* ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint* ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint* ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint* ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids, severities_, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int* severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids_, severities, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int* severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids_, severities, lengths_, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int[] severities, int* lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids_, severities_, lengths, messageLog);
        }
        
        /// <summary>
        /// retrieve messages from the debug message log
        /// <para>
        /// glGetDebugMessageLog retrieves messages from the debug message log. A maximum of count messages are
        /// retrieved from the log. If sources is not NULL then the source of each message is written into up to
        /// count elements of the array. If types is not NULL then the type of each message is written into up
        /// to count elements of the array. If id is not NULL then the identifier of each message is written
        /// into up to count elements of the array. If severities is not NULL then the severity of each message
        /// is written into up to count elements of the array. If lengths is not NULL then the length of each
        /// message is written into up to count elements of the array
        /// </para>
        /// </summary>
        /// <param name="count">
        /// The number of debug messages to retrieve from the log.
        /// </param>
        /// <param name="bufSize">
        /// The size of the buffer whose address is given by messageLog.
        /// </param>
        /// <param name="sources">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        /// <param name="types">
        /// The address of an array of variables to receive the types of the retrieved messages.
        /// </param>
        /// <param name="ids">
        /// The address of an array of unsigned integers to receive the ids of the retrieved messages.
        /// </param>
        /// <param name="severities">
        /// The address of an array of variables to receive the severites of the retrieved messages.
        /// </param>
        /// <param name="lengths">
        /// The address of an array of variables to receive the lengths of the received messages.
        /// </param>
        /// <param name="messageLog">
        /// The address of an array of variables to receive the sources of the retrieved messages.
        /// </param>
        public static uint glGetDebugMessageLogKHR(uint count, int bufSize, int[] sources, int[] types, uint[] ids, int[] severities, int[] lengths, StringBuilder messageLog) {
            fixed(int* sources_ = &sources[0])
            fixed(int* types_ = &types[0])
            fixed(uint* ids_ = &ids[0])
            fixed(int* severities_ = &severities[0])
            fixed(int* lengths_ = &lengths[0])
                return Pointers.glGetDebugMessageLogKHR(count, bufSize, sources_, types_, ids_, severities_, lengths_, messageLog);
        }
        
        public static void glGetDetailTexFuncSGIS(int target, float* points) {
            Pointers.glGetDetailTexFuncSGIS(target, points);
        }
        
        public static void glGetDetailTexFuncSGIS(int target, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glGetDetailTexFuncSGIS(target, points_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoubleIndexedvEXT(int target, uint index, double* data) {
            Pointers.glGetDoubleIndexedvEXT(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoubleIndexedvEXT(int target, uint index, double[] data) {
            fixed(double* data_ = &data[0])
                Pointers.glGetDoubleIndexedvEXT(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoublei_v(int target, uint index, double* data) {
            Pointers.glGetDoublei_v(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoublei_v(int target, uint index, double[] data) {
            fixed(double* data_ = &data[0])
                Pointers.glGetDoublei_v(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoublei_vEXT(int pname, uint index, double* _params) {
            Pointers.glGetDoublei_vEXT(pname, index, _params);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoublei_vEXT(int pname, uint index, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetDoublei_vEXT(pname, index, _params_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoublev(int pname, double* data) {
            Pointers.glGetDoublev(pname, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetDoublev(int pname, double[] data) {
            fixed(double* data_ = &data[0])
                Pointers.glGetDoublev(pname, data_);
        }
        
        public static double glGetDoublev(int pname) {
            double data;
            glGetDoublev(pname, &data);
            return data;
        }
        
        public static void glGetDriverControlStringQCOM(uint driverControl, int bufSize, int* length, StringBuilder driverControlString) {
            Pointers.glGetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
        }
        
        public static void glGetDriverControlStringQCOM(uint driverControl, int bufSize, int[] length, StringBuilder driverControlString) {
            fixed(int* length_ = &length[0])
                Pointers.glGetDriverControlStringQCOM(driverControl, bufSize, length_, driverControlString);
        }
        
        public static void glGetDriverControlsQCOM(int* num, int size, uint* driverControls) {
            Pointers.glGetDriverControlsQCOM(num, size, driverControls);
        }
        
        public static void glGetDriverControlsQCOM(int* num, int size, uint[] driverControls) {
            fixed(uint* driverControls_ = &driverControls[0])
                Pointers.glGetDriverControlsQCOM(num, size, driverControls_);
        }
        
        public static void glGetDriverControlsQCOM(int[] num, int size, uint* driverControls) {
            fixed(int* num_ = &num[0])
                Pointers.glGetDriverControlsQCOM(num_, size, driverControls);
        }
        
        public static void glGetDriverControlsQCOM(int[] num, int size, uint[] driverControls) {
            fixed(int* num_ = &num[0])
            fixed(uint* driverControls_ = &driverControls[0])
                Pointers.glGetDriverControlsQCOM(num_, size, driverControls_);
        }
        
        /// <summary>
        /// return error information
        /// <para>
        /// glGetError returns the value of the error flag. Each detectable error is assigned a numeric code and
        /// symbolic name. When an error occurs, the error flag is set to the appropriate error code value. No
        /// other errors are recorded until glGetError is called, the error code is returned, and the flag is
        /// reset to GL_NO_ERROR. If a call to glGetError returns GL_NO_ERROR, there has been no detectable
        /// error since the last call to glGetError, or since the GL was initialized
        /// </para>
        /// </summary>
        public static int glGetError() {
            return Pointers.glGetError();
        }
        
        public static void glGetFenceivNV(uint fence, int pname, int* _params) {
            Pointers.glGetFenceivNV(fence, pname, _params);
        }
        
        public static void glGetFenceivNV(uint fence, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFenceivNV(fence, pname, _params_);
        }
        
        public static void glGetFinalCombinerInputParameterfvNV(int variable, int pname, float* _params) {
            Pointers.glGetFinalCombinerInputParameterfvNV(variable, pname, _params);
        }
        
        public static void glGetFinalCombinerInputParameterfvNV(int variable, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetFinalCombinerInputParameterfvNV(variable, pname, _params_);
        }
        
        public static void glGetFinalCombinerInputParameterivNV(int variable, int pname, int* _params) {
            Pointers.glGetFinalCombinerInputParameterivNV(variable, pname, _params);
        }
        
        public static void glGetFinalCombinerInputParameterivNV(int variable, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFinalCombinerInputParameterivNV(variable, pname, _params_);
        }
        
        public static void glGetFirstPerfQueryIdINTEL(uint* queryId) {
            Pointers.glGetFirstPerfQueryIdINTEL(queryId);
        }
        
        public static void glGetFirstPerfQueryIdINTEL(uint[] queryId) {
            fixed(uint* queryId_ = &queryId[0])
                Pointers.glGetFirstPerfQueryIdINTEL(queryId_);
        }
        
        public static void glGetFixedv(int pname, IntPtr* _params) {
            Pointers.glGetFixedv(pname, _params);
        }
        
        public static void glGetFixedv(int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetFixedv(pname, _params_);
        }
        
        public static void glGetFixedvOES(int pname, IntPtr* _params) {
            Pointers.glGetFixedvOES(pname, _params);
        }
        
        public static void glGetFixedvOES(int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetFixedvOES(pname, _params_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloatIndexedvEXT(int target, uint index, float* data) {
            Pointers.glGetFloatIndexedvEXT(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloatIndexedvEXT(int target, uint index, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetFloatIndexedvEXT(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_v(int target, uint index, float* data) {
            Pointers.glGetFloati_v(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_v(int target, uint index, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetFloati_v(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_vEXT(int pname, uint index, float* _params) {
            Pointers.glGetFloati_vEXT(pname, index, _params);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_vEXT(int pname, uint index, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetFloati_vEXT(pname, index, _params_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_vNV(int target, uint index, float* data) {
            Pointers.glGetFloati_vNV(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_vNV(int target, uint index, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetFloati_vNV(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_vOES(int target, uint index, float* data) {
            Pointers.glGetFloati_vOES(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloati_vOES(int target, uint index, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetFloati_vOES(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloatv(int pname, float* data) {
            Pointers.glGetFloatv(pname, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetFloatv(int pname, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetFloatv(pname, data_);
        }
        
        public static float glGetFloatv(int pname) {
            float data;
            glGetFloatv(pname, &data);
            return data;
        }
        
        public static void glGetFogFuncSGIS(float* points) {
            Pointers.glGetFogFuncSGIS(points);
        }
        
        public static void glGetFogFuncSGIS(float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glGetFogFuncSGIS(points_);
        }
        
        /// <summary>
        /// query the bindings of color indices to user-defined varying out variables
        /// <para>
        /// glGetFragDataIndex returns the index of the fragment color to which the variable name was bound when
        /// the program object program was last linked. If name is not a varying out variable of program, or if
        /// an error occurs, -1 will be returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to query
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose index to query
        /// </param>
        public static int glGetFragDataIndex(uint program, string name) {
            return Pointers.glGetFragDataIndex(program, name);
        }
        
        /// <summary>
        /// query the bindings of color indices to user-defined varying out variables
        /// <para>
        /// glGetFragDataIndex returns the index of the fragment color to which the variable name was bound when
        /// the program object program was last linked. If name is not a varying out variable of program, or if
        /// an error occurs, -1 will be returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to query
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose index to query
        /// </param>
        public static int glGetFragDataIndexEXT(uint program, string name) {
            return Pointers.glGetFragDataIndexEXT(program, name);
        }
        
        /// <summary>
        /// query the bindings of color numbers to user-defined varying out variables
        /// <para>
        /// glGetFragDataLocation retrieves the assigned color number binding for the user-defined varying out
        /// variable name for program program. program must have previously been linked. name must be a
        /// null-terminated string. If name is not the name of an active user-defined varying out fragment
        /// shader variable within program, -1 will be returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to query
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose binding to query
        /// </param>
        public static int glGetFragDataLocation(uint program, string name) {
            return Pointers.glGetFragDataLocation(program, name);
        }
        
        /// <summary>
        /// query the bindings of color numbers to user-defined varying out variables
        /// <para>
        /// glGetFragDataLocation retrieves the assigned color number binding for the user-defined varying out
        /// variable name for program program. program must have previously been linked. name must be a
        /// null-terminated string. If name is not the name of an active user-defined varying out fragment
        /// shader variable within program, -1 will be returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing varying out variable whose binding to query
        /// </param>
        /// <param name="name">
        /// The name of the user-defined varying out variable whose binding to query
        /// </param>
        public static int glGetFragDataLocationEXT(uint program, string name) {
            return Pointers.glGetFragDataLocationEXT(program, name);
        }
        
        public static void glGetFragmentLightfvSGIX(int light, int pname, float* _params) {
            Pointers.glGetFragmentLightfvSGIX(light, pname, _params);
        }
        
        public static void glGetFragmentLightfvSGIX(int light, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetFragmentLightfvSGIX(light, pname, _params_);
        }
        
        public static void glGetFragmentLightivSGIX(int light, int pname, int* _params) {
            Pointers.glGetFragmentLightivSGIX(light, pname, _params);
        }
        
        public static void glGetFragmentLightivSGIX(int light, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFragmentLightivSGIX(light, pname, _params_);
        }
        
        public static void glGetFragmentMaterialfvSGIX(int face, int pname, float* _params) {
            Pointers.glGetFragmentMaterialfvSGIX(face, pname, _params);
        }
        
        public static void glGetFragmentMaterialfvSGIX(int face, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetFragmentMaterialfvSGIX(face, pname, _params_);
        }
        
        public static void glGetFragmentMaterialivSGIX(int face, int pname, int* _params) {
            Pointers.glGetFragmentMaterialivSGIX(face, pname, _params);
        }
        
        public static void glGetFragmentMaterialivSGIX(int face, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFragmentMaterialivSGIX(face, pname, _params_);
        }
        
        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>
        /// glGetFramebufferAttachmentParameteriv and glGetNamedFramebufferAttachmentParameteriv return
        /// parameters of attachments of a specified framebuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is bound for
        /// glGetFramebufferAttachmentParameteriv.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment of the framebuffer object to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for attachment.
        /// </param>
        public static void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int* _params) {
            Pointers.glGetFramebufferAttachmentParameteriv(target, attachment, pname, _params);
        }
        
        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>
        /// glGetFramebufferAttachmentParameteriv and glGetNamedFramebufferAttachmentParameteriv return
        /// parameters of attachments of a specified framebuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is bound for
        /// glGetFramebufferAttachmentParameteriv.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment of the framebuffer object to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for attachment.
        /// </param>
        public static void glGetFramebufferAttachmentParameteriv(int target, int attachment, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFramebufferAttachmentParameteriv(target, attachment, pname, _params_);
        }
        
        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>
        /// glGetFramebufferAttachmentParameteriv and glGetNamedFramebufferAttachmentParameteriv return
        /// parameters of attachments of a specified framebuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is bound for
        /// glGetFramebufferAttachmentParameteriv.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment of the framebuffer object to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for attachment.
        /// </param>
        public static void glGetFramebufferAttachmentParameterivEXT(int target, int attachment, int pname, int* _params) {
            Pointers.glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, _params);
        }
        
        /// <summary>
        /// retrieve information about attachments of a framebuffer object
        /// <para>
        /// glGetFramebufferAttachmentParameteriv and glGetNamedFramebufferAttachmentParameteriv return
        /// parameters of attachments of a specified framebuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is bound for
        /// glGetFramebufferAttachmentParameteriv.
        /// </param>
        /// <param name="attachment">
        /// Specifies the attachment of the framebuffer object to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of attachment to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for attachment.
        /// </param>
        public static void glGetFramebufferAttachmentParameterivEXT(int target, int attachment, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFramebufferAttachmentParameterivEXT(target, attachment, pname, _params_);
        }
        
        public static void glGetFramebufferAttachmentParameterivOES(int target, int attachment, int pname, int* _params) {
            Pointers.glGetFramebufferAttachmentParameterivOES(target, attachment, pname, _params);
        }
        
        public static void glGetFramebufferAttachmentParameterivOES(int target, int attachment, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFramebufferAttachmentParameterivOES(target, attachment, pname, _params_);
        }
        
        public static void glGetFramebufferParameterfvAMD(int target, int pname, uint numsamples, uint pixelindex, int size, float* values) {
            Pointers.glGetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values);
        }
        
        public static void glGetFramebufferParameterfvAMD(int target, int pname, uint numsamples, uint pixelindex, int size, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glGetFramebufferParameterfvAMD(target, pname, numsamples, pixelindex, size, values_);
        }
        
        /// <summary>
        /// query a named parameter of a framebuffer object
        /// <para>
        /// glGetFramebufferParameteriv and glGetNamedFramebufferParameteriv query parameters of a specified
        /// framebuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the framebuffer object to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for the framebuffer object.
        /// </param>
        public static void glGetFramebufferParameteriv(int target, int pname, int* _params) {
            Pointers.glGetFramebufferParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// query a named parameter of a framebuffer object
        /// <para>
        /// glGetFramebufferParameteriv and glGetNamedFramebufferParameteriv query parameters of a specified
        /// framebuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is bound for glGetFramebufferParameteriv.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the framebuffer object to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for the framebuffer object.
        /// </param>
        public static void glGetFramebufferParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFramebufferParameteriv(target, pname, _params_);
        }
        
        public static void glGetFramebufferParameterivEXT(uint framebuffer, int pname, int* _params) {
            Pointers.glGetFramebufferParameterivEXT(framebuffer, pname, _params);
        }
        
        public static void glGetFramebufferParameterivEXT(uint framebuffer, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetFramebufferParameterivEXT(framebuffer, pname, _params_);
        }
        
        public static int glGetFramebufferPixelLocalStorageSizeEXT(uint target) {
            return Pointers.glGetFramebufferPixelLocalStorageSizeEXT(target);
        }
        
        /// <summary>
        /// check if the rendering context has not been lost due to software or hardware issues
        /// <para>
        /// Certain events can result in a reset of the GL context. Such a reset causes all context state to be
        /// lost and requires the application to recreate all objects in the affected context
        /// </para>
        /// </summary>
        public static int glGetGraphicsResetStatus() {
            return Pointers.glGetGraphicsResetStatus();
        }
        
        public static int glGetGraphicsResetStatusARB() {
            return Pointers.glGetGraphicsResetStatusARB();
        }
        
        public static int glGetGraphicsResetStatusEXT() {
            return Pointers.glGetGraphicsResetStatusEXT();
        }
        
        /// <summary>
        /// check if the rendering context has not been lost due to software or hardware issues
        /// <para>
        /// Certain events can result in a reset of the GL context. Such a reset causes all context state to be
        /// lost and requires the application to recreate all objects in the affected context
        /// </para>
        /// </summary>
        public static int glGetGraphicsResetStatusKHR() {
            return Pointers.glGetGraphicsResetStatusKHR();
        }
        
        public static uint glGetHandleARB(int pname) {
            return Pointers.glGetHandleARB(pname);
        }
        
        /// <summary>
        /// get histogram table
        /// <para>
        /// glGetHistogram returns the current histogram table as a one-dimensional image with the same width as
        /// the histogram. No pixel transfer operations are performed on this image, but pixel storage modes
        /// that are applicable to 1D images are honored
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_HISTOGRAM.
        /// </param>
        /// <param name="reset">
        /// If GL_TRUE, each component counter that is actually returned is reset to zero. (Other counters are
        /// unaffected.) If GL_FALSE, none of the counters in the histogram table is modified.
        /// </param>
        /// <param name="format">
        /// The format of values to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="values">
        /// The type of values to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        public static void glGetHistogram(int target, bool reset, int format, int type, IntPtr values) {
            Pointers.glGetHistogram(target, reset, format, type, values);
        }
        
        public static void glGetHistogramEXT(int target, bool reset, int format, int type, IntPtr values) {
            Pointers.glGetHistogramEXT(target, reset, format, type, values);
        }
        
        /// <summary>
        /// get histogram parameters
        /// <para>
        /// glGetHistogramParameter is used to query parameter values for the current histogram or for a proxy.
        /// The histogram state information may be queried by calling glGetHistogramParameter with a target of
        /// GL_HISTOGRAM (to obtain information for the current histogram table) or GL_PROXY_HISTOGRAM (to
        /// obtain information from the most recent proxy request) and one of the following values for the pname
        /// argument:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT,
        /// GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE,
        /// GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the returned values.
        /// </param>
        public static void glGetHistogramParameterfv(int target, int pname, float* _params) {
            Pointers.glGetHistogramParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// get histogram parameters
        /// <para>
        /// glGetHistogramParameter is used to query parameter values for the current histogram or for a proxy.
        /// The histogram state information may be queried by calling glGetHistogramParameter with a target of
        /// GL_HISTOGRAM (to obtain information for the current histogram table) or GL_PROXY_HISTOGRAM (to
        /// obtain information from the most recent proxy request) and one of the following values for the pname
        /// argument:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT,
        /// GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE,
        /// GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the returned values.
        /// </param>
        public static void glGetHistogramParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetHistogramParameterfv(target, pname, _params_);
        }
        
        public static void glGetHistogramParameterfvEXT(int target, int pname, float* _params) {
            Pointers.glGetHistogramParameterfvEXT(target, pname, _params);
        }
        
        public static void glGetHistogramParameterfvEXT(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetHistogramParameterfvEXT(target, pname, _params_);
        }
        
        /// <summary>
        /// get histogram parameters
        /// <para>
        /// glGetHistogramParameter is used to query parameter values for the current histogram or for a proxy.
        /// The histogram state information may be queried by calling glGetHistogramParameter with a target of
        /// GL_HISTOGRAM (to obtain information for the current histogram table) or GL_PROXY_HISTOGRAM (to
        /// obtain information from the most recent proxy request) and one of the following values for the pname
        /// argument:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT,
        /// GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE,
        /// GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the returned values.
        /// </param>
        public static void glGetHistogramParameteriv(int target, int pname, int* _params) {
            Pointers.glGetHistogramParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// get histogram parameters
        /// <para>
        /// glGetHistogramParameter is used to query parameter values for the current histogram or for a proxy.
        /// The histogram state information may be queried by calling glGetHistogramParameter with a target of
        /// GL_HISTOGRAM (to obtain information for the current histogram table) or GL_PROXY_HISTOGRAM (to
        /// obtain information from the most recent proxy request) and one of the following values for the pname
        /// argument:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter to be retrieved. Must be one of GL_HISTOGRAM_WIDTH, GL_HISTOGRAM_FORMAT,
        /// GL_HISTOGRAM_RED_SIZE, GL_HISTOGRAM_GREEN_SIZE, GL_HISTOGRAM_BLUE_SIZE, GL_HISTOGRAM_ALPHA_SIZE,
        /// GL_HISTOGRAM_LUMINANCE_SIZE, or GL_HISTOGRAM_SINK.
        /// </param>
        /// <param name="_params">
        /// Pointer to storage for the returned values.
        /// </param>
        public static void glGetHistogramParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetHistogramParameteriv(target, pname, _params_);
        }
        
        public static void glGetHistogramParameterivEXT(int target, int pname, int* _params) {
            Pointers.glGetHistogramParameterivEXT(target, pname, _params);
        }
        
        public static void glGetHistogramParameterivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetHistogramParameterivEXT(target, pname, _params_);
        }
        
        public static void glGetHistogramParameterxvOES(int target, int pname, IntPtr* _params) {
            Pointers.glGetHistogramParameterxvOES(target, pname, _params);
        }
        
        public static void glGetHistogramParameterxvOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetHistogramParameterxvOES(target, pname, _params_);
        }
        
        public static ulong glGetImageHandleARB(uint texture, int level, bool layered, int layer, int format) {
            return Pointers.glGetImageHandleARB(texture, level, layered, layer, format);
        }
        
        public static ulong glGetImageHandleNV(uint texture, int level, bool layered, int layer, int format) {
            return Pointers.glGetImageHandleNV(texture, level, layered, layer, format);
        }
        
        public static void glGetImageTransformParameterfvHP(int target, int pname, float* _params) {
            Pointers.glGetImageTransformParameterfvHP(target, pname, _params);
        }
        
        public static void glGetImageTransformParameterfvHP(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetImageTransformParameterfvHP(target, pname, _params_);
        }
        
        public static void glGetImageTransformParameterivHP(int target, int pname, int* _params) {
            Pointers.glGetImageTransformParameterivHP(target, pname, _params);
        }
        
        public static void glGetImageTransformParameterivHP(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetImageTransformParameterivHP(target, pname, _params_);
        }
        
        public static void glGetInfoLogARB(uint obj, int maxLength, int* length, StringBuilder infoLog) {
            Pointers.glGetInfoLogARB(obj, maxLength, length, infoLog);
        }
        
        public static void glGetInfoLogARB(uint obj, int maxLength, out int length, StringBuilder infoLog) {
            fixed(int* length_ = &length)
                Pointers.glGetInfoLogARB(obj, maxLength, length_, infoLog);
        }
        
        public static int glGetInstrumentsSGIX() {
            return Pointers.glGetInstrumentsSGIX();
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetInteger64i_v(int target, uint index, long* data) {
            Pointers.glGetInteger64i_v(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetInteger64i_v(int target, uint index, long[] data) {
            fixed(long* data_ = &data[0])
                Pointers.glGetInteger64i_v(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetInteger64v(int pname, long* data) {
            Pointers.glGetInteger64v(pname, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetInteger64v(int pname, long[] data) {
            fixed(long* data_ = &data[0])
                Pointers.glGetInteger64v(pname, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetInteger64vAPPLE(int pname, long* _params) {
            Pointers.glGetInteger64vAPPLE(pname, _params);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetInteger64vAPPLE(int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetInteger64vAPPLE(pname, _params_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetIntegerIndexedvEXT(int target, uint index, int* data) {
            Pointers.glGetIntegerIndexedvEXT(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetIntegerIndexedvEXT(int target, uint index, int[] data) {
            fixed(int* data_ = &data[0])
                Pointers.glGetIntegerIndexedvEXT(target, index, data_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetIntegeri_v(int target, uint index, int* data) {
            Pointers.glGetIntegeri_v(target, index, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the parameter value to be returned for indexed versions of glGet. The symbolic constants
        /// in the list below are accepted.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the particular element being queried.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetIntegeri_v(int target, uint index, int[] data) {
            fixed(int* data_ = &data[0])
                Pointers.glGetIntegeri_v(target, index, data_);
        }
        
        public static void glGetIntegeri_vEXT(int target, uint index, int* data) {
            Pointers.glGetIntegeri_vEXT(target, index, data);
        }
        
        public static void glGetIntegeri_vEXT(int target, uint index, int[] data) {
            fixed(int* data_ = &data[0])
                Pointers.glGetIntegeri_vEXT(target, index, data_);
        }
        
        public static void glGetIntegerui64i_vNV(int value, uint index, ulong* result) {
            Pointers.glGetIntegerui64i_vNV(value, index, result);
        }
        
        public static void glGetIntegerui64i_vNV(int value, uint index, ulong[] result) {
            fixed(ulong* result_ = &result[0])
                Pointers.glGetIntegerui64i_vNV(value, index, result_);
        }
        
        public static void glGetIntegerui64vNV(int value, ulong* result) {
            Pointers.glGetIntegerui64vNV(value, result);
        }
        
        public static void glGetIntegerui64vNV(int value, ulong[] result) {
            fixed(ulong* result_ = &result[0])
                Pointers.glGetIntegerui64vNV(value, result_);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetIntegerv(int pname, int* data) {
            Pointers.glGetIntegerv(pname, data);
        }
        
        /// <summary>
        /// return the value or values of a selected parameter
        /// <para>
        /// These commands return values for simple state variables in GL. pname is a symbolic constant
        /// indicating the state variable to be returned, and data is a pointer to an array of the indicated
        /// type in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the parameter value to be returned for non-indexed versions of glGet. The symbolic
        /// constants in the list below are accepted.
        /// </param>
        /// <param name="data">
        /// Returns the value or values of the specified parameter.
        /// </param>
        public static void glGetIntegerv(int pname, int[] data) {
            fixed(int* data_ = &data[0])
                Pointers.glGetIntegerv(pname, data_);
        }
        
        public static int glGetIntegerv(int pname) {
            int data;
            glGetIntegerv(pname, &data);
            return data;
        }
        
        public static void glGetInternalformatSampleivNV(int target, int internalformat, int samples, int pname, int bufSize, int* _params) {
            Pointers.glGetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, _params);
        }
        
        public static void glGetInternalformatSampleivNV(int target, int internalformat, int samples, int pname, int bufSize, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetInternalformatSampleivNV(target, internalformat, samples, pname, bufSize, _params_);
        }
        
        public static void glGetInternalformati64v(int target, int internalformat, int pname, int bufSize, long* _params) {
            Pointers.glGetInternalformati64v(target, internalformat, pname, bufSize, _params);
        }
        
        public static void glGetInternalformati64v(int target, int internalformat, int pname, int bufSize, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetInternalformati64v(target, internalformat, pname, bufSize, _params_);
        }
        
        /// <summary>
        /// retrieve information about implementation-dependent support for internal formats
        /// <para>
        /// glGetInternalformativ and glGetInternalformati64v retrieve information about
        /// implementation-dependent support for internal formats. target indicates the target with which the
        /// internal format will be used and must be one of GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE, or
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY, corresponding to usage as a renderbuffer, two-dimensional
        /// multisample texture or two-dimensional multisample array texture, respectively
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
        /// GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY,
        /// GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format about which to retrieve information.
        /// </param>
        /// <param name="pname">
        /// Specifies the type of information to query.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of integers of the specified width that may be written to params by the
        /// function.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </param>
        public static void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, int* _params) {
            Pointers.glGetInternalformativ(target, internalformat, pname, bufSize, _params);
        }
        
        /// <summary>
        /// retrieve information about implementation-dependent support for internal formats
        /// <para>
        /// glGetInternalformativ and glGetInternalformati64v retrieve information about
        /// implementation-dependent support for internal formats. target indicates the target with which the
        /// internal format will be used and must be one of GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE, or
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY, corresponding to usage as a renderbuffer, two-dimensional
        /// multisample texture or two-dimensional multisample array texture, respectively
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Indicates the usage of the internal format. target must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
        /// GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY,
        /// GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_RENDERBUFFER, GL_TEXTURE_2D_MULTISAMPLE or
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format about which to retrieve information.
        /// </param>
        /// <param name="pname">
        /// Specifies the type of information to query.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of integers of the specified width that may be written to params by the
        /// function.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable into which to write the retrieved information.
        /// </param>
        public static void glGetInternalformativ(int target, int internalformat, int pname, int bufSize, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetInternalformativ(target, internalformat, pname, bufSize, _params_);
        }
        
        public static void glGetInvariantBooleanvEXT(uint id, int value, bool* data) {
            Pointers.glGetInvariantBooleanvEXT(id, value, data);
        }
        
        public static void glGetInvariantBooleanvEXT(uint id, int value, bool[] data) {
            fixed(bool* data_ = &data[0])
                Pointers.glGetInvariantBooleanvEXT(id, value, data_);
        }
        
        public static void glGetInvariantFloatvEXT(uint id, int value, float* data) {
            Pointers.glGetInvariantFloatvEXT(id, value, data);
        }
        
        public static void glGetInvariantFloatvEXT(uint id, int value, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetInvariantFloatvEXT(id, value, data_);
        }
        
        public static void glGetInvariantIntegervEXT(uint id, int value, int* data) {
            Pointers.glGetInvariantIntegervEXT(id, value, data);
        }
        
        public static void glGetInvariantIntegervEXT(uint id, int value, int[] data) {
            fixed(int* data_ = &data[0])
                Pointers.glGetInvariantIntegervEXT(id, value, data_);
        }
        
        /// <summary>
        /// return light source parameter values
        /// <para>
        /// glGetLight returns in params the value or values of a light source parameter. light names the light
        /// and is a symbolic name of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS -
        /// 1. GL_MAX_LIGHTS is an implementation dependent constant that is greater than or equal to eight.
        /// pname specifies one of ten light source parameters, again by symbolic name
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least
        /// eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i
        /// ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE,
        /// GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetLightfv(int light, int pname, float* _params) {
            Pointers.glGetLightfv(light, pname, _params);
        }
        
        /// <summary>
        /// return light source parameter values
        /// <para>
        /// glGetLight returns in params the value or values of a light source parameter. light names the light
        /// and is a symbolic name of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS -
        /// 1. GL_MAX_LIGHTS is an implementation dependent constant that is greater than or equal to eight.
        /// pname specifies one of ten light source parameters, again by symbolic name
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least
        /// eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i
        /// ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE,
        /// GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetLightfv(int light, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetLightfv(light, pname, _params_);
        }
        
        /// <summary>
        /// return light source parameter values
        /// <para>
        /// glGetLight returns in params the value or values of a light source parameter. light names the light
        /// and is a symbolic name of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS -
        /// 1. GL_MAX_LIGHTS is an implementation dependent constant that is greater than or equal to eight.
        /// pname specifies one of ten light source parameters, again by symbolic name
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least
        /// eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i
        /// ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE,
        /// GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetLightiv(int light, int pname, int* _params) {
            Pointers.glGetLightiv(light, pname, _params);
        }
        
        /// <summary>
        /// return light source parameter values
        /// <para>
        /// glGetLight returns in params the value or values of a light source parameter. light names the light
        /// and is a symbolic name of the form GL_LIGHT i where i ranges from 0 to the value of GL_MAX_LIGHTS -
        /// 1. GL_MAX_LIGHTS is an implementation dependent constant that is greater than or equal to eight.
        /// pname specifies one of ten light source parameters, again by symbolic name
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light source. The number of possible lights depends on the implementation, but at least
        /// eight lights are supported. They are identified by symbolic names of the form GL_LIGHT i where i
        /// ranges from 0 to the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a light source parameter for light. Accepted symbolic names are GL_AMBIENT, GL_DIFFUSE,
        /// GL_SPECULAR, GL_POSITION, GL_SPOT_DIRECTION, GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetLightiv(int light, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetLightiv(light, pname, _params_);
        }
        
        public static void glGetLightxOES(int light, int pname, IntPtr* _params) {
            Pointers.glGetLightxOES(light, pname, _params);
        }
        
        public static void glGetLightxOES(int light, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetLightxOES(light, pname, _params_);
        }
        
        public static void glGetLightxv(int light, int pname, IntPtr* _params) {
            Pointers.glGetLightxv(light, pname, _params);
        }
        
        public static void glGetLightxv(int light, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetLightxv(light, pname, _params_);
        }
        
        public static void glGetLightxvOES(int light, int pname, IntPtr* _params) {
            Pointers.glGetLightxvOES(light, pname, _params);
        }
        
        public static void glGetLightxvOES(int light, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetLightxvOES(light, pname, _params_);
        }
        
        public static void glGetListParameterfvSGIX(uint list, int pname, float* _params) {
            Pointers.glGetListParameterfvSGIX(list, pname, _params);
        }
        
        public static void glGetListParameterfvSGIX(uint list, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetListParameterfvSGIX(list, pname, _params_);
        }
        
        public static void glGetListParameterivSGIX(uint list, int pname, int* _params) {
            Pointers.glGetListParameterivSGIX(list, pname, _params);
        }
        
        public static void glGetListParameterivSGIX(uint list, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetListParameterivSGIX(list, pname, _params_);
        }
        
        public static void glGetLocalConstantBooleanvEXT(uint id, int value, bool* data) {
            Pointers.glGetLocalConstantBooleanvEXT(id, value, data);
        }
        
        public static void glGetLocalConstantBooleanvEXT(uint id, int value, bool[] data) {
            fixed(bool* data_ = &data[0])
                Pointers.glGetLocalConstantBooleanvEXT(id, value, data_);
        }
        
        public static void glGetLocalConstantFloatvEXT(uint id, int value, float* data) {
            Pointers.glGetLocalConstantFloatvEXT(id, value, data);
        }
        
        public static void glGetLocalConstantFloatvEXT(uint id, int value, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetLocalConstantFloatvEXT(id, value, data_);
        }
        
        public static void glGetLocalConstantIntegervEXT(uint id, int value, int* data) {
            Pointers.glGetLocalConstantIntegervEXT(id, value, data);
        }
        
        public static void glGetLocalConstantIntegervEXT(uint id, int value, int[] data) {
            fixed(int* data_ = &data[0])
                Pointers.glGetLocalConstantIntegervEXT(id, value, data_);
        }
        
        public static void glGetMapAttribParameterfvNV(int target, uint index, int pname, float* _params) {
            Pointers.glGetMapAttribParameterfvNV(target, index, pname, _params);
        }
        
        public static void glGetMapAttribParameterfvNV(int target, uint index, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMapAttribParameterfvNV(target, index, pname, _params_);
        }
        
        public static void glGetMapAttribParameterivNV(int target, uint index, int pname, int* _params) {
            Pointers.glGetMapAttribParameterivNV(target, index, pname, _params);
        }
        
        public static void glGetMapAttribParameterivNV(int target, uint index, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMapAttribParameterivNV(target, index, pname, _params_);
        }
        
        public static void glGetMapControlPointsNV(int target, uint index, int type, int ustride, int vstride, bool packed, IntPtr points) {
            Pointers.glGetMapControlPointsNV(target, index, type, ustride, vstride, packed, points);
        }
        
        public static void glGetMapParameterfvNV(int target, int pname, float* _params) {
            Pointers.glGetMapParameterfvNV(target, pname, _params);
        }
        
        public static void glGetMapParameterfvNV(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMapParameterfvNV(target, pname, _params_);
        }
        
        public static void glGetMapParameterivNV(int target, int pname, int* _params) {
            Pointers.glGetMapParameterivNV(target, pname, _params);
        }
        
        public static void glGetMapParameterivNV(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMapParameterivNV(target, pname, _params_);
        }
        
        /// <summary>
        /// return evaluator parameters
        /// <para>
        /// glMap1 and glMap2 define evaluators. glGetMap returns evaluator parameters. target chooses a map,
        /// query selects a specific parameter, and v points to storage where the values will be returned
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX,
        /// GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,
        /// GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX,
        /// GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3,
        /// GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </param>
        /// <param name="query">
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        public static void glGetMapdv(int target, int query, double* v) {
            Pointers.glGetMapdv(target, query, v);
        }
        
        /// <summary>
        /// return evaluator parameters
        /// <para>
        /// glMap1 and glMap2 define evaluators. glGetMap returns evaluator parameters. target chooses a map,
        /// query selects a specific parameter, and v points to storage where the values will be returned
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX,
        /// GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,
        /// GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX,
        /// GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3,
        /// GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </param>
        /// <param name="query">
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        public static void glGetMapdv(int target, int query, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glGetMapdv(target, query, v_);
        }
        
        /// <summary>
        /// return evaluator parameters
        /// <para>
        /// glMap1 and glMap2 define evaluators. glGetMap returns evaluator parameters. target chooses a map,
        /// query selects a specific parameter, and v points to storage where the values will be returned
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX,
        /// GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,
        /// GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX,
        /// GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3,
        /// GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </param>
        /// <param name="query">
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        public static void glGetMapfv(int target, int query, float* v) {
            Pointers.glGetMapfv(target, query, v);
        }
        
        /// <summary>
        /// return evaluator parameters
        /// <para>
        /// glMap1 and glMap2 define evaluators. glGetMap returns evaluator parameters. target chooses a map,
        /// query selects a specific parameter, and v points to storage where the values will be returned
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX,
        /// GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,
        /// GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX,
        /// GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3,
        /// GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </param>
        /// <param name="query">
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        public static void glGetMapfv(int target, int query, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glGetMapfv(target, query, v_);
        }
        
        /// <summary>
        /// return evaluator parameters
        /// <para>
        /// glMap1 and glMap2 define evaluators. glGetMap returns evaluator parameters. target chooses a map,
        /// query selects a specific parameter, and v points to storage where the values will be returned
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX,
        /// GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,
        /// GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX,
        /// GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3,
        /// GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </param>
        /// <param name="query">
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        public static void glGetMapiv(int target, int query, int* v) {
            Pointers.glGetMapiv(target, query, v);
        }
        
        /// <summary>
        /// return evaluator parameters
        /// <para>
        /// glMap1 and glMap2 define evaluators. glGetMap returns evaluator parameters. target chooses a map,
        /// query selects a specific parameter, and v points to storage where the values will be returned
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the symbolic name of a map. Accepted values are GL_MAP1_COLOR_4, GL_MAP1_INDEX,
        /// GL_MAP1_NORMAL, GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3,
        /// GL_MAP1_TEXTURE_COORD_4, GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP2_COLOR_4, GL_MAP2_INDEX,
        /// GL_MAP2_NORMAL, GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3,
        /// GL_MAP2_TEXTURE_COORD_4, GL_MAP2_VERTEX_3, and GL_MAP2_VERTEX_4.
        /// </param>
        /// <param name="query">
        /// Specifies which parameter to return. Symbolic names GL_COEFF, GL_ORDER, and GL_DOMAIN are accepted.
        /// </param>
        /// <param name="v">
        /// Returns the requested data.
        /// </param>
        public static void glGetMapiv(int target, int query, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glGetMapiv(target, query, v_);
        }
        
        public static void glGetMapxvOES(int target, int query, IntPtr* v) {
            Pointers.glGetMapxvOES(target, query, v);
        }
        
        public static void glGetMapxvOES(int target, int query, IntPtr[] v) {
            fixed(IntPtr* v_ = &v[0])
                Pointers.glGetMapxvOES(target, query, v_);
        }
        
        /// <summary>
        /// return material parameters
        /// <para>
        /// glGetMaterial returns in params the value or values of parameter pname of material face. Six
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted,
        /// representing the front and back materials, respectively.
        /// </param>
        /// <param name="pname">
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION,
        /// GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetMaterialfv(int face, int pname, float* _params) {
            Pointers.glGetMaterialfv(face, pname, _params);
        }
        
        /// <summary>
        /// return material parameters
        /// <para>
        /// glGetMaterial returns in params the value or values of parameter pname of material face. Six
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted,
        /// representing the front and back materials, respectively.
        /// </param>
        /// <param name="pname">
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION,
        /// GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetMaterialfv(int face, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMaterialfv(face, pname, _params_);
        }
        
        /// <summary>
        /// return material parameters
        /// <para>
        /// glGetMaterial returns in params the value or values of parameter pname of material face. Six
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted,
        /// representing the front and back materials, respectively.
        /// </param>
        /// <param name="pname">
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION,
        /// GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetMaterialiv(int face, int pname, int* _params) {
            Pointers.glGetMaterialiv(face, pname, _params);
        }
        
        /// <summary>
        /// return material parameters
        /// <para>
        /// glGetMaterial returns in params the value or values of parameter pname of material face. Six
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which of the two materials is being queried. GL_FRONT or GL_BACK are accepted,
        /// representing the front and back materials, respectively.
        /// </param>
        /// <param name="pname">
        /// Specifies the material parameter to return. GL_AMBIENT, GL_DIFFUSE, GL_SPECULAR, GL_EMISSION,
        /// GL_SHININESS, and GL_COLOR_INDEXES are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetMaterialiv(int face, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMaterialiv(face, pname, _params_);
        }
        
        public static void glGetMaterialxOES(int face, int pname, IntPtr param) {
            Pointers.glGetMaterialxOES(face, pname, param);
        }
        
        public static void glGetMaterialxv(int face, int pname, IntPtr* _params) {
            Pointers.glGetMaterialxv(face, pname, _params);
        }
        
        public static void glGetMaterialxv(int face, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetMaterialxv(face, pname, _params_);
        }
        
        public static void glGetMaterialxvOES(int face, int pname, IntPtr* _params) {
            Pointers.glGetMaterialxvOES(face, pname, _params);
        }
        
        public static void glGetMaterialxvOES(int face, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetMaterialxvOES(face, pname, _params_);
        }
        
        public static void glGetMemoryObjectParameterivEXT(uint memoryObject, int pname, int* _params) {
            Pointers.glGetMemoryObjectParameterivEXT(memoryObject, pname, _params);
        }
        
        public static void glGetMemoryObjectParameterivEXT(uint memoryObject, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMemoryObjectParameterivEXT(memoryObject, pname, _params_);
        }
        
        /// <summary>
        /// get minimum and maximum pixel values
        /// <para>
        /// glGetMinmax returns the accumulated minimum and maximum pixel values (computed on a per-component
        /// basis) in a one-dimensional image of width 2. The first set of return values are the minima, and the
        /// second set of return values are the maxima. The format of the return values is determined by format,
        /// and their type is determined by types
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_MINMAX.
        /// </param>
        /// <param name="reset">
        /// If GL_TRUE, all entries in the minmax table that are actually returned are reset to their initial
        /// values. (Other entries are unaltered.) If GL_FALSE, the minmax table is unaltered.
        /// </param>
        /// <param name="format">
        /// The format of the data to be returned in values. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="values">
        /// The type of the data to be returned in values. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        public static void glGetMinmax(int target, bool reset, int format, int type, IntPtr values) {
            Pointers.glGetMinmax(target, reset, format, type, values);
        }
        
        public static void glGetMinmaxEXT(int target, bool reset, int format, int type, IntPtr values) {
            Pointers.glGetMinmaxEXT(target, reset, format, type, values);
        }
        
        /// <summary>
        /// get minmax parameters
        /// <para>
        /// glGetMinmaxParameter retrieves parameters for the current minmax table by setting pname to one of
        /// the following values:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_MINMAX.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </param>
        /// <param name="_params">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        public static void glGetMinmaxParameterfv(int target, int pname, float* _params) {
            Pointers.glGetMinmaxParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// get minmax parameters
        /// <para>
        /// glGetMinmaxParameter retrieves parameters for the current minmax table by setting pname to one of
        /// the following values:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_MINMAX.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </param>
        /// <param name="_params">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        public static void glGetMinmaxParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMinmaxParameterfv(target, pname, _params_);
        }
        
        public static void glGetMinmaxParameterfvEXT(int target, int pname, float* _params) {
            Pointers.glGetMinmaxParameterfvEXT(target, pname, _params);
        }
        
        public static void glGetMinmaxParameterfvEXT(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMinmaxParameterfvEXT(target, pname, _params_);
        }
        
        /// <summary>
        /// get minmax parameters
        /// <para>
        /// glGetMinmaxParameter retrieves parameters for the current minmax table by setting pname to one of
        /// the following values:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_MINMAX.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </param>
        /// <param name="_params">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        public static void glGetMinmaxParameteriv(int target, int pname, int* _params) {
            Pointers.glGetMinmaxParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// get minmax parameters
        /// <para>
        /// glGetMinmaxParameter retrieves parameters for the current minmax table by setting pname to one of
        /// the following values:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_MINMAX.
        /// </param>
        /// <param name="pname">
        /// The parameter to be retrieved. Must be one of GL_MINMAX_FORMAT or GL_MINMAX_SINK.
        /// </param>
        /// <param name="_params">
        /// A pointer to storage for the retrieved parameters.
        /// </param>
        public static void glGetMinmaxParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMinmaxParameteriv(target, pname, _params_);
        }
        
        public static void glGetMinmaxParameterivEXT(int target, int pname, int* _params) {
            Pointers.glGetMinmaxParameterivEXT(target, pname, _params);
        }
        
        public static void glGetMinmaxParameterivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMinmaxParameterivEXT(target, pname, _params_);
        }
        
        public static void glGetMultiTexEnvfvEXT(int texunit, int target, int pname, float* _params) {
            Pointers.glGetMultiTexEnvfvEXT(texunit, target, pname, _params);
        }
        
        public static void glGetMultiTexEnvfvEXT(int texunit, int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMultiTexEnvfvEXT(texunit, target, pname, _params_);
        }
        
        public static void glGetMultiTexEnvivEXT(int texunit, int target, int pname, int* _params) {
            Pointers.glGetMultiTexEnvivEXT(texunit, target, pname, _params);
        }
        
        public static void glGetMultiTexEnvivEXT(int texunit, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMultiTexEnvivEXT(texunit, target, pname, _params_);
        }
        
        public static void glGetMultiTexGendvEXT(int texunit, int coord, int pname, double* _params) {
            Pointers.glGetMultiTexGendvEXT(texunit, coord, pname, _params);
        }
        
        public static void glGetMultiTexGendvEXT(int texunit, int coord, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetMultiTexGendvEXT(texunit, coord, pname, _params_);
        }
        
        public static void glGetMultiTexGenfvEXT(int texunit, int coord, int pname, float* _params) {
            Pointers.glGetMultiTexGenfvEXT(texunit, coord, pname, _params);
        }
        
        public static void glGetMultiTexGenfvEXT(int texunit, int coord, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMultiTexGenfvEXT(texunit, coord, pname, _params_);
        }
        
        public static void glGetMultiTexGenivEXT(int texunit, int coord, int pname, int* _params) {
            Pointers.glGetMultiTexGenivEXT(texunit, coord, pname, _params);
        }
        
        public static void glGetMultiTexGenivEXT(int texunit, int coord, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMultiTexGenivEXT(texunit, coord, pname, _params_);
        }
        
        public static void glGetMultiTexImageEXT(int texunit, int target, int level, int format, int type, IntPtr pixels) {
            Pointers.glGetMultiTexImageEXT(texunit, target, level, format, type, pixels);
        }
        
        public static void glGetMultiTexLevelParameterfvEXT(int texunit, int target, int level, int pname, float* _params) {
            Pointers.glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, _params);
        }
        
        public static void glGetMultiTexLevelParameterfvEXT(int texunit, int target, int level, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMultiTexLevelParameterfvEXT(texunit, target, level, pname, _params_);
        }
        
        public static void glGetMultiTexLevelParameterivEXT(int texunit, int target, int level, int pname, int* _params) {
            Pointers.glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, _params);
        }
        
        public static void glGetMultiTexLevelParameterivEXT(int texunit, int target, int level, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMultiTexLevelParameterivEXT(texunit, target, level, pname, _params_);
        }
        
        public static void glGetMultiTexParameterIivEXT(int texunit, int target, int pname, int* _params) {
            Pointers.glGetMultiTexParameterIivEXT(texunit, target, pname, _params);
        }
        
        public static void glGetMultiTexParameterIivEXT(int texunit, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMultiTexParameterIivEXT(texunit, target, pname, _params_);
        }
        
        public static void glGetMultiTexParameterIuivEXT(int texunit, int target, int pname, uint* _params) {
            Pointers.glGetMultiTexParameterIuivEXT(texunit, target, pname, _params);
        }
        
        public static void glGetMultiTexParameterIuivEXT(int texunit, int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetMultiTexParameterIuivEXT(texunit, target, pname, _params_);
        }
        
        public static void glGetMultiTexParameterfvEXT(int texunit, int target, int pname, float* _params) {
            Pointers.glGetMultiTexParameterfvEXT(texunit, target, pname, _params);
        }
        
        public static void glGetMultiTexParameterfvEXT(int texunit, int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetMultiTexParameterfvEXT(texunit, target, pname, _params_);
        }
        
        public static void glGetMultiTexParameterivEXT(int texunit, int target, int pname, int* _params) {
            Pointers.glGetMultiTexParameterivEXT(texunit, target, pname, _params);
        }
        
        public static void glGetMultiTexParameterivEXT(int texunit, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetMultiTexParameterivEXT(texunit, target, pname, _params_);
        }
        
        /// <summary>
        /// retrieve the location of a sample
        /// <para>
        /// glGetMultisamplefv queries the location of a given sample. pname specifies the sample parameter to
        /// retrieve and must be GL_SAMPLE_POSITION. index corresponds to the sample for which the location
        /// should be returned. The sample location is returned as two floating-point values in val[0] and
        /// val[1], each between 0 and 1, corresponding to the x and y locations respectively in the GL pixel
        /// space of that sample. (0.5, 0.5) this corresponds to the pixel center. index must be between zero
        /// and the value of GL_SAMPLES minus one
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        public static void glGetMultisamplefv(int pname, uint index, float* val) {
            Pointers.glGetMultisamplefv(pname, index, val);
        }
        
        /// <summary>
        /// retrieve the location of a sample
        /// <para>
        /// glGetMultisamplefv queries the location of a given sample. pname specifies the sample parameter to
        /// retrieve and must be GL_SAMPLE_POSITION. index corresponds to the sample for which the location
        /// should be returned. The sample location is returned as two floating-point values in val[0] and
        /// val[1], each between 0 and 1, corresponding to the x and y locations respectively in the GL pixel
        /// space of that sample. (0.5, 0.5) this corresponds to the pixel center. index must be between zero
        /// and the value of GL_SAMPLES minus one
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        public static void glGetMultisamplefv(int pname, uint index, float[] val) {
            fixed(float* val_ = &val[0])
                Pointers.glGetMultisamplefv(pname, index, val_);
        }
        
        /// <summary>
        /// retrieve the location of a sample
        /// <para>
        /// glGetMultisamplefv queries the location of a given sample. pname specifies the sample parameter to
        /// retrieve and must be GL_SAMPLE_POSITION. index corresponds to the sample for which the location
        /// should be returned. The sample location is returned as two floating-point values in val[0] and
        /// val[1], each between 0 and 1, corresponding to the x and y locations respectively in the GL pixel
        /// space of that sample. (0.5, 0.5) this corresponds to the pixel center. index must be between zero
        /// and the value of GL_SAMPLES minus one
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        public static void glGetMultisamplefvNV(int pname, uint index, float* val) {
            Pointers.glGetMultisamplefvNV(pname, index, val);
        }
        
        /// <summary>
        /// retrieve the location of a sample
        /// <para>
        /// glGetMultisamplefv queries the location of a given sample. pname specifies the sample parameter to
        /// retrieve and must be GL_SAMPLE_POSITION. index corresponds to the sample for which the location
        /// should be returned. The sample location is returned as two floating-point values in val[0] and
        /// val[1], each between 0 and 1, corresponding to the x and y locations respectively in the GL pixel
        /// space of that sample. (0.5, 0.5) this corresponds to the pixel center. index must be between zero
        /// and the value of GL_SAMPLES minus one
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the sample parameter name. pname must be GL_SAMPLE_POSITION.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the sample whose position to query.
        /// </param>
        /// <param name="val">
        /// Specifies the address of an array to receive the position of the sample.
        /// </param>
        public static void glGetMultisamplefvNV(int pname, uint index, float[] val) {
            fixed(float* val_ = &val[0])
                Pointers.glGetMultisamplefvNV(pname, index, val_);
        }
        
        public static void glGetNamedBufferParameteri64v(uint buffer, int pname, long* _params) {
            Pointers.glGetNamedBufferParameteri64v(buffer, pname, _params);
        }
        
        public static void glGetNamedBufferParameteri64v(uint buffer, int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetNamedBufferParameteri64v(buffer, pname, _params_);
        }
        
        public static void glGetNamedBufferParameteriv(uint buffer, int pname, int* _params) {
            Pointers.glGetNamedBufferParameteriv(buffer, pname, _params);
        }
        
        public static void glGetNamedBufferParameteriv(uint buffer, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedBufferParameteriv(buffer, pname, _params_);
        }
        
        public static void glGetNamedBufferParameterivEXT(uint buffer, int pname, int* _params) {
            Pointers.glGetNamedBufferParameterivEXT(buffer, pname, _params);
        }
        
        public static void glGetNamedBufferParameterivEXT(uint buffer, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedBufferParameterivEXT(buffer, pname, _params_);
        }
        
        public static void glGetNamedBufferParameterui64vNV(uint buffer, int pname, ulong* _params) {
            Pointers.glGetNamedBufferParameterui64vNV(buffer, pname, _params);
        }
        
        public static void glGetNamedBufferParameterui64vNV(uint buffer, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetNamedBufferParameterui64vNV(buffer, pname, _params_);
        }
        
        public static void glGetNamedBufferPointerv(uint buffer, int pname, IntPtr* _params) {
            Pointers.glGetNamedBufferPointerv(buffer, pname, _params);
        }
        
        public static void glGetNamedBufferPointerv(uint buffer, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetNamedBufferPointerv(buffer, pname, _params_);
        }
        
        public static void glGetNamedBufferPointervEXT(uint buffer, int pname, IntPtr* _params) {
            Pointers.glGetNamedBufferPointervEXT(buffer, pname, _params);
        }
        
        public static void glGetNamedBufferPointervEXT(uint buffer, int pname, out IntPtr _params) {
            fixed(IntPtr* _params_ = &_params)
                Pointers.glGetNamedBufferPointervEXT(buffer, pname, _params_);
        }
        
        public static void glGetNamedBufferSubData(uint buffer, uint offset, uint size, IntPtr data) {
            Pointers.glGetNamedBufferSubData(buffer, offset, size, data);
        }
        
        public static void glGetNamedBufferSubDataEXT(uint buffer, uint offset, uint size, IntPtr data) {
            Pointers.glGetNamedBufferSubDataEXT(buffer, offset, size, data);
        }
        
        public static void glGetNamedFramebufferParameterfvAMD(uint framebuffer, int pname, uint numsamples, uint pixelindex, int size, float* values) {
            Pointers.glGetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values);
        }
        
        public static void glGetNamedFramebufferParameterfvAMD(uint framebuffer, int pname, uint numsamples, uint pixelindex, int size, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glGetNamedFramebufferParameterfvAMD(framebuffer, pname, numsamples, pixelindex, size, values_);
        }
        
        public static void glGetNamedFramebufferAttachmentParameteriv(uint framebuffer, int attachment, int pname, int* _params) {
            Pointers.glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, _params);
        }
        
        public static void glGetNamedFramebufferAttachmentParameteriv(uint framebuffer, int attachment, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, _params_);
        }
        
        public static void glGetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, int attachment, int pname, int* _params) {
            Pointers.glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, _params);
        }
        
        public static void glGetNamedFramebufferAttachmentParameterivEXT(uint framebuffer, int attachment, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedFramebufferAttachmentParameterivEXT(framebuffer, attachment, pname, _params_);
        }
        
        public static void glGetNamedFramebufferParameteriv(uint framebuffer, int pname, int* param) {
            Pointers.glGetNamedFramebufferParameteriv(framebuffer, pname, param);
        }
        
        public static void glGetNamedFramebufferParameteriv(uint framebuffer, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetNamedFramebufferParameteriv(framebuffer, pname, param_);
        }
        
        public static void glGetNamedFramebufferParameterivEXT(uint framebuffer, int pname, int* _params) {
            Pointers.glGetNamedFramebufferParameterivEXT(framebuffer, pname, _params);
        }
        
        public static void glGetNamedFramebufferParameterivEXT(uint framebuffer, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedFramebufferParameterivEXT(framebuffer, pname, _params_);
        }
        
        public static void glGetNamedProgramLocalParameterIivEXT(uint program, int target, uint index, int* _params) {
            Pointers.glGetNamedProgramLocalParameterIivEXT(program, target, index, _params);
        }
        
        public static void glGetNamedProgramLocalParameterIivEXT(uint program, int target, uint index, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedProgramLocalParameterIivEXT(program, target, index, _params_);
        }
        
        public static void glGetNamedProgramLocalParameterIuivEXT(uint program, int target, uint index, uint* _params) {
            Pointers.glGetNamedProgramLocalParameterIuivEXT(program, target, index, _params);
        }
        
        public static void glGetNamedProgramLocalParameterIuivEXT(uint program, int target, uint index, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetNamedProgramLocalParameterIuivEXT(program, target, index, _params_);
        }
        
        public static void glGetNamedProgramLocalParameterdvEXT(uint program, int target, uint index, double* _params) {
            Pointers.glGetNamedProgramLocalParameterdvEXT(program, target, index, _params);
        }
        
        public static void glGetNamedProgramLocalParameterdvEXT(uint program, int target, uint index, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetNamedProgramLocalParameterdvEXT(program, target, index, _params_);
        }
        
        public static void glGetNamedProgramLocalParameterfvEXT(uint program, int target, uint index, float* _params) {
            Pointers.glGetNamedProgramLocalParameterfvEXT(program, target, index, _params);
        }
        
        public static void glGetNamedProgramLocalParameterfvEXT(uint program, int target, uint index, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetNamedProgramLocalParameterfvEXT(program, target, index, _params_);
        }
        
        public static void glGetNamedProgramStringEXT(uint program, int target, int pname, IntPtr _string) {
            Pointers.glGetNamedProgramStringEXT(program, target, pname, _string);
        }
        
        public static void glGetNamedProgramivEXT(uint program, int target, int pname, int* _params) {
            Pointers.glGetNamedProgramivEXT(program, target, pname, _params);
        }
        
        public static void glGetNamedProgramivEXT(uint program, int target, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetNamedProgramivEXT(program, target, pname, _params_);
        }
        
        public static void glGetNamedRenderbufferParameteriv(uint renderbuffer, int pname, int* _params) {
            Pointers.glGetNamedRenderbufferParameteriv(renderbuffer, pname, _params);
        }
        
        public static void glGetNamedRenderbufferParameteriv(uint renderbuffer, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedRenderbufferParameteriv(renderbuffer, pname, _params_);
        }
        
        public static void glGetNamedRenderbufferParameterivEXT(uint renderbuffer, int pname, int* _params) {
            Pointers.glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, _params);
        }
        
        public static void glGetNamedRenderbufferParameterivEXT(uint renderbuffer, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedRenderbufferParameterivEXT(renderbuffer, pname, _params_);
        }
        
        public static void glGetNamedStringARB(int namelen, string name, int bufSize, int* stringlen, StringBuilder _string) {
            Pointers.glGetNamedStringARB(namelen, name, bufSize, stringlen, _string);
        }
        
        public static void glGetNamedStringARB(int namelen, string name, int bufSize, out int stringlen, StringBuilder _string) {
            fixed(int* stringlen_ = &stringlen)
                Pointers.glGetNamedStringARB(namelen, name, bufSize, stringlen_, _string);
        }
        
        public static void glGetNamedStringivARB(int namelen, string name, int pname, int* _params) {
            Pointers.glGetNamedStringivARB(namelen, name, pname, _params);
        }
        
        public static void glGetNamedStringivARB(int namelen, string name, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetNamedStringivARB(namelen, name, pname, _params_);
        }
        
        public static void glGetNextPerfQueryIdINTEL(uint queryId, uint* nextQueryId) {
            Pointers.glGetNextPerfQueryIdINTEL(queryId, nextQueryId);
        }
        
        public static void glGetNextPerfQueryIdINTEL(uint queryId, uint[] nextQueryId) {
            fixed(uint* nextQueryId_ = &nextQueryId[0])
                Pointers.glGetNextPerfQueryIdINTEL(queryId, nextQueryId_);
        }
        
        public static void glGetObjectBufferfvATI(uint buffer, int pname, float* _params) {
            Pointers.glGetObjectBufferfvATI(buffer, pname, _params);
        }
        
        public static void glGetObjectBufferfvATI(uint buffer, int pname, out float _params) {
            fixed(float* _params_ = &_params)
                Pointers.glGetObjectBufferfvATI(buffer, pname, _params_);
        }
        
        public static void glGetObjectBufferivATI(uint buffer, int pname, int* _params) {
            Pointers.glGetObjectBufferivATI(buffer, pname, _params);
        }
        
        public static void glGetObjectBufferivATI(uint buffer, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetObjectBufferivATI(buffer, pname, _params_);
        }
        
        /// <summary>
        /// retrieve the label of a named object identified within a namespace
        /// <para>
        /// glGetObjectLabel retrieves the label of the object identified by name within the namespace given by
        /// identifier. identifier must be one of GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,
        /// GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER, GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,
        /// to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects,
        /// query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and
        /// frame buffers, respectively
        /// </para>
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectLabel(int identifier, uint name, int bufSize, int* length, StringBuilder label) {
            Pointers.glGetObjectLabel(identifier, name, bufSize, length, label);
        }
        
        /// <summary>
        /// retrieve the label of a named object identified within a namespace
        /// <para>
        /// glGetObjectLabel retrieves the label of the object identified by name within the namespace given by
        /// identifier. identifier must be one of GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,
        /// GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER, GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,
        /// to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects,
        /// query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and
        /// frame buffers, respectively
        /// </para>
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectLabel(int identifier, uint name, int bufSize, out int length, StringBuilder label) {
            fixed(int* length_ = &length)
                Pointers.glGetObjectLabel(identifier, name, bufSize, length_, label);
        }
        
        public static void glGetObjectLabelEXT(int type, uint _object, int bufSize, int* length, StringBuilder label) {
            Pointers.glGetObjectLabelEXT(type, _object, bufSize, length, label);
        }
        
        public static void glGetObjectLabelEXT(int type, uint _object, int bufSize, out int length, StringBuilder label) {
            fixed(int* length_ = &length)
                Pointers.glGetObjectLabelEXT(type, _object, bufSize, length_, label);
        }
        
        /// <summary>
        /// retrieve the label of a named object identified within a namespace
        /// <para>
        /// glGetObjectLabel retrieves the label of the object identified by name within the namespace given by
        /// identifier. identifier must be one of GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,
        /// GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER, GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,
        /// to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects,
        /// query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and
        /// frame buffers, respectively
        /// </para>
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectLabelKHR(int identifier, uint name, int bufSize, int* length, StringBuilder label) {
            Pointers.glGetObjectLabelKHR(identifier, name, bufSize, length, label);
        }
        
        /// <summary>
        /// retrieve the label of a named object identified within a namespace
        /// <para>
        /// glGetObjectLabel retrieves the label of the object identified by name within the namespace given by
        /// identifier. identifier must be one of GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,
        /// GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER, GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,
        /// to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects,
        /// query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and
        /// frame buffers, respectively
        /// </para>
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectLabelKHR(int identifier, uint name, int bufSize, int[] length, StringBuilder label) {
            fixed(int* length_ = &length[0])
                Pointers.glGetObjectLabelKHR(identifier, name, bufSize, length_, label);
        }
        
        public static void glGetObjectParameterfvARB(uint obj, int pname, float* _params) {
            Pointers.glGetObjectParameterfvARB(obj, pname, _params);
        }
        
        public static void glGetObjectParameterfvARB(uint obj, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetObjectParameterfvARB(obj, pname, _params_);
        }
        
        public static void glGetObjectParameterivAPPLE(int objectType, uint name, int pname, int* _params) {
            Pointers.glGetObjectParameterivAPPLE(objectType, name, pname, _params);
        }
        
        public static void glGetObjectParameterivAPPLE(int objectType, uint name, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetObjectParameterivAPPLE(objectType, name, pname, _params_);
        }
        
        public static void glGetObjectParameterivARB(uint obj, int pname, int* _params) {
            Pointers.glGetObjectParameterivARB(obj, pname, _params);
        }
        
        public static void glGetObjectParameterivARB(uint obj, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetObjectParameterivARB(obj, pname, _params_);
        }
        
        /// <summary>
        /// retrieve the label of a sync object identified by a pointer
        /// <para>
        /// glGetObjectPtrLabel retrieves the label of the sync object identified by ptr
        /// </para>
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectPtrLabel(IntPtr ptr, int bufSize, int* length, StringBuilder label) {
            Pointers.glGetObjectPtrLabel(ptr, bufSize, length, label);
        }
        
        /// <summary>
        /// retrieve the label of a sync object identified by a pointer
        /// <para>
        /// glGetObjectPtrLabel retrieves the label of the sync object identified by ptr
        /// </para>
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectPtrLabel(IntPtr ptr, int bufSize, out int length, StringBuilder label) {
            fixed(int* length_ = &length)
                Pointers.glGetObjectPtrLabel(ptr, bufSize, length_, label);
        }
        
        /// <summary>
        /// retrieve the label of a sync object identified by a pointer
        /// <para>
        /// glGetObjectPtrLabel retrieves the label of the sync object identified by ptr
        /// </para>
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectPtrLabelKHR(IntPtr ptr, int bufSize, int* length, StringBuilder label) {
            Pointers.glGetObjectPtrLabelKHR(ptr, bufSize, length, label);
        }
        
        /// <summary>
        /// retrieve the label of a sync object identified by a pointer
        /// <para>
        /// glGetObjectPtrLabel retrieves the label of the sync object identified by ptr
        /// </para>
        /// </summary>
        /// <param name="ptr">
        /// The name of the sync object whose label to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        /// <param name="label">
        /// The address of a variable to receive the length of the object label.
        /// </param>
        public static void glGetObjectPtrLabelKHR(IntPtr ptr, int bufSize, out int length, StringBuilder label) {
            fixed(int* length_ = &length)
                Pointers.glGetObjectPtrLabelKHR(ptr, bufSize, length_, label);
        }
        
        public static void glGetOcclusionQueryivNV(uint id, int pname, int* _params) {
            Pointers.glGetOcclusionQueryivNV(id, pname, _params);
        }
        
        public static void glGetOcclusionQueryivNV(uint id, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetOcclusionQueryivNV(id, pname, _params_);
        }
        
        public static void glGetOcclusionQueryuivNV(uint id, int pname, uint* _params) {
            Pointers.glGetOcclusionQueryuivNV(id, pname, _params);
        }
        
        public static void glGetOcclusionQueryuivNV(uint id, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetOcclusionQueryuivNV(id, pname, _params_);
        }
        
        public static void glGetPathColorGenfvNV(int color, int pname, float* value) {
            Pointers.glGetPathColorGenfvNV(color, pname, value);
        }
        
        public static void glGetPathColorGenfvNV(int color, int pname, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glGetPathColorGenfvNV(color, pname, value_);
        }
        
        public static void glGetPathColorGenivNV(int color, int pname, int* value) {
            Pointers.glGetPathColorGenivNV(color, pname, value);
        }
        
        public static void glGetPathColorGenivNV(int color, int pname, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glGetPathColorGenivNV(color, pname, value_);
        }
        
        public static void glGetPathCommandsNV(uint path, byte* commands) {
            Pointers.glGetPathCommandsNV(path, commands);
        }
        
        public static void glGetPathCommandsNV(uint path, byte[] commands) {
            fixed(byte* commands_ = &commands[0])
                Pointers.glGetPathCommandsNV(path, commands_);
        }
        
        public static void glGetPathCoordsNV(uint path, float* coords) {
            Pointers.glGetPathCoordsNV(path, coords);
        }
        
        public static void glGetPathCoordsNV(uint path, float[] coords) {
            fixed(float* coords_ = &coords[0])
                Pointers.glGetPathCoordsNV(path, coords_);
        }
        
        public static void glGetPathDashArrayNV(uint path, float* dashArray) {
            Pointers.glGetPathDashArrayNV(path, dashArray);
        }
        
        public static void glGetPathDashArrayNV(uint path, float[] dashArray) {
            fixed(float* dashArray_ = &dashArray[0])
                Pointers.glGetPathDashArrayNV(path, dashArray_);
        }
        
        public static float glGetPathLengthNV(uint path, int startSegment, int numSegments) {
            return Pointers.glGetPathLengthNV(path, startSegment, numSegments);
        }
        
        public static void glGetPathMetricRangeNV(uint metricQueryMask, uint firstPathName, int numPaths, int stride, float* metrics) {
            Pointers.glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics);
        }
        
        public static void glGetPathMetricRangeNV(uint metricQueryMask, uint firstPathName, int numPaths, int stride, float[] metrics) {
            fixed(float* metrics_ = &metrics[0])
                Pointers.glGetPathMetricRangeNV(metricQueryMask, firstPathName, numPaths, stride, metrics_);
        }
        
        public static void glGetPathMetricsNV(uint metricQueryMask, int numPaths, int pathNameType, IntPtr paths, uint pathBase, int stride, float* metrics) {
            Pointers.glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics);
        }
        
        public static void glGetPathMetricsNV(uint metricQueryMask, int numPaths, int pathNameType, IntPtr paths, uint pathBase, int stride, float[] metrics) {
            fixed(float* metrics_ = &metrics[0])
                Pointers.glGetPathMetricsNV(metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics_);
        }
        
        public static void glGetPathParameterfvNV(uint path, int pname, float* value) {
            Pointers.glGetPathParameterfvNV(path, pname, value);
        }
        
        public static void glGetPathParameterfvNV(uint path, int pname, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glGetPathParameterfvNV(path, pname, value_);
        }
        
        public static void glGetPathParameterivNV(uint path, int pname, int* value) {
            Pointers.glGetPathParameterivNV(path, pname, value);
        }
        
        public static void glGetPathParameterivNV(uint path, int pname, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glGetPathParameterivNV(path, pname, value_);
        }
        
        public static void glGetPathSpacingNV(int pathListMode, int numPaths, int pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, int transformType, float* returnedSpacing) {
            Pointers.glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing);
        }
        
        public static void glGetPathSpacingNV(int pathListMode, int numPaths, int pathNameType, IntPtr paths, uint pathBase, float advanceScale, float kerningScale, int transformType, float[] returnedSpacing) {
            fixed(float* returnedSpacing_ = &returnedSpacing[0])
                Pointers.glGetPathSpacingNV(pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing_);
        }
        
        public static void glGetPathTexGenfvNV(int texCoordSet, int pname, float* value) {
            Pointers.glGetPathTexGenfvNV(texCoordSet, pname, value);
        }
        
        public static void glGetPathTexGenfvNV(int texCoordSet, int pname, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glGetPathTexGenfvNV(texCoordSet, pname, value_);
        }
        
        public static void glGetPathTexGenivNV(int texCoordSet, int pname, int* value) {
            Pointers.glGetPathTexGenivNV(texCoordSet, pname, value);
        }
        
        public static void glGetPathTexGenivNV(int texCoordSet, int pname, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glGetPathTexGenivNV(texCoordSet, pname, value_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint* counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset, counterDataSize_, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint* counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint* counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint* counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum_, counterDataTypeEnum, rawCounterMaxValue_);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong* rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue);
        }
        
        public static void glGetPerfCounterInfoINTEL(uint queryId, uint counterId, uint counterNameLength, StringBuilder counterName, uint counterDescLength, StringBuilder counterDesc, uint[] counterOffset, uint[] counterDataSize, uint[] counterTypeEnum, uint[] counterDataTypeEnum, ulong[] rawCounterMaxValue) {
            fixed(uint* counterOffset_ = &counterOffset[0])
            fixed(uint* counterDataSize_ = &counterDataSize[0])
            fixed(uint* counterTypeEnum_ = &counterTypeEnum[0])
            fixed(uint* counterDataTypeEnum_ = &counterDataTypeEnum[0])
            fixed(ulong* rawCounterMaxValue_ = &rawCounterMaxValue[0])
                Pointers.glGetPerfCounterInfoINTEL(queryId, counterId, counterNameLength, counterName, counterDescLength, counterDesc, counterOffset_, counterDataSize_, counterTypeEnum_, counterDataTypeEnum_, rawCounterMaxValue_);
        }
        
        public static void glGetPerfMonitorCounterDataAMD(uint monitor, int pname, int dataSize, uint* data, int* bytesWritten) {
            Pointers.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
        }
        
        public static void glGetPerfMonitorCounterDataAMD(uint monitor, int pname, int dataSize, uint* data, out int bytesWritten) {
            fixed(int* bytesWritten_ = &bytesWritten)
                Pointers.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten_);
        }
        
        public static void glGetPerfMonitorCounterDataAMD(uint monitor, int pname, int dataSize, uint[] data, int* bytesWritten) {
            fixed(uint* data_ = &data[0])
                Pointers.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data_, bytesWritten);
        }
        
        public static void glGetPerfMonitorCounterDataAMD(uint monitor, int pname, int dataSize, uint[] data, out int bytesWritten) {
            fixed(uint* data_ = &data[0])
            fixed(int* bytesWritten_ = &bytesWritten)
                Pointers.glGetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data_, bytesWritten_);
        }
        
        public static void glGetPerfMonitorCounterInfoAMD(uint group, uint counter, int pname, IntPtr data) {
            Pointers.glGetPerfMonitorCounterInfoAMD(group, counter, pname, data);
        }
        
        public static void glGetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, int* length, StringBuilder counterString) {
            Pointers.glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
        }
        
        public static void glGetPerfMonitorCounterStringAMD(uint group, uint counter, int bufSize, out int length, StringBuilder counterString) {
            fixed(int* length_ = &length)
                Pointers.glGetPerfMonitorCounterStringAMD(group, counter, bufSize, length_, counterString);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint* counters) {
            Pointers.glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, int* numCounters, int* maxActiveCounters, int counterSize, uint[] counters) {
            fixed(uint* counters_ = &counters[0])
                Pointers.glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters_);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, int* numCounters, out int maxActiveCounters, int counterSize, uint* counters) {
            fixed(int* maxActiveCounters_ = &maxActiveCounters)
                Pointers.glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters_, counterSize, counters);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, int* numCounters, out int maxActiveCounters, int counterSize, uint[] counters) {
            fixed(int* maxActiveCounters_ = &maxActiveCounters)
            fixed(uint* counters_ = &counters[0])
                Pointers.glGetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters_, counterSize, counters_);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, out int numCounters, int* maxActiveCounters, int counterSize, uint* counters) {
            fixed(int* numCounters_ = &numCounters)
                Pointers.glGetPerfMonitorCountersAMD(group, numCounters_, maxActiveCounters, counterSize, counters);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, out int numCounters, int* maxActiveCounters, int counterSize, uint[] counters) {
            fixed(int* numCounters_ = &numCounters)
            fixed(uint* counters_ = &counters[0])
                Pointers.glGetPerfMonitorCountersAMD(group, numCounters_, maxActiveCounters, counterSize, counters_);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, out int numCounters, out int maxActiveCounters, int counterSize, uint* counters) {
            fixed(int* numCounters_ = &numCounters)
            fixed(int* maxActiveCounters_ = &maxActiveCounters)
                Pointers.glGetPerfMonitorCountersAMD(group, numCounters_, maxActiveCounters_, counterSize, counters);
        }
        
        public static void glGetPerfMonitorCountersAMD(uint group, out int numCounters, out int maxActiveCounters, int counterSize, uint[] counters) {
            fixed(int* numCounters_ = &numCounters)
            fixed(int* maxActiveCounters_ = &maxActiveCounters)
            fixed(uint* counters_ = &counters[0])
                Pointers.glGetPerfMonitorCountersAMD(group, numCounters_, maxActiveCounters_, counterSize, counters_);
        }
        
        public static void glGetPerfMonitorGroupStringAMD(uint group, int bufSize, int* length, StringBuilder groupString) {
            Pointers.glGetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
        }
        
        public static void glGetPerfMonitorGroupStringAMD(uint group, int bufSize, out int length, StringBuilder groupString) {
            fixed(int* length_ = &length)
                Pointers.glGetPerfMonitorGroupStringAMD(group, bufSize, length_, groupString);
        }
        
        public static void glGetPerfMonitorGroupsAMD(int* numGroups, int groupsSize, uint* groups) {
            Pointers.glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
        }
        
        public static void glGetPerfMonitorGroupsAMD(int* numGroups, int groupsSize, uint[] groups) {
            fixed(uint* groups_ = &groups[0])
                Pointers.glGetPerfMonitorGroupsAMD(numGroups, groupsSize, groups_);
        }
        
        public static void glGetPerfMonitorGroupsAMD(out int numGroups, int groupsSize, uint* groups) {
            fixed(int* numGroups_ = &numGroups)
                Pointers.glGetPerfMonitorGroupsAMD(numGroups_, groupsSize, groups);
        }
        
        public static void glGetPerfMonitorGroupsAMD(out int numGroups, int groupsSize, uint[] groups) {
            fixed(int* numGroups_ = &numGroups)
            fixed(uint* groups_ = &groups[0])
                Pointers.glGetPerfMonitorGroupsAMD(numGroups_, groupsSize, groups_);
        }
        
        public static void glGetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, IntPtr data, uint* bytesWritten) {
            Pointers.glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten);
        }
        
        public static void glGetPerfQueryDataINTEL(uint queryHandle, uint flags, int dataSize, IntPtr data, uint[] bytesWritten) {
            fixed(uint* bytesWritten_ = &bytesWritten[0])
                Pointers.glGetPerfQueryDataINTEL(queryHandle, flags, dataSize, data, bytesWritten_);
        }
        
        public static void glGetPerfQueryIdByNameINTEL(StringBuilder queryName, uint* queryId) {
            Pointers.glGetPerfQueryIdByNameINTEL(queryName, queryId);
        }
        
        public static void glGetPerfQueryIdByNameINTEL(StringBuilder queryName, uint[] queryId) {
            fixed(uint* queryId_ = &queryId[0])
                Pointers.glGetPerfQueryIdByNameINTEL(queryName, queryId_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint* noCounters, uint* noInstances, uint* capsMask) {
            Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint* noCounters, uint* noInstances, uint[] capsMask) {
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances, capsMask_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint* noCounters, uint[] noInstances, uint* capsMask) {
            fixed(uint* noInstances_ = &noInstances[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances_, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint* noCounters, uint[] noInstances, uint[] capsMask) {
            fixed(uint* noInstances_ = &noInstances[0])
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters, noInstances_, capsMask_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint[] noCounters, uint* noInstances, uint* capsMask) {
            fixed(uint* noCounters_ = &noCounters[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters_, noInstances, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint[] noCounters, uint* noInstances, uint[] capsMask) {
            fixed(uint* noCounters_ = &noCounters[0])
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters_, noInstances, capsMask_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint[] noCounters, uint[] noInstances, uint* capsMask) {
            fixed(uint* noCounters_ = &noCounters[0])
            fixed(uint* noInstances_ = &noInstances[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters_, noInstances_, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint* dataSize, uint[] noCounters, uint[] noInstances, uint[] capsMask) {
            fixed(uint* noCounters_ = &noCounters[0])
            fixed(uint* noInstances_ = &noInstances[0])
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize, noCounters_, noInstances_, capsMask_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint* noCounters, uint* noInstances, uint* capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters, noInstances, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint* noCounters, uint* noInstances, uint[] capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters, noInstances, capsMask_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint* noCounters, uint[] noInstances, uint* capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
            fixed(uint* noInstances_ = &noInstances[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters, noInstances_, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint* noCounters, uint[] noInstances, uint[] capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
            fixed(uint* noInstances_ = &noInstances[0])
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters, noInstances_, capsMask_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint[] noCounters, uint* noInstances, uint* capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
            fixed(uint* noCounters_ = &noCounters[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters_, noInstances, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint[] noCounters, uint* noInstances, uint[] capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
            fixed(uint* noCounters_ = &noCounters[0])
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters_, noInstances, capsMask_);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint[] noCounters, uint[] noInstances, uint* capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
            fixed(uint* noCounters_ = &noCounters[0])
            fixed(uint* noInstances_ = &noInstances[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters_, noInstances_, capsMask);
        }
        
        public static void glGetPerfQueryInfoINTEL(uint queryId, uint queryNameLength, StringBuilder queryName, uint[] dataSize, uint[] noCounters, uint[] noInstances, uint[] capsMask) {
            fixed(uint* dataSize_ = &dataSize[0])
            fixed(uint* noCounters_ = &noCounters[0])
            fixed(uint* noInstances_ = &noInstances[0])
            fixed(uint* capsMask_ = &capsMask[0])
                Pointers.glGetPerfQueryInfoINTEL(queryId, queryNameLength, queryName, dataSize_, noCounters_, noInstances_, capsMask_);
        }
        
        /// <summary>
        /// return the specified pixel map
        /// <para>
        /// See the glPixelMap reference page for a description of the acceptable values for the map parameter.
        /// glGetPixelMap returns in data the contents of the pixel map specified in map. Pixel maps are used
        /// during the execution of glReadPixels, glDrawPixels, glCopyPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glCopyTexImage1D, glCopyTexImage2D,
        /// glCopyTexSubImage1D, glCopyTexSubImage2D, and glCopyTexSubImage3D. to map color indices, stencil
        /// indices, color components, and depth components to other values
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="values">
        /// Returns the pixel map contents.
        /// </param>
        public static void glGetPixelMapfv(int map, float* values) {
            Pointers.glGetPixelMapfv(map, values);
        }
        
        /// <summary>
        /// return the specified pixel map
        /// <para>
        /// See the glPixelMap reference page for a description of the acceptable values for the map parameter.
        /// glGetPixelMap returns in data the contents of the pixel map specified in map. Pixel maps are used
        /// during the execution of glReadPixels, glDrawPixels, glCopyPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glCopyTexImage1D, glCopyTexImage2D,
        /// glCopyTexSubImage1D, glCopyTexSubImage2D, and glCopyTexSubImage3D. to map color indices, stencil
        /// indices, color components, and depth components to other values
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="values">
        /// Returns the pixel map contents.
        /// </param>
        public static void glGetPixelMapfv(int map, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glGetPixelMapfv(map, values_);
        }
        
        /// <summary>
        /// return the specified pixel map
        /// <para>
        /// See the glPixelMap reference page for a description of the acceptable values for the map parameter.
        /// glGetPixelMap returns in data the contents of the pixel map specified in map. Pixel maps are used
        /// during the execution of glReadPixels, glDrawPixels, glCopyPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glCopyTexImage1D, glCopyTexImage2D,
        /// glCopyTexSubImage1D, glCopyTexSubImage2D, and glCopyTexSubImage3D. to map color indices, stencil
        /// indices, color components, and depth components to other values
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="values">
        /// Returns the pixel map contents.
        /// </param>
        public static void glGetPixelMapuiv(int map, uint* values) {
            Pointers.glGetPixelMapuiv(map, values);
        }
        
        /// <summary>
        /// return the specified pixel map
        /// <para>
        /// See the glPixelMap reference page for a description of the acceptable values for the map parameter.
        /// glGetPixelMap returns in data the contents of the pixel map specified in map. Pixel maps are used
        /// during the execution of glReadPixels, glDrawPixels, glCopyPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glCopyTexImage1D, glCopyTexImage2D,
        /// glCopyTexSubImage1D, glCopyTexSubImage2D, and glCopyTexSubImage3D. to map color indices, stencil
        /// indices, color components, and depth components to other values
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="values">
        /// Returns the pixel map contents.
        /// </param>
        public static void glGetPixelMapuiv(int map, uint[] values) {
            fixed(uint* values_ = &values[0])
                Pointers.glGetPixelMapuiv(map, values_);
        }
        
        /// <summary>
        /// return the specified pixel map
        /// <para>
        /// See the glPixelMap reference page for a description of the acceptable values for the map parameter.
        /// glGetPixelMap returns in data the contents of the pixel map specified in map. Pixel maps are used
        /// during the execution of glReadPixels, glDrawPixels, glCopyPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glCopyTexImage1D, glCopyTexImage2D,
        /// glCopyTexSubImage1D, glCopyTexSubImage2D, and glCopyTexSubImage3D. to map color indices, stencil
        /// indices, color components, and depth components to other values
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="values">
        /// Returns the pixel map contents.
        /// </param>
        public static void glGetPixelMapusv(int map, ushort* values) {
            Pointers.glGetPixelMapusv(map, values);
        }
        
        /// <summary>
        /// return the specified pixel map
        /// <para>
        /// See the glPixelMap reference page for a description of the acceptable values for the map parameter.
        /// glGetPixelMap returns in data the contents of the pixel map specified in map. Pixel maps are used
        /// during the execution of glReadPixels, glDrawPixels, glCopyPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, glTexSubImage3D, glCopyTexImage1D, glCopyTexImage2D,
        /// glCopyTexSubImage1D, glCopyTexSubImage2D, and glCopyTexSubImage3D. to map color indices, stencil
        /// indices, color components, and depth components to other values
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies the name of the pixel map to return. Accepted values are GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, and
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="values">
        /// Returns the pixel map contents.
        /// </param>
        public static void glGetPixelMapusv(int map, ushort[] values) {
            fixed(ushort* values_ = &values[0])
                Pointers.glGetPixelMapusv(map, values_);
        }
        
        public static void glGetPixelMapxv(int map, int size, IntPtr* values) {
            Pointers.glGetPixelMapxv(map, size, values);
        }
        
        public static void glGetPixelMapxv(int map, int size, IntPtr[] values) {
            fixed(IntPtr* values_ = &values[0])
                Pointers.glGetPixelMapxv(map, size, values_);
        }
        
        public static void glGetPixelTexGenParameterfvSGIS(int pname, float* _params) {
            Pointers.glGetPixelTexGenParameterfvSGIS(pname, _params);
        }
        
        public static void glGetPixelTexGenParameterfvSGIS(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetPixelTexGenParameterfvSGIS(pname, _params_);
        }
        
        public static void glGetPixelTexGenParameterivSGIS(int pname, int* _params) {
            Pointers.glGetPixelTexGenParameterivSGIS(pname, _params);
        }
        
        public static void glGetPixelTexGenParameterivSGIS(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetPixelTexGenParameterivSGIS(pname, _params_);
        }
        
        public static void glGetPixelTransformParameterfvEXT(int target, int pname, float* _params) {
            Pointers.glGetPixelTransformParameterfvEXT(target, pname, _params);
        }
        
        public static void glGetPixelTransformParameterfvEXT(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetPixelTransformParameterfvEXT(target, pname, _params_);
        }
        
        public static void glGetPixelTransformParameterivEXT(int target, int pname, int* _params) {
            Pointers.glGetPixelTransformParameterivEXT(target, pname, _params);
        }
        
        public static void glGetPixelTransformParameterivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetPixelTransformParameterivEXT(target, pname, _params_);
        }
        
        public static void glGetPointerIndexedvEXT(int target, uint index, IntPtr* data) {
            Pointers.glGetPointerIndexedvEXT(target, index, data);
        }
        
        public static void glGetPointerIndexedvEXT(int target, uint index, out IntPtr data) {
            fixed(IntPtr* data_ = &data)
                Pointers.glGetPointerIndexedvEXT(target, index, data_);
        }
        
        public static void glGetPointeri_vEXT(int pname, uint index, IntPtr* _params) {
            Pointers.glGetPointeri_vEXT(pname, index, _params);
        }
        
        public static void glGetPointeri_vEXT(int pname, uint index, out IntPtr _params) {
            fixed(IntPtr* _params_ = &_params)
                Pointers.glGetPointeri_vEXT(pname, index, _params_);
        }
        
        /// <summary>
        /// return the address of the specified pointer
        /// <para>
        /// glGetPointerv returns pointer information. pname indicates the pointer to be returned, and params is
        /// a pointer to a location in which to place the returned data. The parameters that may be queried
        /// include:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or
        /// GL_DEBUG_CALLBACK_USER_PARAM.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetPointerv(int pname, IntPtr* _params) {
            Pointers.glGetPointerv(pname, _params);
        }
        
        /// <summary>
        /// return the address of the specified pointer
        /// <para>
        /// glGetPointerv returns pointer information. pname indicates the pointer to be returned, and params is
        /// a pointer to a location in which to place the returned data. The parameters that may be queried
        /// include:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or
        /// GL_DEBUG_CALLBACK_USER_PARAM.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetPointerv(int pname, out IntPtr _params) {
            fixed(IntPtr* _params_ = &_params)
                Pointers.glGetPointerv(pname, _params_);
        }
        
        /// <summary>
        /// return the address of the specified pointer
        /// <para>
        /// glGetPointerv returns pointer information. pname indicates the pointer to be returned, and params is
        /// a pointer to a location in which to place the returned data. The parameters that may be queried
        /// include:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or
        /// GL_DEBUG_CALLBACK_USER_PARAM.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetPointervEXT(int pname, IntPtr* _params) {
            Pointers.glGetPointervEXT(pname, _params);
        }
        
        /// <summary>
        /// return the address of the specified pointer
        /// <para>
        /// glGetPointerv returns pointer information. pname indicates the pointer to be returned, and params is
        /// a pointer to a location in which to place the returned data. The parameters that may be queried
        /// include:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or
        /// GL_DEBUG_CALLBACK_USER_PARAM.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetPointervEXT(int pname, out IntPtr _params) {
            fixed(IntPtr* _params_ = &_params)
                Pointers.glGetPointervEXT(pname, _params_);
        }
        
        /// <summary>
        /// return the address of the specified pointer
        /// <para>
        /// glGetPointerv returns pointer information. pname indicates the pointer to be returned, and params is
        /// a pointer to a location in which to place the returned data. The parameters that may be queried
        /// include:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or
        /// GL_DEBUG_CALLBACK_USER_PARAM.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetPointervKHR(int pname, IntPtr* _params) {
            Pointers.glGetPointervKHR(pname, _params);
        }
        
        /// <summary>
        /// return the address of the specified pointer
        /// <para>
        /// glGetPointerv returns pointer information. pname indicates the pointer to be returned, and params is
        /// a pointer to a location in which to place the returned data. The parameters that may be queried
        /// include:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the pointer to be returned. Must be one of GL_DEBUG_CALLBACK_FUNCTION or
        /// GL_DEBUG_CALLBACK_USER_PARAM.
        /// </param>
        /// <param name="_params">
        /// Returns the pointer value specified by pname.
        /// </param>
        public static void glGetPointervKHR(int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetPointervKHR(pname, _params_);
        }
        
        /// <summary>
        /// return the polygon stipple pattern
        /// <para>
        /// glGetPolygonStipple returns to pattern a 32 &times; 32 polygon stipple pattern. The pattern is
        /// packed into memory as if glReadPixels with both height and width of 32, type of GL_BITMAP, and
        /// format of GL_COLOR_INDEX were called, and the stipple pattern were stored in an internal 32 &times;
        /// 32 color index buffer. Unlike glReadPixels, however, pixel transfer operations (shift, offset, pixel
        /// map) are not applied to the returned stipple image
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Returns the stipple pattern. The initial value is all 1's.
        /// </param>
        public static void glGetPolygonStipple(byte* mask) {
            Pointers.glGetPolygonStipple(mask);
        }
        
        /// <summary>
        /// return the polygon stipple pattern
        /// <para>
        /// glGetPolygonStipple returns to pattern a 32 &times; 32 polygon stipple pattern. The pattern is
        /// packed into memory as if glReadPixels with both height and width of 32, type of GL_BITMAP, and
        /// format of GL_COLOR_INDEX were called, and the stipple pattern were stored in an internal 32 &times;
        /// 32 color index buffer. Unlike glReadPixels, however, pixel transfer operations (shift, offset, pixel
        /// map) are not applied to the returned stipple image
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Returns the stipple pattern. The initial value is all 1's.
        /// </param>
        public static void glGetPolygonStipple(byte[] mask) {
            fixed(byte* mask_ = &mask[0])
                Pointers.glGetPolygonStipple(mask_);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinary(uint program, int bufSize, int* length, int* binaryFormat, IntPtr binary) {
            Pointers.glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinary(uint program, int bufSize, int* length, out int binaryFormat, IntPtr binary) {
            fixed(int* binaryFormat_ = &binaryFormat)
                Pointers.glGetProgramBinary(program, bufSize, length, binaryFormat_, binary);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinary(uint program, int bufSize, out int length, int* binaryFormat, IntPtr binary) {
            fixed(int* length_ = &length)
                Pointers.glGetProgramBinary(program, bufSize, length_, binaryFormat, binary);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinary(uint program, int bufSize, out int length, out int binaryFormat, IntPtr binary) {
            fixed(int* length_ = &length)
            fixed(int* binaryFormat_ = &binaryFormat)
                Pointers.glGetProgramBinary(program, bufSize, length_, binaryFormat_, binary);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinaryOES(uint program, int bufSize, int* length, int* binaryFormat, IntPtr binary) {
            Pointers.glGetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinaryOES(uint program, int bufSize, int* length, out int binaryFormat, IntPtr binary) {
            fixed(int* binaryFormat_ = &binaryFormat)
                Pointers.glGetProgramBinaryOES(program, bufSize, length, binaryFormat_, binary);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinaryOES(uint program, int bufSize, out int length, int* binaryFormat, IntPtr binary) {
            fixed(int* length_ = &length)
                Pointers.glGetProgramBinaryOES(program, bufSize, length_, binaryFormat, binary);
        }
        
        /// <summary>
        /// return a binary representation of a program object's compiled and linked executable source
        /// <para>
        /// glGetProgramBinary returns a binary representation of the compiled and linked executable for program
        /// into the array of bytes whose address is specified in binary. The maximum number of bytes that may
        /// be written into binary is specified by bufSize. If the program binary is greater in size than
        /// bufSize bytes, then an error is generated, otherwise the actual number of bytes written into binary
        /// is returned in the variable whose address is given by length. If length is NULL, then no length is
        /// returned
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose binary representation to retrieve.
        /// </param>
        /// <param name="bufSize"> </param>
        /// <param name="length">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the address of a variable to receive a token indicating the format of the binary data
        /// returned by the GL.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of a variable to receive the number of bytes written into binary.
        /// </param>
        public static void glGetProgramBinaryOES(uint program, int bufSize, out int length, out int binaryFormat, IntPtr binary) {
            fixed(int* length_ = &length)
            fixed(int* binaryFormat_ = &binaryFormat)
                Pointers.glGetProgramBinaryOES(program, bufSize, length_, binaryFormat_, binary);
        }
        
        public static void glGetProgramEnvParameterIivNV(int target, uint index, int* _params) {
            Pointers.glGetProgramEnvParameterIivNV(target, index, _params);
        }
        
        public static void glGetProgramEnvParameterIivNV(int target, uint index, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramEnvParameterIivNV(target, index, _params_);
        }
        
        public static void glGetProgramEnvParameterIuivNV(int target, uint index, uint* _params) {
            Pointers.glGetProgramEnvParameterIuivNV(target, index, _params);
        }
        
        public static void glGetProgramEnvParameterIuivNV(int target, uint index, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetProgramEnvParameterIuivNV(target, index, _params_);
        }
        
        public static void glGetProgramEnvParameterdvARB(int target, uint index, double* _params) {
            Pointers.glGetProgramEnvParameterdvARB(target, index, _params);
        }
        
        public static void glGetProgramEnvParameterdvARB(int target, uint index, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetProgramEnvParameterdvARB(target, index, _params_);
        }
        
        public static void glGetProgramEnvParameterfvARB(int target, uint index, float* _params) {
            Pointers.glGetProgramEnvParameterfvARB(target, index, _params);
        }
        
        public static void glGetProgramEnvParameterfvARB(int target, uint index, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramEnvParameterfvARB(target, index, _params_);
        }
        
        /// <summary>
        /// Returns the information log for a program object
        /// <para>
        /// glGetProgramInfoLog returns the information log for the specified program object. The information
        /// log for a program object is modified when the program object is linked or validated. The string that
        /// is returned will be null terminated
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        public static void glGetProgramInfoLog(uint program, int bufSize, int* length, StringBuilder infoLog) {
            Pointers.glGetProgramInfoLog(program, bufSize, length, infoLog);
        }
        
        /// <summary>
        /// Returns the information log for a program object
        /// <para>
        /// glGetProgramInfoLog returns the information log for the specified program object. The information
        /// log for a program object is modified when the program object is linked or validated. The string that
        /// is returned will be null terminated
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        public static void glGetProgramInfoLog(uint program, int bufSize, out int length, StringBuilder infoLog) {
            fixed(int* length_ = &length)
                Pointers.glGetProgramInfoLog(program, bufSize, length_, infoLog);
        }
        
        /// <summary>
        /// query a property of an interface in a program
        /// <para>
        /// glGetProgramInterfaceiv queries the property of the interface identifed by programInterface in
        /// program, the property name of which is given by pname
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="_params">
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        public static void glGetProgramInterfaceiv(uint program, int programInterface, int pname, int* _params) {
            Pointers.glGetProgramInterfaceiv(program, programInterface, pname, _params);
        }
        
        /// <summary>
        /// query a property of an interface in a program
        /// <para>
        /// glGetProgramInterfaceiv queries the property of the interface identifed by programInterface in
        /// program, the property name of which is given by pname
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose interface to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program to query.
        /// </param>
        /// <param name="pname">
        /// The name of the parameter within programInterface to query.
        /// </param>
        /// <param name="_params">
        /// The address of a variable to retrieve the value of pname for the program interface.
        /// </param>
        public static void glGetProgramInterfaceiv(uint program, int programInterface, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramInterfaceiv(program, programInterface, pname, _params_);
        }
        
        public static void glGetProgramLocalParameterIivNV(int target, uint index, int* _params) {
            Pointers.glGetProgramLocalParameterIivNV(target, index, _params);
        }
        
        public static void glGetProgramLocalParameterIivNV(int target, uint index, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramLocalParameterIivNV(target, index, _params_);
        }
        
        public static void glGetProgramLocalParameterIuivNV(int target, uint index, uint* _params) {
            Pointers.glGetProgramLocalParameterIuivNV(target, index, _params);
        }
        
        public static void glGetProgramLocalParameterIuivNV(int target, uint index, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetProgramLocalParameterIuivNV(target, index, _params_);
        }
        
        public static void glGetProgramLocalParameterdvARB(int target, uint index, double* _params) {
            Pointers.glGetProgramLocalParameterdvARB(target, index, _params);
        }
        
        public static void glGetProgramLocalParameterdvARB(int target, uint index, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetProgramLocalParameterdvARB(target, index, _params_);
        }
        
        public static void glGetProgramLocalParameterfvARB(int target, uint index, float* _params) {
            Pointers.glGetProgramLocalParameterfvARB(target, index, _params);
        }
        
        public static void glGetProgramLocalParameterfvARB(int target, uint index, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramLocalParameterfvARB(target, index, _params_);
        }
        
        public static void glGetProgramNamedParameterdvNV(uint id, int len, byte* name, double* _params) {
            Pointers.glGetProgramNamedParameterdvNV(id, len, name, _params);
        }
        
        public static void glGetProgramNamedParameterdvNV(uint id, int len, byte* name, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetProgramNamedParameterdvNV(id, len, name, _params_);
        }
        
        public static void glGetProgramNamedParameterdvNV(uint id, int len, out byte name, double* _params) {
            fixed(byte* name_ = &name)
                Pointers.glGetProgramNamedParameterdvNV(id, len, name_, _params);
        }
        
        public static void glGetProgramNamedParameterdvNV(uint id, int len, out byte name, double[] _params) {
            fixed(byte* name_ = &name)
            fixed(double* _params_ = &_params[0])
                Pointers.glGetProgramNamedParameterdvNV(id, len, name_, _params_);
        }
        
        public static void glGetProgramNamedParameterfvNV(uint id, int len, byte* name, float* _params) {
            Pointers.glGetProgramNamedParameterfvNV(id, len, name, _params);
        }
        
        public static void glGetProgramNamedParameterfvNV(uint id, int len, byte* name, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramNamedParameterfvNV(id, len, name, _params_);
        }
        
        public static void glGetProgramNamedParameterfvNV(uint id, int len, out byte name, float* _params) {
            fixed(byte* name_ = &name)
                Pointers.glGetProgramNamedParameterfvNV(id, len, name_, _params);
        }
        
        public static void glGetProgramNamedParameterfvNV(uint id, int len, out byte name, float[] _params) {
            fixed(byte* name_ = &name)
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramNamedParameterfvNV(id, len, name_, _params_);
        }
        
        public static void glGetProgramParameterdvNV(int target, uint index, int pname, double* _params) {
            Pointers.glGetProgramParameterdvNV(target, index, pname, _params);
        }
        
        public static void glGetProgramParameterdvNV(int target, uint index, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetProgramParameterdvNV(target, index, pname, _params_);
        }
        
        public static void glGetProgramParameterfvNV(int target, uint index, int pname, float* _params) {
            Pointers.glGetProgramParameterfvNV(target, index, pname, _params);
        }
        
        public static void glGetProgramParameterfvNV(int target, uint index, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramParameterfvNV(target, index, pname, _params_);
        }
        
        /// <summary>
        /// retrieve the info log string from a program pipeline object
        /// <para>
        /// glGetProgramPipelineInfoLog retrieves the info log for the program pipeline object pipeline. The
        /// info log, including its null terminator, is written into the array of characters whose address is
        /// given by infoLog. The maximum number of characters that may be written into infoLog is given by
        /// bufSize, and the actual number of characters written into infoLog is returned in the integer whose
        /// address is given by length. If length is NULL, no length is returned
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object from which to retrieve the info log.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters, including the null terminator, that may be written into
        /// infoLog.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable into which will be written the number of characters written into
        /// infoLog.
        /// </param>
        /// <param name="infoLog">
        /// Specifies the address of a variable into which will be written the number of characters written into
        /// infoLog.
        /// </param>
        public static void glGetProgramPipelineInfoLog(uint pipeline, int bufSize, int* length, StringBuilder infoLog) {
            Pointers.glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
        }
        
        /// <summary>
        /// retrieve the info log string from a program pipeline object
        /// <para>
        /// glGetProgramPipelineInfoLog retrieves the info log for the program pipeline object pipeline. The
        /// info log, including its null terminator, is written into the array of characters whose address is
        /// given by infoLog. The maximum number of characters that may be written into infoLog is given by
        /// bufSize, and the actual number of characters written into infoLog is returned in the integer whose
        /// address is given by length. If length is NULL, no length is returned
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object from which to retrieve the info log.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the maximum number of characters, including the null terminator, that may be written into
        /// infoLog.
        /// </param>
        /// <param name="length">
        /// Specifies the address of a variable into which will be written the number of characters written into
        /// infoLog.
        /// </param>
        /// <param name="infoLog">
        /// Specifies the address of a variable into which will be written the number of characters written into
        /// infoLog.
        /// </param>
        public static void glGetProgramPipelineInfoLog(uint pipeline, int bufSize, out int length, StringBuilder infoLog) {
            fixed(int* length_ = &length)
                Pointers.glGetProgramPipelineInfoLog(pipeline, bufSize, length_, infoLog);
        }
        
        public static void glGetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, int* length, StringBuilder infoLog) {
            Pointers.glGetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
        }
        
        public static void glGetProgramPipelineInfoLogEXT(uint pipeline, int bufSize, out int length, StringBuilder infoLog) {
            fixed(int* length_ = &length)
                Pointers.glGetProgramPipelineInfoLogEXT(pipeline, bufSize, length_, infoLog);
        }
        
        /// <summary>
        /// retrieve properties of a program pipeline object
        /// <para>
        /// glGetProgramPipelineiv retrieves the value of a property of the program pipeline object pipeline.
        /// pname specifies the name of the parameter whose value to retrieve. The value of the parameter is
        /// written to the variable whose address is given by params
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable into which will be written the value or values of pname for
        /// pipeline.
        /// </param>
        public static void glGetProgramPipelineiv(uint pipeline, int pname, int* _params) {
            Pointers.glGetProgramPipelineiv(pipeline, pname, _params);
        }
        
        /// <summary>
        /// retrieve properties of a program pipeline object
        /// <para>
        /// glGetProgramPipelineiv retrieves the value of a property of the program pipeline object pipeline.
        /// pname specifies the name of the parameter whose value to retrieve. The value of the parameter is
        /// written to the variable whose address is given by params
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object whose parameter retrieve.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to retrieve.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable into which will be written the value or values of pname for
        /// pipeline.
        /// </param>
        public static void glGetProgramPipelineiv(uint pipeline, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramPipelineiv(pipeline, pname, _params_);
        }
        
        public static void glGetProgramPipelineivEXT(uint pipeline, int pname, int* _params) {
            Pointers.glGetProgramPipelineivEXT(pipeline, pname, _params);
        }
        
        public static void glGetProgramPipelineivEXT(uint pipeline, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramPipelineivEXT(pipeline, pname, _params_);
        }
        
        /// <summary>
        /// query the index of a named resource within a program
        /// <para>
        /// glGetProgramResourceIndex returns the unsigned integer index assigned to a resource named name in
        /// the interface type programInterface of program object program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="name">
        /// The name of the resource to query the index of.
        /// </param>
        public static uint glGetProgramResourceIndex(uint program, int programInterface, string name) {
            return Pointers.glGetProgramResourceIndex(program, programInterface, name);
        }
        
        /// <summary>
        /// query the location of a named resource within a program
        /// <para>
        /// glGetProgramResourceLocation returns the location assigned to the variable named name in interface
        /// programInterface of program object program. program must be the name of a program that has been
        /// linked successfully. programInterface must be one of GL_UNIFORM, GL_PROGRAM_INPUT,
        /// GL_PROGRAM_OUTPUT, GL_VERTEX_SUBROUTINE_UNIFORM, GL_TESS_CONTROL_SUBROUTINE_UNIFORM,
        /// GL_TESS_EVALUATION_SUBROUTINE_UNIFORM, GL_GEOMETRY_SUBROUTINE_UNIFORM,
        /// GL_FRAGMENT_SUBROUTINE_UNIFORM, GL_COMPUTE_SUBROUTINE_UNIFORM, or GL_TRANSFORM_FEEDBACK_BUFFER
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="name">
        /// The name of the resource to query the location of.
        /// </param>
        public static int glGetProgramResourceLocation(uint program, int programInterface, string name) {
            return Pointers.glGetProgramResourceLocation(program, programInterface, name);
        }
        
        /// <summary>
        /// query the fragment color index of a named variable within a program
        /// <para>
        /// glGetProgramResourceLocationIndex returns the fragment color index assigned to the variable named
        /// name in interface programInterface of program object program. program must be the name of a program
        /// that has been linked successfully. programInterface must be GL_PROGRAM_OUTPUT
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="name">
        /// The name of the resource to query the location of.
        /// </param>
        public static int glGetProgramResourceLocationIndex(uint program, int programInterface, string name) {
            return Pointers.glGetProgramResourceLocationIndex(program, programInterface, name);
        }
        
        public static int glGetProgramResourceLocationIndexEXT(uint program, int programInterface, string name) {
            return Pointers.glGetProgramResourceLocationIndexEXT(program, programInterface, name);
        }
        
        /// <summary>
        /// query the name of an indexed resource within a program
        /// <para>
        /// glGetProgramResourceName retrieves the name string assigned to the single active resource with an
        /// index of index in the interface programInterface of program object program. index must be less than
        /// the number of entries in the active resource list for programInterface
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the indexed resource.
        /// </param>
        /// <param name="index">
        /// The index of the resource within programInterface of program.
        /// </param>
        /// <param name="bufSize">
        /// The size of the character array whose address is given by name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        public static void glGetProgramResourceName(uint program, int programInterface, uint index, int bufSize, int* length, StringBuilder name) {
            Pointers.glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
        }
        
        /// <summary>
        /// query the name of an indexed resource within a program
        /// <para>
        /// glGetProgramResourceName retrieves the name string assigned to the single active resource with an
        /// index of index in the interface programInterface of program object program. index must be less than
        /// the number of entries in the active resource list for programInterface
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the indexed resource.
        /// </param>
        /// <param name="index">
        /// The index of the resource within programInterface of program.
        /// </param>
        /// <param name="bufSize">
        /// The size of the character array whose address is given by name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the length of the resource name.
        /// </param>
        public static void glGetProgramResourceName(uint program, int programInterface, uint index, int bufSize, out int length, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetProgramResourceName(program, programInterface, index, bufSize, length_, name);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, int* length, float* _params) {
            Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length, _params);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, int* length, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length, _params_);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, int[] length, float* _params) {
            fixed(int* length_ = &length[0])
                Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length_, _params);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, int[] length, float[] _params) {
            fixed(int* length_ = &length[0])
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props, bufSize, length_, _params_);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, int* length, float* _params) {
            fixed(uint* props_ = &props[0])
                Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props_, bufSize, length, _params);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, int* length, float[] _params) {
            fixed(uint* props_ = &props[0])
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props_, bufSize, length, _params_);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, int[] length, float* _params) {
            fixed(uint* props_ = &props[0])
            fixed(int* length_ = &length[0])
                Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props_, bufSize, length_, _params);
        }
        
        public static void glGetProgramResourcefvNV(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, int[] length, float[] _params) {
            fixed(uint* props_ = &props[0])
            fixed(int* length_ = &length[0])
            fixed(float* _params_ = &_params[0])
                Pointers.glGetProgramResourcefvNV(program, programInterface, index, propCount, props_, bufSize, length_, _params_);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, int* length, int* _params) {
            Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, _params);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, int* length, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length, _params_);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, out int length, int* _params) {
            fixed(int* length_ = &length)
                Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length_, _params);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint* props, int bufSize, out int length, int[] _params) {
            fixed(int* length_ = &length)
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props, bufSize, length_, _params_);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, int* length, int* _params) {
            fixed(uint* props_ = &props[0])
                Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props_, bufSize, length, _params);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, int* length, int[] _params) {
            fixed(uint* props_ = &props[0])
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props_, bufSize, length, _params_);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, out int length, int* _params) {
            fixed(uint* props_ = &props[0])
            fixed(int* length_ = &length)
                Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props_, bufSize, length_, _params);
        }
        
        /// <summary>
        /// retrieve values for multiple properties of a single active resource within a program object
        /// <para>
        /// glGetProgramResourceiv returns values for multiple properties of a single active resource with an
        /// index of index in the interface programInterface of program object program. For each resource,
        /// values for propCount properties specified by the array props are returned. propCount may not be
        /// zero. An error is generated if any value in props is not one of the properties described immediately
        /// belowor if any value in props is not allowed for programInterface. The set of allowed
        /// programInterface values for each property can be found in the following table:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object whose resources to query.
        /// </param>
        /// <param name="programInterface">
        /// A token identifying the interface within program containing the resource named name.
        /// </param>
        /// <param name="index"> </param>
        /// <param name="propCount"> </param>
        /// <param name="props"> </param>
        /// <param name="bufSize"> </param>
        /// <param name="length"> </param>
        /// <param name="_params"> </param>
        public static void glGetProgramResourceiv(uint program, int programInterface, uint index, int propCount, uint[] props, int bufSize, out int length, int[] _params) {
            fixed(uint* props_ = &props[0])
            fixed(int* length_ = &length)
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramResourceiv(program, programInterface, index, propCount, props_, bufSize, length_, _params_);
        }
        
        /// <summary>
        /// retrieve properties of a program object corresponding to a specified shader stage
        /// <para>
        /// glGetProgramStage queries a parameter of a shader stage attached to a program object. program
        /// contains the name of the program to which the shader is attached. shadertype specifies the stage
        /// from which to query the parameter. pname specifies which parameter should be queried. The value or
        /// values of the parameter to be queried is returned in the variable whose address is given in values
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a variable into which the queried value or values will be placed.
        /// </param>
        public static void glGetProgramStageiv(uint program, int shadertype, int pname, int* values) {
            Pointers.glGetProgramStageiv(program, shadertype, pname, values);
        }
        
        /// <summary>
        /// retrieve properties of a program object corresponding to a specified shader stage
        /// <para>
        /// glGetProgramStage queries a parameter of a shader stage attached to a program object. program
        /// contains the name of the program to which the shader is attached. shadertype specifies the stage
        /// from which to query the parameter. pname specifies which parameter should be queried. The value or
        /// values of the parameter to be queried is returned in the variable whose address is given in values
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a variable into which the queried value or values will be placed.
        /// </param>
        public static void glGetProgramStageiv(uint program, int shadertype, int pname, out int values) {
            fixed(int* values_ = &values)
                Pointers.glGetProgramStageiv(program, shadertype, pname, values_);
        }
        
        /// <summary>
        /// retrieve properties of a program object corresponding to a specified shader stage
        /// <para>
        /// glGetProgramStage queries a parameter of a shader stage attached to a program object. program
        /// contains the name of the program to which the shader is attached. shadertype specifies the stage
        /// from which to query the parameter. pname specifies which parameter should be queried. The value or
        /// values of the parameter to be queried is returned in the variable whose address is given in values
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a variable into which the queried value or values will be placed.
        /// </param>
        public static void glGetProgramStageiv(uint program, Enums.ShaderType shadertype, int pname, int* values) {
            Pointers.glGetProgramStageiv(program, (int)shadertype, pname, values);
        }
        
        /// <summary>
        /// retrieve properties of a program object corresponding to a specified shader stage
        /// <para>
        /// glGetProgramStage queries a parameter of a shader stage attached to a program object. program
        /// contains the name of the program to which the shader is attached. shadertype specifies the stage
        /// from which to query the parameter. pname specifies which parameter should be queried. The value or
        /// values of the parameter to be queried is returned in the variable whose address is given in values
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for the subroutine parameter. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the shader to query. pname must be GL_ACTIVE_SUBROUTINE_UNIFORMS,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS, GL_ACTIVE_SUBROUTINES,
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_MAX_LENGTH, or GL_ACTIVE_SUBROUTINE_MAX_LENGTH.
        /// </param>
        /// <param name="values">
        /// Specifies the address of a variable into which the queried value or values will be placed.
        /// </param>
        public static void glGetProgramStageiv(uint program, Enums.ShaderType shadertype, int pname, out int values) {
            fixed(int* values_ = &values)
                Pointers.glGetProgramStageiv(program, (int)shadertype, pname, values_);
        }
        
        public static void glGetProgramStringARB(int target, int pname, IntPtr _string) {
            Pointers.glGetProgramStringARB(target, pname, _string);
        }
        
        public static void glGetProgramStringNV(uint id, int pname, byte* program) {
            Pointers.glGetProgramStringNV(id, pname, program);
        }
        
        public static void glGetProgramStringNV(uint id, int pname, byte[] program) {
            fixed(byte* program_ = &program[0])
                Pointers.glGetProgramStringNV(id, pname, program_);
        }
        
        public static void glGetProgramSubroutineParameteruivNV(int target, uint index, uint* param) {
            Pointers.glGetProgramSubroutineParameteruivNV(target, index, param);
        }
        
        public static void glGetProgramSubroutineParameteruivNV(int target, uint index, uint[] param) {
            fixed(uint* param_ = &param[0])
                Pointers.glGetProgramSubroutineParameteruivNV(target, index, param_);
        }
        
        /// <summary>
        /// Returns a parameter from a program object
        /// <para>
        /// glGetProgram returns in params the value of a parameter for a specific program object. The following
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS,
        /// GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS,
        /// GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS,
        /// GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE
        /// GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS,
        /// GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and
        /// GL_GEOMETRY_OUTPUT_TYPE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested object parameter.
        /// </param>
        public static void glGetProgramiv(uint program, int pname, int* _params) {
            Pointers.glGetProgramiv(program, pname, _params);
        }
        
        /// <summary>
        /// Returns a parameter from a program object
        /// <para>
        /// glGetProgram returns in params the value of a parameter for a specific program object. The following
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are GL_DELETE_STATUS, GL_LINK_STATUS,
        /// GL_VALIDATE_STATUS, GL_INFO_LOG_LENGTH, GL_ATTACHED_SHADERS, GL_ACTIVE_ATOMIC_COUNTER_BUFFERS,
        /// GL_ACTIVE_ATTRIBUTES, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, GL_ACTIVE_UNIFORMS, GL_ACTIVE_UNIFORM_BLOCKS,
        /// GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH, GL_ACTIVE_UNIFORM_MAX_LENGTH, GL_COMPUTE_WORK_GROUP_SIZE
        /// GL_PROGRAM_BINARY_LENGTH, GL_TRANSFORM_FEEDBACK_BUFFER_MODE, GL_TRANSFORM_FEEDBACK_VARYINGS,
        /// GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, and
        /// GL_GEOMETRY_OUTPUT_TYPE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested object parameter.
        /// </param>
        public static void glGetProgramiv(uint program, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramiv(program, pname, _params_);
        }
        
        public static void glGetProgramivARB(int target, int pname, int* _params) {
            Pointers.glGetProgramivARB(target, pname, _params);
        }
        
        public static void glGetProgramivARB(int target, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetProgramivARB(target, pname, _params_);
        }
        
        public static void glGetProgramivNV(uint id, int pname, int* _params) {
            Pointers.glGetProgramivNV(id, pname, _params);
        }
        
        public static void glGetProgramivNV(uint id, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetProgramivNV(id, pname, _params_);
        }
        
        public static void glGetQueryBufferObjecti64v(uint id, uint buffer, int pname, uint offset) {
            Pointers.glGetQueryBufferObjecti64v(id, buffer, pname, offset);
        }
        
        public static void glGetQueryBufferObjectiv(uint id, uint buffer, int pname, uint offset) {
            Pointers.glGetQueryBufferObjectiv(id, buffer, pname, offset);
        }
        
        public static void glGetQueryBufferObjectui64v(uint id, uint buffer, int pname, uint offset) {
            Pointers.glGetQueryBufferObjectui64v(id, buffer, pname, offset);
        }
        
        public static void glGetQueryBufferObjectuiv(uint id, uint buffer, int pname, uint offset) {
            Pointers.glGetQueryBufferObjectuiv(id, buffer, pname, offset);
        }
        
        /// <summary>
        /// return parameters of an indexed query object target
        /// <para>
        /// glGetQueryIndexediv returns in params a selected parameter of the indexed query object target
        /// specified by target and index. index specifies the index of the query object target and must be
        /// between zero and a target-specific maxiumum
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the query object target.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY
        /// or GL_QUERY_COUNTER_BITS.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetQueryIndexediv(int target, uint index, int pname, int* _params) {
            Pointers.glGetQueryIndexediv(target, index, pname, _params);
        }
        
        /// <summary>
        /// return parameters of an indexed query object target
        /// <para>
        /// glGetQueryIndexediv returns in params a selected parameter of the indexed query object target
        /// specified by target and index. index specifies the index of the query object target and must be
        /// between zero and a target-specific maxiumum
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the query object target.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY
        /// or GL_QUERY_COUNTER_BITS.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetQueryIndexediv(int target, uint index, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetQueryIndexediv(target, index, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjecti64v(uint id, int pname, long* _params) {
            Pointers.glGetQueryObjecti64v(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjecti64v(uint id, int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetQueryObjecti64v(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjecti64vEXT(uint id, int pname, long* _params) {
            Pointers.glGetQueryObjecti64vEXT(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjecti64vEXT(uint id, int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetQueryObjecti64vEXT(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectiv(uint id, int pname, int* _params) {
            Pointers.glGetQueryObjectiv(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectiv(uint id, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetQueryObjectiv(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectivARB(uint id, int pname, int* _params) {
            Pointers.glGetQueryObjectivARB(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectivARB(uint id, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetQueryObjectivARB(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectivEXT(uint id, int pname, int* _params) {
            Pointers.glGetQueryObjectivEXT(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectivEXT(uint id, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetQueryObjectivEXT(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectui64v(uint id, int pname, ulong* _params) {
            Pointers.glGetQueryObjectui64v(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectui64v(uint id, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetQueryObjectui64v(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectui64vEXT(uint id, int pname, ulong* _params) {
            Pointers.glGetQueryObjectui64vEXT(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectui64vEXT(uint id, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetQueryObjectui64vEXT(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectuiv(uint id, int pname, uint* _params) {
            Pointers.glGetQueryObjectuiv(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectuiv(uint id, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetQueryObjectuiv(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectuivARB(uint id, int pname, uint* _params) {
            Pointers.glGetQueryObjectuivARB(id, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object
        /// <para>
        /// glGetQueryObject returns in params a selected parameter of the query object specified by id
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies the name of a query object.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object parameter. Accepted values are GL_QUERY_RESULT or
        /// GL_QUERY_RESULT_AVAILABLE.
        /// </param>
        /// <param name="_params">
        /// If a buffer is bound to the GL_QUERY_RESULT_BUFFER target, then params is treated as an offset to a
        /// location within that buffer's data store to receive the result of the query. If no buffer is bound
        /// to GL_QUERY_RESULT_BUFFER, then params is treated as an address in client memory of a variable to
        /// receive the resulting data.
        /// </param>
        public static void glGetQueryObjectuivARB(uint id, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetQueryObjectuivARB(id, pname, _params_);
        }
        
        public static void glGetQueryObjectuivEXT(uint id, int pname, uint* _params) {
            Pointers.glGetQueryObjectuivEXT(id, pname, _params);
        }
        
        public static void glGetQueryObjectuivEXT(uint id, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetQueryObjectuivEXT(id, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object target
        /// <para>
        /// glGetQueryiv returns in params a selected parameter of the query object target specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY
        /// or GL_QUERY_COUNTER_BITS.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetQueryiv(int target, int pname, int* _params) {
            Pointers.glGetQueryiv(target, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object target
        /// <para>
        /// glGetQueryiv returns in params a selected parameter of the query object target specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY
        /// or GL_QUERY_COUNTER_BITS.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetQueryiv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetQueryiv(target, pname, _params_);
        }
        
        /// <summary>
        /// return parameters of a query object target
        /// <para>
        /// glGetQueryiv returns in params a selected parameter of the query object target specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY
        /// or GL_QUERY_COUNTER_BITS.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetQueryivARB(int target, int pname, int* _params) {
            Pointers.glGetQueryivARB(target, pname, _params);
        }
        
        /// <summary>
        /// return parameters of a query object target
        /// <para>
        /// glGetQueryiv returns in params a selected parameter of the query object target specified by target
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a query object target. Must be GL_SAMPLES_PASSED, GL_ANY_SAMPLES_PASSED,
        /// GL_ANY_SAMPLES_PASSED_CONSERVATIVE GL_PRIMITIVES_GENERATED,
        /// GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN, GL_TIME_ELAPSED, or GL_TIMESTAMP.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a query object target parameter. Accepted values are GL_CURRENT_QUERY
        /// or GL_QUERY_COUNTER_BITS.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetQueryivARB(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetQueryivARB(target, pname, _params_);
        }
        
        public static void glGetQueryivEXT(int target, int pname, int* _params) {
            Pointers.glGetQueryivEXT(target, pname, _params);
        }
        
        public static void glGetQueryivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetQueryivEXT(target, pname, _params_);
        }
        
        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>
        /// glGetRenderbufferParameteriv and glGetNamedRenderbufferParameteriv query parameters of a specified
        /// renderbuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv.
        /// target must be GL_RENDERBUFFER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the renderbuffer object to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for the renderbuffer object.
        /// </param>
        public static void glGetRenderbufferParameteriv(int target, int pname, int* _params) {
            Pointers.glGetRenderbufferParameteriv(target, pname, _params);
        }
        
        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>
        /// glGetRenderbufferParameteriv and glGetNamedRenderbufferParameteriv query parameters of a specified
        /// renderbuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv.
        /// target must be GL_RENDERBUFFER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the renderbuffer object to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for the renderbuffer object.
        /// </param>
        public static void glGetRenderbufferParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetRenderbufferParameteriv(target, pname, _params_);
        }
        
        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>
        /// glGetRenderbufferParameteriv and glGetNamedRenderbufferParameteriv query parameters of a specified
        /// renderbuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv.
        /// target must be GL_RENDERBUFFER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the renderbuffer object to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for the renderbuffer object.
        /// </param>
        public static void glGetRenderbufferParameterivEXT(int target, int pname, int* _params) {
            Pointers.glGetRenderbufferParameterivEXT(target, pname, _params);
        }
        
        /// <summary>
        /// query a named parameter of a renderbuffer object
        /// <para>
        /// glGetRenderbufferParameteriv and glGetNamedRenderbufferParameteriv query parameters of a specified
        /// renderbuffer object
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the renderbuffer object is bound for glGetRenderbufferParameteriv.
        /// target must be GL_RENDERBUFFER.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter of the renderbuffer object to query.
        /// </param>
        /// <param name="_params">
        /// Returns the value of parameter pname for the renderbuffer object.
        /// </param>
        public static void glGetRenderbufferParameterivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetRenderbufferParameterivEXT(target, pname, _params_);
        }
        
        public static void glGetRenderbufferParameterivOES(int target, int pname, int* _params) {
            Pointers.glGetRenderbufferParameterivOES(target, pname, _params);
        }
        
        public static void glGetRenderbufferParameterivOES(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetRenderbufferParameterivOES(target, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIiv(uint sampler, int pname, int* _params) {
            Pointers.glGetSamplerParameterIiv(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIiv(uint sampler, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetSamplerParameterIiv(sampler, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIivEXT(uint sampler, int pname, int* _params) {
            Pointers.glGetSamplerParameterIivEXT(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIivEXT(uint sampler, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetSamplerParameterIivEXT(sampler, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIivOES(uint sampler, int pname, int* _params) {
            Pointers.glGetSamplerParameterIivOES(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIivOES(uint sampler, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetSamplerParameterIivOES(sampler, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIuiv(uint sampler, int pname, uint* _params) {
            Pointers.glGetSamplerParameterIuiv(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIuiv(uint sampler, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetSamplerParameterIuiv(sampler, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIuivEXT(uint sampler, int pname, uint* _params) {
            Pointers.glGetSamplerParameterIuivEXT(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIuivEXT(uint sampler, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetSamplerParameterIuivEXT(sampler, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIuivOES(uint sampler, int pname, uint* _params) {
            Pointers.glGetSamplerParameterIuivOES(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterIuivOES(uint sampler, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetSamplerParameterIuivOES(sampler, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterfv(uint sampler, int pname, float* _params) {
            Pointers.glGetSamplerParameterfv(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameterfv(uint sampler, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetSamplerParameterfv(sampler, pname, _params_);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameteriv(uint sampler, int pname, int* _params) {
            Pointers.glGetSamplerParameteriv(sampler, pname, _params);
        }
        
        /// <summary>
        /// return sampler parameter values
        /// <para>
        /// glGetSamplerParameter returns in params the value or values of the sampler parameter specified as
        /// pname. sampler defines the target sampler, and must be the name of an existing sampler object,
        /// returned from a previous call to glGenSamplers. pname accepts the same symbols as
        /// glSamplerParameter, with the same interpretations:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies name of the sampler object from which to retrieve parameters.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T,
        /// GL_TEXTURE_WRAP_R, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_COMPARE_MODE, and GL_TEXTURE_COMPARE_FUNC are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the sampler parameters.
        /// </param>
        public static void glGetSamplerParameteriv(uint sampler, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetSamplerParameteriv(sampler, pname, _params_);
        }
        
        public static void glGetSemaphoreParameterui64vEXT(uint semaphore, int pname, ulong* _params) {
            Pointers.glGetSemaphoreParameterui64vEXT(semaphore, pname, _params);
        }
        
        public static void glGetSemaphoreParameterui64vEXT(uint semaphore, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetSemaphoreParameterui64vEXT(semaphore, pname, _params_);
        }
        
        /// <summary>
        /// get separable convolution filter kernel images
        /// <para>
        /// glGetSeparableFilter returns the two one-dimensional filter kernel images for the current separable
        /// 2D convolution filter. The row image is placed in row and the column image is placed in column
        /// according to the specifications in format and type. (In the current implementation, span is not
        /// affected in any way.) No pixel transfer operations are performed on the images, but the relevant
        /// pixel storage modes are applied
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The separable filter to be retrieved. Must be GL_SEPARABLE_2D.
        /// </param>
        /// <param name="format">
        /// Format of the output images. Must be one of GL_RED, GL_GREEN, GL_BLUE, GL_ALPHA, GL_RGB, GL_BGR
        /// GL_RGBA, GL_BGRA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// Data type of components in the output images. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="row">
        /// Pointer to storage for the row filter image.
        /// </param>
        /// <param name="column">
        /// Pointer to storage for the column filter image.
        /// </param>
        /// <param name="span">
        /// Pointer to storage for the span filter image (currently unused).
        /// </param>
        public static void glGetSeparableFilter(int target, int format, int type, IntPtr row, IntPtr column, IntPtr span) {
            Pointers.glGetSeparableFilter(target, format, type, row, column, span);
        }
        
        public static void glGetSeparableFilterEXT(int target, int format, int type, IntPtr row, IntPtr column, IntPtr span) {
            Pointers.glGetSeparableFilterEXT(target, format, type, row, column, span);
        }
        
        /// <summary>
        /// Returns the information log for a shader object
        /// <para>
        /// glGetShaderInfoLog returns the information log for the specified shader object. The information log
        /// for a shader object is modified when the shader is compiled. The string that is returned will be
        /// null terminated
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        public static void glGetShaderInfoLog(uint shader, int bufSize, int* length, StringBuilder infoLog) {
            Pointers.glGetShaderInfoLog(shader, bufSize, length, infoLog);
        }
        
        /// <summary>
        /// Returns the information log for a shader object
        /// <para>
        /// glGetShaderInfoLog returns the information log for the specified shader object. The information log
        /// for a shader object is modified when the shader is compiled. The string that is returned will be
        /// null terminated
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object whose information log is to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned information log.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in infoLog (excluding the null terminator).
        /// </param>
        /// <param name="infoLog">
        /// Specifies an array of characters that is used to return the information log.
        /// </param>
        public static void glGetShaderInfoLog(uint shader, int bufSize, out int length, StringBuilder infoLog) {
            fixed(int* length_ = &length)
                Pointers.glGetShaderInfoLog(shader, bufSize, length_, infoLog);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int* range, int* precision) {
            Pointers.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int* range, out int precision) {
            fixed(int* precision_ = &precision)
                Pointers.glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision_);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, int* precision) {
            fixed(int* range_ = &range[0])
                Pointers.glGetShaderPrecisionFormat(shadertype, precisiontype, range_, precision);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(int shadertype, int precisiontype, int[] range, out int precision) {
            fixed(int* range_ = &range[0])
            fixed(int* precision_ = &precision)
                Pointers.glGetShaderPrecisionFormat(shadertype, precisiontype, range_, precision_);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(Enums.ShaderType shadertype, int precisiontype, int* range, int* precision) {
            Pointers.glGetShaderPrecisionFormat((int)shadertype, precisiontype, range, precision);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(Enums.ShaderType shadertype, int precisiontype, int* range, out int precision) {
            fixed(int* precision_ = &precision)
                Pointers.glGetShaderPrecisionFormat((int)shadertype, precisiontype, range, precision_);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(Enums.ShaderType shadertype, int precisiontype, int[] range, int* precision) {
            fixed(int* range_ = &range[0])
                Pointers.glGetShaderPrecisionFormat((int)shadertype, precisiontype, range_, precision);
        }
        
        /// <summary>
        /// retrieve the range and precision for numeric formats supported by the shader compiler
        /// <para>
        /// glGetShaderPrecisionFormat retrieves the numeric range and precision for the implementation's
        /// representation of quantities in different numeric formats in specified shader type. shaderType
        /// specifies the type of shader for which the numeric precision and range is to be retrieved and must
        /// be one of GL_VERTEX_SHADER or GL_FRAGMENT_SHADER. precisionType specifies the numeric format to
        /// query and must be one of GL_LOW_FLOAT, GL_MEDIUM_FLOAT GL_HIGH_FLOAT, GL_LOW_INT, GL_MEDIUM_INT, or
        /// GL_HIGH_INT
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the type of shader whose precision to query. shaderType must be GL_VERTEX_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="precisiontype">
        /// Specifies the numeric format whose precision and range to query.
        /// </param>
        /// <param name="range">
        /// Specifies the address of array of two integers into which encodings of the implementation's numeric
        /// range are returned.
        /// </param>
        /// <param name="precision">
        /// Specifies the address of an integer into which the numeric precision of the implementation is
        /// written.
        /// </param>
        public static void glGetShaderPrecisionFormat(Enums.ShaderType shadertype, int precisiontype, int[] range, out int precision) {
            fixed(int* range_ = &range[0])
            fixed(int* precision_ = &precision)
                Pointers.glGetShaderPrecisionFormat((int)shadertype, precisiontype, range_, precision_);
        }
        
        /// <summary>
        /// Returns the source code string from a shader object
        /// <para>
        /// glGetShaderSource returns the concatenation of the source code strings from the shader object
        /// specified by shader. The source code strings for a shader object are the result of a previous call
        /// to glShaderSource. The string returned by the function will be null terminated
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        public static void glGetShaderSource(uint shader, int bufSize, int* length, StringBuilder source) {
            Pointers.glGetShaderSource(shader, bufSize, length, source);
        }
        
        /// <summary>
        /// Returns the source code string from a shader object
        /// <para>
        /// glGetShaderSource returns the concatenation of the source code strings from the shader object
        /// specified by shader. The source code strings for a shader object are the result of a previous call
        /// to glShaderSource. The string returned by the function will be null terminated
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        public static void glGetShaderSource(uint shader, int bufSize, out int length, StringBuilder source) {
            fixed(int* length_ = &length)
                Pointers.glGetShaderSource(shader, bufSize, length_, source);
        }
        
        /// <summary>
        /// Returns the source code string from a shader object
        /// <para>
        /// glGetShaderSource returns the concatenation of the source code strings from the shader object
        /// specified by shader. The source code strings for a shader object are the result of a previous call
        /// to glShaderSource. The string returned by the function will be null terminated
        /// </para>
        /// </summary>
        /// <param name="obj">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        public static void glGetShaderSourceARB(uint obj, int maxLength, int* length, StringBuilder source) {
            Pointers.glGetShaderSourceARB(obj, maxLength, length, source);
        }
        
        /// <summary>
        /// Returns the source code string from a shader object
        /// <para>
        /// glGetShaderSource returns the concatenation of the source code strings from the shader object
        /// specified by shader. The source code strings for a shader object are the result of a previous call
        /// to glShaderSource. The string returned by the function will be null terminated
        /// </para>
        /// </summary>
        /// <param name="obj">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="maxLength">
        /// Specifies the size of the character buffer for storing the returned source code string.
        /// </param>
        /// <param name="length">
        /// Returns the length of the string returned in source (excluding the null terminator).
        /// </param>
        /// <param name="source">
        /// Specifies an array of characters that is used to return the source code string.
        /// </param>
        public static void glGetShaderSourceARB(uint obj, int maxLength, out int length, StringBuilder source) {
            fixed(int* length_ = &length)
                Pointers.glGetShaderSourceARB(obj, maxLength, length_, source);
        }
        
        /// <summary>
        /// Returns a parameter from a shader object
        /// <para>
        /// glGetShader returns in params the value of a parameter for a specific shader object. The following
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS,
        /// GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </param>
        /// <param name="_params">
        /// Returns the requested object parameter.
        /// </param>
        public static void glGetShaderiv(uint shader, int pname, int* _params) {
            Pointers.glGetShaderiv(shader, pname, _params);
        }
        
        /// <summary>
        /// Returns a parameter from a shader object
        /// <para>
        /// glGetShader returns in params the value of a parameter for a specific shader object. The following
        /// parameters are defined:
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the shader object to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the object parameter. Accepted symbolic names are GL_SHADER_TYPE, GL_DELETE_STATUS,
        /// GL_COMPILE_STATUS, GL_INFO_LOG_LENGTH, GL_SHADER_SOURCE_LENGTH.
        /// </param>
        /// <param name="_params">
        /// Returns the requested object parameter.
        /// </param>
        public static void glGetShaderiv(uint shader, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetShaderiv(shader, pname, _params_);
        }
        
        public static void glGetSharpenTexFuncSGIS(int target, float* points) {
            Pointers.glGetSharpenTexFuncSGIS(target, points);
        }
        
        public static void glGetSharpenTexFuncSGIS(int target, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glGetSharpenTexFuncSGIS(target, points_);
        }
        
        public static ushort glGetStageIndexNV(int shadertype) {
            return Pointers.glGetStageIndexNV(shadertype);
        }
        
        public static ushort glGetStageIndexNV(Enums.ShaderType shadertype) {
            return Pointers.glGetStageIndexNV((int)shadertype);
        }
        
        /// <summary>
        /// return a string describing the current GL connection
        /// <para>
        /// glGetString returns a pointer to a static string describing some aspect of the current GL
        /// connection. name can be one of the following:
        /// </para>
        /// </summary>
        /// <param name="name">
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or
        /// GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </param>
        public static string glGetString(int name) {
            return PtrToStringUTF8(Pointers.glGetString(name));
        }
        
        /// <summary>
        /// return a string describing the current GL connection
        /// <para>
        /// glGetString returns a pointer to a static string describing some aspect of the current GL
        /// connection. name can be one of the following:
        /// </para>
        /// </summary>
        /// <param name="name">
        /// Specifies a symbolic constant, one of GL_VENDOR, GL_RENDERER, GL_VERSION, or
        /// GL_SHADING_LANGUAGE_VERSION. Additionally, glGetStringi accepts the GL_EXTENSIONS token.
        /// </param>
        /// <param name="index">
        /// For glGetStringi, specifies the index of the string to return.
        /// </param>
        public static string glGetStringi(int name, uint index) {
            return PtrToStringUTF8(Pointers.glGetStringi(name, index));
        }
        
        /// <summary>
        /// retrieve the index of a subroutine uniform of a given shader stage within a program
        /// <para>
        /// glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage attached to a
        /// program object. program contains the name of the program to which the shader is attached. shadertype
        /// specifies the stage from which to query shader subroutine index. name contains the null-terminated
        /// name of the subroutine uniform whose name to query
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="name">
        /// Specifies the name of the subroutine uniform whose index to query.
        /// </param>
        public static uint glGetSubroutineIndex(uint program, int shadertype, string name) {
            return Pointers.glGetSubroutineIndex(program, shadertype, name);
        }
        
        /// <summary>
        /// retrieve the index of a subroutine uniform of a given shader stage within a program
        /// <para>
        /// glGetSubroutineIndex returns the index of a subroutine uniform within a shader stage attached to a
        /// program object. program contains the name of the program to which the shader is attached. shadertype
        /// specifies the stage from which to query shader subroutine index. name contains the null-terminated
        /// name of the subroutine uniform whose name to query
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="name">
        /// Specifies the name of the subroutine uniform whose index to query.
        /// </param>
        public static uint glGetSubroutineIndex(uint program, Enums.ShaderType shadertype, string name) {
            return Pointers.glGetSubroutineIndex(program, (int)shadertype, name);
        }
        
        /// <summary>
        /// retrieve the location of a subroutine uniform of a given shader stage within a program
        /// <para>
        /// glGetSubroutineUniformLocation returns the location of the subroutine uniform variable name in the
        /// shader stage of type shadertype attached to program, with behavior otherwise identical to
        /// glGetUniformLocation
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="name">
        /// Specifies the name of the subroutine uniform whose index to query.
        /// </param>
        public static int glGetSubroutineUniformLocation(uint program, int shadertype, string name) {
            return Pointers.glGetSubroutineUniformLocation(program, shadertype, name);
        }
        
        /// <summary>
        /// retrieve the location of a subroutine uniform of a given shader stage within a program
        /// <para>
        /// glGetSubroutineUniformLocation returns the location of the subroutine uniform variable name in the
        /// shader stage of type shadertype attached to program, with behavior otherwise identical to
        /// glGetUniformLocation
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of the program containing shader stage.
        /// </param>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="name">
        /// Specifies the name of the subroutine uniform whose index to query.
        /// </param>
        public static int glGetSubroutineUniformLocation(uint program, Enums.ShaderType shadertype, string name) {
            return Pointers.glGetSubroutineUniformLocation(program, (int)shadertype, name);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSynciv(IntPtr sync, int pname, int bufSize, int* length, int* values) {
            Pointers.glGetSynciv(sync, pname, bufSize, length, values);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSynciv(IntPtr sync, int pname, int bufSize, int* length, int[] values) {
            fixed(int* values_ = &values[0])
                Pointers.glGetSynciv(sync, pname, bufSize, length, values_);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSynciv(IntPtr sync, int pname, int bufSize, out int length, int* values) {
            fixed(int* length_ = &length)
                Pointers.glGetSynciv(sync, pname, bufSize, length_, values);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSynciv(IntPtr sync, int pname, int bufSize, out int length, int[] values) {
            fixed(int* length_ = &length)
            fixed(int* values_ = &values[0])
                Pointers.glGetSynciv(sync, pname, bufSize, length_, values_);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSyncivAPPLE(IntPtr sync, int pname, int bufSize, int* length, int* values) {
            Pointers.glGetSyncivAPPLE(sync, pname, bufSize, length, values);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSyncivAPPLE(IntPtr sync, int pname, int bufSize, int* length, int[] values) {
            fixed(int* values_ = &values[0])
                Pointers.glGetSyncivAPPLE(sync, pname, bufSize, length, values_);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSyncivAPPLE(IntPtr sync, int pname, int bufSize, int[] length, int* values) {
            fixed(int* length_ = &length[0])
                Pointers.glGetSyncivAPPLE(sync, pname, bufSize, length_, values);
        }
        
        /// <summary>
        /// query the properties of a sync object
        /// <para>
        /// glGetSynciv retrieves properties of a sync object. sync specifies the name of the sync object whose
        /// properties to retrieve
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose properties to query.
        /// </param>
        /// <param name="pname">
        /// Specifies the parameter whose value to retrieve from the sync object specified in sync.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer whose address is given in values.
        /// </param>
        /// <param name="length">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an variable to receive the number of integers placed in values.
        /// </param>
        public static void glGetSyncivAPPLE(IntPtr sync, int pname, int bufSize, int[] length, int[] values) {
            fixed(int* length_ = &length[0])
            fixed(int* values_ = &values[0])
                Pointers.glGetSyncivAPPLE(sync, pname, bufSize, length_, values_);
        }
        
        public static void glGetTexBumpParameterfvATI(int pname, float* param) {
            Pointers.glGetTexBumpParameterfvATI(pname, param);
        }
        
        public static void glGetTexBumpParameterfvATI(int pname, float[] param) {
            fixed(float* param_ = &param[0])
                Pointers.glGetTexBumpParameterfvATI(pname, param_);
        }
        
        public static void glGetTexBumpParameterivATI(int pname, int* param) {
            Pointers.glGetTexBumpParameterivATI(pname, param);
        }
        
        public static void glGetTexBumpParameterivATI(int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetTexBumpParameterivATI(pname, param_);
        }
        
        /// <summary>
        /// return texture environment parameters
        /// <para>
        /// glGetTexEnv returns in params selected values of a texture environment that was specified with
        /// glTexEnv. target specifies a texture environment
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA,
        /// GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexEnvfv(int target, int pname, float* _params) {
            Pointers.glGetTexEnvfv(target, pname, _params);
        }
        
        /// <summary>
        /// return texture environment parameters
        /// <para>
        /// glGetTexEnv returns in params selected values of a texture environment that was specified with
        /// glTexEnv. target specifies a texture environment
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA,
        /// GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexEnvfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTexEnvfv(target, pname, _params_);
        }
        
        /// <summary>
        /// return texture environment parameters
        /// <para>
        /// glGetTexEnv returns in params selected values of a texture environment that was specified with
        /// glTexEnv. target specifies a texture environment
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA,
        /// GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexEnviv(int target, int pname, int* _params) {
            Pointers.glGetTexEnviv(target, pname, _params);
        }
        
        /// <summary>
        /// return texture environment parameters
        /// <para>
        /// glGetTexEnv returns in params selected values of a texture environment that was specified with
        /// glTexEnv. target specifies a texture environment
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL, or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture environment parameter. Accepted values are
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA,
        /// GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexEnviv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexEnviv(target, pname, _params_);
        }
        
        public static void glGetTexEnvxv(int target, int pname, IntPtr* _params) {
            Pointers.glGetTexEnvxv(target, pname, _params);
        }
        
        public static void glGetTexEnvxv(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetTexEnvxv(target, pname, _params_);
        }
        
        public static void glGetTexEnvxvOES(int target, int pname, IntPtr* _params) {
            Pointers.glGetTexEnvxvOES(target, pname, _params);
        }
        
        public static void glGetTexEnvxvOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetTexEnvxvOES(target, pname, _params_);
        }
        
        public static void glGetTexFilterFuncSGIS(int target, int filter, float* weights) {
            Pointers.glGetTexFilterFuncSGIS(target, filter, weights);
        }
        
        public static void glGetTexFilterFuncSGIS(int target, int filter, float[] weights) {
            fixed(float* weights_ = &weights[0])
                Pointers.glGetTexFilterFuncSGIS(target, filter, weights_);
        }
        
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>
        /// glGetTexGen returns in params selected parameters of a texture coordinate generation function that
        /// was specified using glTexGen. coord names one of the (s, t, r, q) texture coordinates, using the
        /// symbolic constant GL_S, GL_T, GL_R, or GL_Q
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or
        /// the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexGendv(int coord, int pname, double* _params) {
            Pointers.glGetTexGendv(coord, pname, _params);
        }
        
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>
        /// glGetTexGen returns in params selected parameters of a texture coordinate generation function that
        /// was specified using glTexGen. coord names one of the (s, t, r, q) texture coordinates, using the
        /// symbolic constant GL_S, GL_T, GL_R, or GL_Q
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or
        /// the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexGendv(int coord, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetTexGendv(coord, pname, _params_);
        }
        
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>
        /// glGetTexGen returns in params selected parameters of a texture coordinate generation function that
        /// was specified using glTexGen. coord names one of the (s, t, r, q) texture coordinates, using the
        /// symbolic constant GL_S, GL_T, GL_R, or GL_Q
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or
        /// the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexGenfv(int coord, int pname, float* _params) {
            Pointers.glGetTexGenfv(coord, pname, _params);
        }
        
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>
        /// glGetTexGen returns in params selected parameters of a texture coordinate generation function that
        /// was specified using glTexGen. coord names one of the (s, t, r, q) texture coordinates, using the
        /// symbolic constant GL_S, GL_T, GL_R, or GL_Q
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or
        /// the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexGenfv(int coord, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTexGenfv(coord, pname, _params_);
        }
        
        public static void glGetTexGenfvOES(int coord, int pname, float* _params) {
            Pointers.glGetTexGenfvOES(coord, pname, _params);
        }
        
        public static void glGetTexGenfvOES(int coord, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTexGenfvOES(coord, pname, _params_);
        }
        
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>
        /// glGetTexGen returns in params selected parameters of a texture coordinate generation function that
        /// was specified using glTexGen. coord names one of the (s, t, r, q) texture coordinates, using the
        /// symbolic constant GL_S, GL_T, GL_R, or GL_Q
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or
        /// the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexGeniv(int coord, int pname, int* _params) {
            Pointers.glGetTexGeniv(coord, pname, _params);
        }
        
        /// <summary>
        /// return texture coordinate generation parameters
        /// <para>
        /// glGetTexGen returns in params selected parameters of a texture coordinate generation function that
        /// was specified using glTexGen. coord names one of the (s, t, r, q) texture coordinates, using the
        /// symbolic constant GL_S, GL_T, GL_R, or GL_Q
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the value(s) to be returned. Must be either GL_TEXTURE_GEN_MODE or
        /// the name of one of the texture generation plane equations: GL_OBJECT_PLANE or GL_EYE_PLANE.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexGeniv(int coord, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexGeniv(coord, pname, _params_);
        }
        
        public static void glGetTexGenivOES(int coord, int pname, int* _params) {
            Pointers.glGetTexGenivOES(coord, pname, _params);
        }
        
        public static void glGetTexGenivOES(int coord, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexGenivOES(coord, pname, _params_);
        }
        
        public static void glGetTexGenxvOES(int coord, int pname, IntPtr* _params) {
            Pointers.glGetTexGenxvOES(coord, pname, _params);
        }
        
        public static void glGetTexGenxvOES(int coord, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetTexGenxvOES(coord, pname, _params_);
        }
        
        /// <summary>
        /// return a texture image
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glGetTexImage and glGetnTexImage functions.
        /// GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY,
        /// GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, and GL_TEXTURE_CUBE_MAP_ARRAY are acceptable.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n
        /// is the nth mipmap reduction image.
        /// </param>
        /// <param name="format">
        /// Specifies a pixel format for the returned data. The supported formats are GL_STENCIL_INDEX,
        /// GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RG, GL_RGB, GL_RGBA, GL_BGR,
        /// GL_BGRA, GL_RED_INTEGER, GL_GREEN_INTEGER, GL_BLUE_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER,
        /// GL_RGBA_INTEGER, GL_BGR_INTEGER, GL_BGRA_INTEGER.
        /// </param>
        /// <param name="type">
        /// Specifies a pixel type for the returned data. The supported types are GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV,
        /// GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, and
        /// GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </param>
        /// <param name="pixels">
        /// Returns the texture image. Should be a pointer to an array of the type specified by type.
        /// </param>
        public static void glGetTexImage(int target, int level, int format, int type, IntPtr pixels) {
            Pointers.glGetTexImage(target, level, format, type, pixels);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glGetTexLevelParameterfv and
        /// glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D,
        /// GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
        /// GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D,
        /// GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,
        /// GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY,
        /// GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n
        /// is the nth mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT,
        /// GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
        /// GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED,
        /// GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexLevelParameterfv(int target, int level, int pname, float* _params) {
            Pointers.glGetTexLevelParameterfv(target, level, pname, _params);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glGetTexLevelParameterfv and
        /// glGetTexLevelParameteriv functions. Must be one of the following values: GL_TEXTURE_1D,
        /// GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_RECTANGLE,
        /// GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_CUBE_MAP_POSITIVE_X,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, GL_PROXY_TEXTURE_1D,
        /// GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_3D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY,
        /// GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE, GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY,
        /// GL_PROXY_TEXTURE_CUBE_MAP, or GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number of the desired image. Level 0 is the base image level. Level n
        /// is the nth mipmap reduction image.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. GL_TEXTURE_WIDTH, GL_TEXTURE_HEIGHT,
        /// GL_TEXTURE_DEPTH, GL_TEXTURE_INTERNAL_FORMAT, GL_TEXTURE_RED_SIZE, GL_TEXTURE_GREEN_SIZE,
        /// GL_TEXTURE_BLUE_SIZE, GL_TEXTURE_ALPHA_SIZE, GL_TEXTURE_DEPTH_SIZE, GL_TEXTURE_COMPRESSED,
        /// GL_TEXTURE_COMPRESSED_IMAGE_SIZE, and GL_TEXTURE_BUFFER_OFFSET are accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetTexLevelParameterfv(int target, int level, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTexLevelParameterfv(target, level, pname, _params_);
        }
        
        public static void glGetTexLevelParameteriv(int target, int level, int pname, int* _params) {
            Pointers.glGetTexLevelParameteriv(target, level, pname, _params);
        }
        
        public static void glGetTexLevelParameteriv(int target, int level, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexLevelParameteriv(target, level, pname, _params_);
        }
        
        public static void glGetTexLevelParameterxvOES(int target, int level, int pname, IntPtr* _params) {
            Pointers.glGetTexLevelParameterxvOES(target, level, pname, _params);
        }
        
        public static void glGetTexLevelParameterxvOES(int target, int level, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetTexLevelParameterxvOES(target, level, pname, _params_);
        }
        
        public static void glGetTexParameterIiv(int target, int pname, int* _params) {
            Pointers.glGetTexParameterIiv(target, pname, _params);
        }
        
        public static void glGetTexParameterIiv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexParameterIiv(target, pname, _params_);
        }
        
        public static void glGetTexParameterIivEXT(int target, int pname, int* _params) {
            Pointers.glGetTexParameterIivEXT(target, pname, _params);
        }
        
        public static void glGetTexParameterIivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexParameterIivEXT(target, pname, _params_);
        }
        
        public static void glGetTexParameterIivOES(int target, int pname, int* _params) {
            Pointers.glGetTexParameterIivOES(target, pname, _params);
        }
        
        public static void glGetTexParameterIivOES(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexParameterIivOES(target, pname, _params_);
        }
        
        public static void glGetTexParameterIuiv(int target, int pname, uint* _params) {
            Pointers.glGetTexParameterIuiv(target, pname, _params);
        }
        
        public static void glGetTexParameterIuiv(int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetTexParameterIuiv(target, pname, _params_);
        }
        
        public static void glGetTexParameterIuivEXT(int target, int pname, uint* _params) {
            Pointers.glGetTexParameterIuivEXT(target, pname, _params);
        }
        
        public static void glGetTexParameterIuivEXT(int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetTexParameterIuivEXT(target, pname, _params_);
        }
        
        public static void glGetTexParameterIuivOES(int target, int pname, uint* _params) {
            Pointers.glGetTexParameterIuivOES(target, pname, _params);
        }
        
        public static void glGetTexParameterIuivOES(int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetTexParameterIuivOES(target, pname, _params_);
        }
        
        public static void glGetTexParameterPointervAPPLE(int target, int pname, IntPtr* _params) {
            Pointers.glGetTexParameterPointervAPPLE(target, pname, _params);
        }
        
        public static void glGetTexParameterPointervAPPLE(int target, int pname, out IntPtr _params) {
            fixed(IntPtr* _params_ = &_params)
                Pointers.glGetTexParameterPointervAPPLE(target, pname, _params_);
        }
        
        /// <summary>
        /// return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv,
        /// glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
        /// GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
        /// GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are
        /// accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE,
        /// GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
        /// GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL,
        /// GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
        /// GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS,
        /// GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the texture parameters.
        /// </param>
        public static void glGetTexParameterfv(int target, int pname, float* _params) {
            Pointers.glGetTexParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// return texture parameter values
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glGetTexParameterfv, glGetTexParameteriv,
        /// glGetTexParameterIiv, and glGetTexParameterIuiv functions. GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
        /// GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY,
        /// GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_RECTANGLE, and GL_TEXTURE_CUBE_MAP_ARRAY are
        /// accepted.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a texture parameter. GL_DEPTH_STENCIL_TEXTURE_MODE,
        /// GL_IMAGE_FORMAT_COMPATIBILITY_TYPE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_BORDER_COLOR,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_COMPARE_FUNC, GL_TEXTURE_IMMUTABLE_FORMAT,
        /// GL_TEXTURE_IMMUTABLE_LEVELS, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_MAX_LEVEL,
        /// GL_TEXTURE_MAX_LOD, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MIN_LOD, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_SWIZZLE_RGBA,
        /// GL_TEXTURE_TARGET, GL_TEXTURE_VIEW_MIN_LAYER, GL_TEXTURE_VIEW_MIN_LEVEL, GL_TEXTURE_VIEW_NUM_LAYERS,
        /// GL_TEXTURE_VIEW_NUM_LEVELS, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, and GL_TEXTURE_WRAP_R are
        /// accepted.
        /// </param>
        /// <param name="_params">
        /// Returns the texture parameters.
        /// </param>
        public static void glGetTexParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTexParameterfv(target, pname, _params_);
        }
        
        public static void glGetTexParameteriv(int target, int pname, int* _params) {
            Pointers.glGetTexParameteriv(target, pname, _params);
        }
        
        public static void glGetTexParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTexParameteriv(target, pname, _params_);
        }
        
        public static void glGetTexParameterxv(int target, int pname, IntPtr* _params) {
            Pointers.glGetTexParameterxv(target, pname, _params);
        }
        
        public static void glGetTexParameterxv(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetTexParameterxv(target, pname, _params_);
        }
        
        public static void glGetTexParameterxvOES(int target, int pname, IntPtr* _params) {
            Pointers.glGetTexParameterxvOES(target, pname, _params);
        }
        
        public static void glGetTexParameterxvOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glGetTexParameterxvOES(target, pname, _params_);
        }
        
        public static ulong glGetTextureHandleARB(uint texture) {
            return Pointers.glGetTextureHandleARB(texture);
        }
        
        public static ulong glGetTextureHandleIMG(uint texture) {
            return Pointers.glGetTextureHandleIMG(texture);
        }
        
        public static ulong glGetTextureHandleNV(uint texture) {
            return Pointers.glGetTextureHandleNV(texture);
        }
        
        public static void glGetTextureImage(uint texture, int level, int format, int type, int bufSize, IntPtr pixels) {
            Pointers.glGetTextureImage(texture, level, format, type, bufSize, pixels);
        }
        
        public static void glGetTextureImageEXT(uint texture, int target, int level, int format, int type, IntPtr pixels) {
            Pointers.glGetTextureImageEXT(texture, target, level, format, type, pixels);
        }
        
        public static void glGetTextureLevelParameterfv(uint texture, int level, int pname, float* _params) {
            Pointers.glGetTextureLevelParameterfv(texture, level, pname, _params);
        }
        
        public static void glGetTextureLevelParameterfv(uint texture, int level, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTextureLevelParameterfv(texture, level, pname, _params_);
        }
        
        public static void glGetTextureLevelParameterfvEXT(uint texture, int target, int level, int pname, float* _params) {
            Pointers.glGetTextureLevelParameterfvEXT(texture, target, level, pname, _params);
        }
        
        public static void glGetTextureLevelParameterfvEXT(uint texture, int target, int level, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTextureLevelParameterfvEXT(texture, target, level, pname, _params_);
        }
        
        public static void glGetTextureLevelParameteriv(uint texture, int level, int pname, int* _params) {
            Pointers.glGetTextureLevelParameteriv(texture, level, pname, _params);
        }
        
        public static void glGetTextureLevelParameteriv(uint texture, int level, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTextureLevelParameteriv(texture, level, pname, _params_);
        }
        
        public static void glGetTextureLevelParameterivEXT(uint texture, int target, int level, int pname, int* _params) {
            Pointers.glGetTextureLevelParameterivEXT(texture, target, level, pname, _params);
        }
        
        public static void glGetTextureLevelParameterivEXT(uint texture, int target, int level, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTextureLevelParameterivEXT(texture, target, level, pname, _params_);
        }
        
        public static void glGetTextureParameterIiv(uint texture, int pname, int* _params) {
            Pointers.glGetTextureParameterIiv(texture, pname, _params);
        }
        
        public static void glGetTextureParameterIiv(uint texture, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTextureParameterIiv(texture, pname, _params_);
        }
        
        public static void glGetTextureParameterIivEXT(uint texture, int target, int pname, int* _params) {
            Pointers.glGetTextureParameterIivEXT(texture, target, pname, _params);
        }
        
        public static void glGetTextureParameterIivEXT(uint texture, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTextureParameterIivEXT(texture, target, pname, _params_);
        }
        
        public static void glGetTextureParameterIuiv(uint texture, int pname, uint* _params) {
            Pointers.glGetTextureParameterIuiv(texture, pname, _params);
        }
        
        public static void glGetTextureParameterIuiv(uint texture, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetTextureParameterIuiv(texture, pname, _params_);
        }
        
        public static void glGetTextureParameterIuivEXT(uint texture, int target, int pname, uint* _params) {
            Pointers.glGetTextureParameterIuivEXT(texture, target, pname, _params);
        }
        
        public static void glGetTextureParameterIuivEXT(uint texture, int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetTextureParameterIuivEXT(texture, target, pname, _params_);
        }
        
        public static void glGetTextureParameterfv(uint texture, int pname, float* _params) {
            Pointers.glGetTextureParameterfv(texture, pname, _params);
        }
        
        public static void glGetTextureParameterfv(uint texture, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTextureParameterfv(texture, pname, _params_);
        }
        
        public static void glGetTextureParameterfvEXT(uint texture, int target, int pname, float* _params) {
            Pointers.glGetTextureParameterfvEXT(texture, target, pname, _params);
        }
        
        public static void glGetTextureParameterfvEXT(uint texture, int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetTextureParameterfvEXT(texture, target, pname, _params_);
        }
        
        public static void glGetTextureParameteriv(uint texture, int pname, int* _params) {
            Pointers.glGetTextureParameteriv(texture, pname, _params);
        }
        
        public static void glGetTextureParameteriv(uint texture, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTextureParameteriv(texture, pname, _params_);
        }
        
        public static void glGetTextureParameterivEXT(uint texture, int target, int pname, int* _params) {
            Pointers.glGetTextureParameterivEXT(texture, target, pname, _params);
        }
        
        public static void glGetTextureParameterivEXT(uint texture, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetTextureParameterivEXT(texture, target, pname, _params_);
        }
        
        public static ulong glGetTextureSamplerHandleARB(uint texture, uint sampler) {
            return Pointers.glGetTextureSamplerHandleARB(texture, sampler);
        }
        
        public static ulong glGetTextureSamplerHandleIMG(uint texture, uint sampler) {
            return Pointers.glGetTextureSamplerHandleIMG(texture, sampler);
        }
        
        public static ulong glGetTextureSamplerHandleNV(uint texture, uint sampler) {
            return Pointers.glGetTextureSamplerHandleNV(texture, sampler);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="texture">
        /// Specifies the name of the source texture object. Must be GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY,
        /// GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY or
        /// GL_TEXTURE_RECTANGLE. In specific, buffer and multisample textures are not permitted.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level $n$ is the $n$th mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT and GL_STENCIL_INDEX.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="bufSize">
        /// Specifies the size of the buffer to receive the retrieved pixel data.
        /// </param>
        /// <param name="pixels">
        /// Returns the texture subimage. Should be a pointer to an array of the type specified by type.
        /// </param>
        public static void glGetTextureSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, int bufSize, IntPtr pixels) {
            Pointers.glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
        }
        
        public static void glGetTrackMatrixivNV(int target, uint address, int pname, int* _params) {
            Pointers.glGetTrackMatrixivNV(target, address, pname, _params);
        }
        
        public static void glGetTrackMatrixivNV(int target, uint address, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetTrackMatrixivNV(target, address, pname, _params_);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, int* type, StringBuilder name) {
            Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, int* size, out int type, StringBuilder name) {
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length, size, type_, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, out int size, int* type, StringBuilder name) {
            fixed(int* size_ = &size)
                Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length, size_, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, int* length, out int size, out int type, StringBuilder name) {
            fixed(int* size_ = &size)
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length, size_, type_, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, int* size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length_, size, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, int* size, out int type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length_, size, type_, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, out int size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
                Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length_, size_, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVarying(uint program, uint index, int bufSize, out int length, out int size, out int type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVarying(program, index, bufSize, length_, size_, type_, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, int* size, int* type, StringBuilder name) {
            Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, int* size, out int type, StringBuilder name) {
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size, type_, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, out int size, int* type, StringBuilder name) {
            fixed(int* size_ = &size)
                Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size_, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, int* length, out int size, out int type, StringBuilder name) {
            fixed(int* size_ = &size)
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length, size_, type_, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, out int length, int* size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
                Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length_, size, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, out int length, int* size, out int type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length_, size, type_, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, out int length, out int size, int* type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
                Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length_, size_, type, name);
        }
        
        /// <summary>
        /// retrieve information about varying variables selected for transform feedback
        /// <para>
        /// Information about the set of varying variables in a linked program that will be captured during
        /// transform feedback may be retrieved by calling glGetTransformFeedbackVarying.
        /// glGetTransformFeedbackVarying provides information about the varying variable selected by index. An
        /// index of 0 selects the first varying variable specified in the varyings array passed to
        /// glTransformFeedbackVaryings, and an index of the value of GL_TRANSFORM_FEEDBACK_VARYINGS minus one
        /// selects the last such variable
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="index">
        /// The index of the varying variable whose information to retrieve.
        /// </param>
        /// <param name="bufSize">
        /// The maximum number of characters, including the null terminator, that may be written into name.
        /// </param>
        /// <param name="length">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        /// <param name="size">
        /// The address of a variable that will receive the size of the varying.
        /// </param>
        /// <param name="type">
        /// The address of a variable that will recieve the type of the varying.
        /// </param>
        /// <param name="name">
        /// The address of a variable which will receive the number of characters written into name, excluding
        /// the null-terminator. If length is NULL no length is returned.
        /// </param>
        public static void glGetTransformFeedbackVaryingEXT(uint program, uint index, int bufSize, out int length, out int size, out int type, StringBuilder name) {
            fixed(int* length_ = &length)
            fixed(int* size_ = &size)
            fixed(int* type_ = &type)
                Pointers.glGetTransformFeedbackVaryingEXT(program, index, bufSize, length_, size_, type_, name);
        }
        
        public static void glGetTransformFeedbackVaryingNV(uint program, uint index, int* location) {
            Pointers.glGetTransformFeedbackVaryingNV(program, index, location);
        }
        
        public static void glGetTransformFeedbackVaryingNV(uint program, uint index, out int location) {
            fixed(int* location_ = &location)
                Pointers.glGetTransformFeedbackVaryingNV(program, index, location_);
        }
        
        /// <summary>
        /// query the state of a transform feedback object.
        /// </summary>
        /// <param name="xfb">
        /// The name of an existing transform feedback object, or zero for the default transform feedback
        /// object.
        /// </param>
        /// <param name="pname">
        /// Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING,
        /// GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
        /// GL_TRANSFORM_FEEDBACK_ACTIVE.
        /// </param>
        /// <param name="index">
        /// Index of the transform feedback stream (for indexed state).
        /// </param>
        /// <param name="param">
        /// The address of a buffer into which will be written the requested state information.
        /// </param>
        public static void glGetTransformFeedbacki64_v(uint xfb, int pname, uint index, long* param) {
            Pointers.glGetTransformFeedbacki64_v(xfb, pname, index, param);
        }
        
        /// <summary>
        /// query the state of a transform feedback object.
        /// </summary>
        /// <param name="xfb">
        /// The name of an existing transform feedback object, or zero for the default transform feedback
        /// object.
        /// </param>
        /// <param name="pname">
        /// Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING,
        /// GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
        /// GL_TRANSFORM_FEEDBACK_ACTIVE.
        /// </param>
        /// <param name="index">
        /// Index of the transform feedback stream (for indexed state).
        /// </param>
        /// <param name="param">
        /// The address of a buffer into which will be written the requested state information.
        /// </param>
        public static void glGetTransformFeedbacki64_v(uint xfb, int pname, uint index, long[] param) {
            fixed(long* param_ = &param[0])
                Pointers.glGetTransformFeedbacki64_v(xfb, pname, index, param_);
        }
        
        /// <summary>
        /// query the state of a transform feedback object.
        /// </summary>
        /// <param name="xfb">
        /// The name of an existing transform feedback object, or zero for the default transform feedback
        /// object.
        /// </param>
        /// <param name="pname">
        /// Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING,
        /// GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
        /// GL_TRANSFORM_FEEDBACK_ACTIVE.
        /// </param>
        /// <param name="index">
        /// Index of the transform feedback stream (for indexed state).
        /// </param>
        /// <param name="param">
        /// The address of a buffer into which will be written the requested state information.
        /// </param>
        public static void glGetTransformFeedbacki_v(uint xfb, int pname, uint index, int* param) {
            Pointers.glGetTransformFeedbacki_v(xfb, pname, index, param);
        }
        
        /// <summary>
        /// query the state of a transform feedback object.
        /// </summary>
        /// <param name="xfb">
        /// The name of an existing transform feedback object, or zero for the default transform feedback
        /// object.
        /// </param>
        /// <param name="pname">
        /// Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING,
        /// GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
        /// GL_TRANSFORM_FEEDBACK_ACTIVE.
        /// </param>
        /// <param name="index">
        /// Index of the transform feedback stream (for indexed state).
        /// </param>
        /// <param name="param">
        /// The address of a buffer into which will be written the requested state information.
        /// </param>
        public static void glGetTransformFeedbacki_v(uint xfb, int pname, uint index, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetTransformFeedbacki_v(xfb, pname, index, param_);
        }
        
        /// <summary>
        /// query the state of a transform feedback object.
        /// </summary>
        /// <param name="xfb">
        /// The name of an existing transform feedback object, or zero for the default transform feedback
        /// object.
        /// </param>
        /// <param name="pname">
        /// Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING,
        /// GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
        /// GL_TRANSFORM_FEEDBACK_ACTIVE.
        /// </param>
        /// <param name="param">
        /// The address of a buffer into which will be written the requested state information.
        /// </param>
        public static void glGetTransformFeedbackiv(uint xfb, int pname, int* param) {
            Pointers.glGetTransformFeedbackiv(xfb, pname, param);
        }
        
        /// <summary>
        /// query the state of a transform feedback object.
        /// </summary>
        /// <param name="xfb">
        /// The name of an existing transform feedback object, or zero for the default transform feedback
        /// object.
        /// </param>
        /// <param name="pname">
        /// Property to use for the query. Must be one of the values: GL_TRANSFORM_FEEDBACK_BUFFER_BINDING,
        /// GL_TRANSFORM_FEEDBACK_BUFFER_START, GL_TRANSFORM_FEEDBACK_BUFFER_SIZE, GL_TRANSFORM_FEEDBACK_PAUSED,
        /// GL_TRANSFORM_FEEDBACK_ACTIVE.
        /// </param>
        /// <param name="param">
        /// The address of a buffer into which will be written the requested state information.
        /// </param>
        public static void glGetTransformFeedbackiv(uint xfb, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetTransformFeedbackiv(xfb, pname, param_);
        }
        
        public static void glGetTranslatedShaderSourceANGLE(uint shader, int bufsize, int* length, StringBuilder source) {
            Pointers.glGetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
        }
        
        public static void glGetTranslatedShaderSourceANGLE(uint shader, int bufsize, out int length, StringBuilder source) {
            fixed(int* length_ = &length)
                Pointers.glGetTranslatedShaderSourceANGLE(shader, bufsize, length_, source);
        }
        
        /// <summary>
        /// retrieve the index of a named uniform block
        /// <para>
        /// glGetUniformBlockIndex retrieves the index of a uniform block within program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing the uniform block.
        /// </param>
        /// <param name="uniformBlockName">
        /// Specifies the address an array of characters to containing the name of the uniform block whose index
        /// to retrieve.
        /// </param>
        public static uint glGetUniformBlockIndex(uint program, string uniformBlockName) {
            return Pointers.glGetUniformBlockIndex(program, uniformBlockName);
        }
        
        public static int glGetUniformBufferSizeEXT(uint program, int location) {
            return Pointers.glGetUniformBufferSizeEXT(program, location);
        }
        
        /// <summary>
        /// retrieve the index of a named uniform block
        /// <para>
        /// glGetUniformIndices retrieves the indices of a number of uniforms within program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">
        /// Specifies the address of an array of pointers to buffers containing the names of the queried
        /// uniforms.
        /// </param>
        /// <param name="uniformIndices">
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        public static void glGetUniformIndices(uint program, int uniformCount, string[] uniformNames, uint* uniformIndices) {
            Pointers.glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
        }
        
        /// <summary>
        /// retrieve the index of a named uniform block
        /// <para>
        /// glGetUniformIndices retrieves the indices of a number of uniforms within program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program containing uniforms whose indices to query.
        /// </param>
        /// <param name="uniformCount">
        /// Specifies the number of uniforms whose indices to query.
        /// </param>
        /// <param name="uniformNames">
        /// Specifies the address of an array of pointers to buffers containing the names of the queried
        /// uniforms.
        /// </param>
        /// <param name="uniformIndices">
        /// Specifies the address of an array that will receive the indices of the uniforms.
        /// </param>
        public static void glGetUniformIndices(uint program, int uniformCount, string[] uniformNames, uint[] uniformIndices) {
            fixed(uint* uniformIndices_ = &uniformIndices[0])
                Pointers.glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices_);
        }
        
        /// <summary>
        /// Returns the location of a uniform variable
        /// <para>
        /// glGetUniformLocation returns an integer that represents the location of a specific uniform variable
        /// within a program object. name must be a null terminated string that contains no white space. name
        /// must be an active uniform variable name in program that is not a structure, an array of structures,
        /// or a subcomponent of a vector or a matrix. This function returns -1 if name does not correspond to
        /// an active uniform variable in program, if name starts with the reserved prefix &quot;gl_&quot;, or
        /// if name is associated with an atomic counter or a named uniform block
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the uniform variable whose location is to
        /// be queried.
        /// </param>
        public static int glGetUniformLocation(uint program, string name) {
            return Pointers.glGetUniformLocation(program, name);
        }
        
        /// <summary>
        /// Returns the location of a uniform variable
        /// <para>
        /// glGetUniformLocation returns an integer that represents the location of a specific uniform variable
        /// within a program object. name must be a null terminated string that contains no white space. name
        /// must be an active uniform variable name in program that is not a structure, an array of structures,
        /// or a subcomponent of a vector or a matrix. This function returns -1 if name does not correspond to
        /// an active uniform variable in program, if name starts with the reserved prefix &quot;gl_&quot;, or
        /// if name is associated with an atomic counter or a named uniform block
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="name">
        /// Points to a null terminated string containing the name of the uniform variable whose location is to
        /// be queried.
        /// </param>
        public static int glGetUniformLocationARB(uint programObj, string name) {
            return Pointers.glGetUniformLocationARB(programObj, name);
        }
        
        public static uint glGetUniformOffsetEXT(uint program, int location) {
            return Pointers.glGetUniformOffsetEXT(program, location);
        }
        
        /// <summary>
        /// retrieve the value of a subroutine uniform of a given shader stage of the current program
        /// <para>
        /// glGetUniformSubroutine retrieves the value of the subroutine uniform at location location for shader
        /// stage shadertype of the current program. location must be less than the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use at shader stage shadertype.
        /// The value of the subroutine uniform is returned in values
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the subroutine uniform.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable to receive the value or values of the subroutine uniform.
        /// </param>
        public static void glGetUniformSubroutineuiv(int shadertype, int location, uint* _params) {
            Pointers.glGetUniformSubroutineuiv(shadertype, location, _params);
        }
        
        /// <summary>
        /// retrieve the value of a subroutine uniform of a given shader stage of the current program
        /// <para>
        /// glGetUniformSubroutine retrieves the value of the subroutine uniform at location location for shader
        /// stage shadertype of the current program. location must be less than the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use at shader stage shadertype.
        /// The value of the subroutine uniform is returned in values
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the subroutine uniform.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable to receive the value or values of the subroutine uniform.
        /// </param>
        public static void glGetUniformSubroutineuiv(int shadertype, int location, out uint _params) {
            fixed(uint* _params_ = &_params)
                Pointers.glGetUniformSubroutineuiv(shadertype, location, _params_);
        }
        
        /// <summary>
        /// retrieve the value of a subroutine uniform of a given shader stage of the current program
        /// <para>
        /// glGetUniformSubroutine retrieves the value of the subroutine uniform at location location for shader
        /// stage shadertype of the current program. location must be less than the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use at shader stage shadertype.
        /// The value of the subroutine uniform is returned in values
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the subroutine uniform.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable to receive the value or values of the subroutine uniform.
        /// </param>
        public static void glGetUniformSubroutineuiv(Enums.ShaderType shadertype, int location, uint* _params) {
            Pointers.glGetUniformSubroutineuiv((int)shadertype, location, _params);
        }
        
        /// <summary>
        /// retrieve the value of a subroutine uniform of a given shader stage of the current program
        /// <para>
        /// glGetUniformSubroutine retrieves the value of the subroutine uniform at location location for shader
        /// stage shadertype of the current program. location must be less than the value of
        /// GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use at shader stage shadertype.
        /// The value of the subroutine uniform is returned in values
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the subroutine uniform.
        /// </param>
        /// <param name="_params">
        /// Specifies the address of a variable to receive the value or values of the subroutine uniform.
        /// </param>
        public static void glGetUniformSubroutineuiv(Enums.ShaderType shadertype, int location, out uint _params) {
            fixed(uint* _params_ = &_params)
                Pointers.glGetUniformSubroutineuiv((int)shadertype, location, _params_);
        }
        
        public static void glGetUniformdv(uint program, int location, double* _params) {
            Pointers.glGetUniformdv(program, location, _params);
        }
        
        public static void glGetUniformdv(uint program, int location, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetUniformdv(program, location, _params_);
        }
        
        /// <summary>
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value of the specified uniform variable.
        /// </param>
        public static void glGetUniformfv(uint program, int location, float* _params) {
            Pointers.glGetUniformfv(program, location, _params);
        }
        
        /// <summary>
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="program">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value of the specified uniform variable.
        /// </param>
        public static void glGetUniformfv(uint program, int location, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetUniformfv(program, location, _params_);
        }
        
        /// <summary>
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value of the specified uniform variable.
        /// </param>
        public static void glGetUniformfvARB(uint programObj, int location, float* _params) {
            Pointers.glGetUniformfvARB(programObj, location, _params);
        }
        
        /// <summary>
        /// Returns the value of a uniform variable
        /// </summary>
        /// <param name="programObj">
        /// Specifies the program object to be queried.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be queried.
        /// </param>
        /// <param name="_params">
        /// Returns the value of the specified uniform variable.
        /// </param>
        public static void glGetUniformfvARB(uint programObj, int location, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetUniformfvARB(programObj, location, _params_);
        }
        
        public static void glGetUniformi64vARB(uint program, int location, long* _params) {
            Pointers.glGetUniformi64vARB(program, location, _params);
        }
        
        public static void glGetUniformi64vARB(uint program, int location, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetUniformi64vARB(program, location, _params_);
        }
        
        public static void glGetUniformi64vNV(uint program, int location, long* _params) {
            Pointers.glGetUniformi64vNV(program, location, _params);
        }
        
        public static void glGetUniformi64vNV(uint program, int location, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetUniformi64vNV(program, location, _params_);
        }
        
        public static void glGetUniformiv(uint program, int location, int* _params) {
            Pointers.glGetUniformiv(program, location, _params);
        }
        
        public static void glGetUniformiv(uint program, int location, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetUniformiv(program, location, _params_);
        }
        
        public static void glGetUniformivARB(uint programObj, int location, int* _params) {
            Pointers.glGetUniformivARB(programObj, location, _params);
        }
        
        public static void glGetUniformivARB(uint programObj, int location, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetUniformivARB(programObj, location, _params_);
        }
        
        public static void glGetUniformui64vARB(uint program, int location, ulong* _params) {
            Pointers.glGetUniformui64vARB(program, location, _params);
        }
        
        public static void glGetUniformui64vARB(uint program, int location, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetUniformui64vARB(program, location, _params_);
        }
        
        public static void glGetUniformui64vNV(uint program, int location, ulong* _params) {
            Pointers.glGetUniformui64vNV(program, location, _params);
        }
        
        public static void glGetUniformui64vNV(uint program, int location, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetUniformui64vNV(program, location, _params_);
        }
        
        public static void glGetUniformuiv(uint program, int location, uint* _params) {
            Pointers.glGetUniformuiv(program, location, _params);
        }
        
        public static void glGetUniformuiv(uint program, int location, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetUniformuiv(program, location, _params_);
        }
        
        public static void glGetUniformuivEXT(uint program, int location, uint* _params) {
            Pointers.glGetUniformuivEXT(program, location, _params);
        }
        
        public static void glGetUniformuivEXT(uint program, int location, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetUniformuivEXT(program, location, _params_);
        }
        
        public static void glGetUnsignedBytevEXT(int pname, byte* data) {
            Pointers.glGetUnsignedBytevEXT(pname, data);
        }
        
        public static void glGetUnsignedBytevEXT(int pname, byte[] data) {
            fixed(byte* data_ = &data[0])
                Pointers.glGetUnsignedBytevEXT(pname, data_);
        }
        
        public static void glGetUnsignedBytei_vEXT(int target, uint index, byte* data) {
            Pointers.glGetUnsignedBytei_vEXT(target, index, data);
        }
        
        public static void glGetUnsignedBytei_vEXT(int target, uint index, byte[] data) {
            fixed(byte* data_ = &data[0])
                Pointers.glGetUnsignedBytei_vEXT(target, index, data_);
        }
        
        public static void glGetVariantArrayObjectfvATI(uint id, int pname, float* _params) {
            Pointers.glGetVariantArrayObjectfvATI(id, pname, _params);
        }
        
        public static void glGetVariantArrayObjectfvATI(uint id, int pname, out float _params) {
            fixed(float* _params_ = &_params)
                Pointers.glGetVariantArrayObjectfvATI(id, pname, _params_);
        }
        
        public static void glGetVariantArrayObjectivATI(uint id, int pname, int* _params) {
            Pointers.glGetVariantArrayObjectivATI(id, pname, _params);
        }
        
        public static void glGetVariantArrayObjectivATI(uint id, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetVariantArrayObjectivATI(id, pname, _params_);
        }
        
        public static void glGetVariantBooleanvEXT(uint id, int value, bool* data) {
            Pointers.glGetVariantBooleanvEXT(id, value, data);
        }
        
        public static void glGetVariantBooleanvEXT(uint id, int value, bool[] data) {
            fixed(bool* data_ = &data[0])
                Pointers.glGetVariantBooleanvEXT(id, value, data_);
        }
        
        public static void glGetVariantFloatvEXT(uint id, int value, float* data) {
            Pointers.glGetVariantFloatvEXT(id, value, data);
        }
        
        public static void glGetVariantFloatvEXT(uint id, int value, float[] data) {
            fixed(float* data_ = &data[0])
                Pointers.glGetVariantFloatvEXT(id, value, data_);
        }
        
        public static void glGetVariantIntegervEXT(uint id, int value, int* data) {
            Pointers.glGetVariantIntegervEXT(id, value, data);
        }
        
        public static void glGetVariantIntegervEXT(uint id, int value, int[] data) {
            fixed(int* data_ = &data[0])
                Pointers.glGetVariantIntegervEXT(id, value, data_);
        }
        
        public static void glGetVariantPointervEXT(uint id, int value, IntPtr* data) {
            Pointers.glGetVariantPointervEXT(id, value, data);
        }
        
        public static void glGetVariantPointervEXT(uint id, int value, IntPtr[] data) {
            fixed(IntPtr* data_ = &data[0])
                Pointers.glGetVariantPointervEXT(id, value, data_);
        }
        
        public static int glGetVaryingLocationNV(uint program, string name) {
            return Pointers.glGetVaryingLocationNV(program, name);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="vaobj">
        /// Specifies the name of a vertex array object.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the vertex array object attribute. Must 	 be a number between 0 and
        /// (GL_MAX_VERTEX_ATTRIBS - 1).
        /// </param>
        /// <param name="pname">
        /// Specifies the property to be used for the query. For 	 glGetVertexArrayIndexediv, it must be one of
        /// the following values: 	 GL_VERTEX_ATTRIB_ARRAY_ENABLED, 	 GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, 	 GL_VERTEX_ATTRIB_ARRAY_TYPE, 	 GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, 	 GL_VERTEX_ATTRIB_ARRAY_LONG, 	 GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
        /// GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For 	 glGetVertexArrayIndexed64v, it must be equal to
        /// GL_VERTEX_BINDING_OFFSET.
        /// </param>
        /// <param name="param">
        /// Returns the requested value.
        /// </param>
        public static void glGetVertexArrayIndexed64iv(uint vaobj, uint index, int pname, long* param) {
            Pointers.glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="vaobj">
        /// Specifies the name of a vertex array object.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the vertex array object attribute. Must 	 be a number between 0 and
        /// (GL_MAX_VERTEX_ATTRIBS - 1).
        /// </param>
        /// <param name="pname">
        /// Specifies the property to be used for the query. For 	 glGetVertexArrayIndexediv, it must be one of
        /// the following values: 	 GL_VERTEX_ATTRIB_ARRAY_ENABLED, 	 GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, 	 GL_VERTEX_ATTRIB_ARRAY_TYPE, 	 GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, 	 GL_VERTEX_ATTRIB_ARRAY_LONG, 	 GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
        /// GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For 	 glGetVertexArrayIndexed64v, it must be equal to
        /// GL_VERTEX_BINDING_OFFSET.
        /// </param>
        /// <param name="param">
        /// Returns the requested value.
        /// </param>
        public static void glGetVertexArrayIndexed64iv(uint vaobj, uint index, int pname, long[] param) {
            fixed(long* param_ = &param[0])
                Pointers.glGetVertexArrayIndexed64iv(vaobj, index, pname, param_);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="vaobj">
        /// Specifies the name of a vertex array object.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the vertex array object attribute. Must 	 be a number between 0 and
        /// (GL_MAX_VERTEX_ATTRIBS - 1).
        /// </param>
        /// <param name="pname">
        /// Specifies the property to be used for the query. For 	 glGetVertexArrayIndexediv, it must be one of
        /// the following values: 	 GL_VERTEX_ATTRIB_ARRAY_ENABLED, 	 GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, 	 GL_VERTEX_ATTRIB_ARRAY_TYPE, 	 GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, 	 GL_VERTEX_ATTRIB_ARRAY_LONG, 	 GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
        /// GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For 	 glGetVertexArrayIndexed64v, it must be equal to
        /// GL_VERTEX_BINDING_OFFSET.
        /// </param>
        /// <param name="param">
        /// Returns the requested value.
        /// </param>
        public static void glGetVertexArrayIndexediv(uint vaobj, uint index, int pname, int* param) {
            Pointers.glGetVertexArrayIndexediv(vaobj, index, pname, param);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="vaobj">
        /// Specifies the name of a vertex array object.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the vertex array object attribute. Must 	 be a number between 0 and
        /// (GL_MAX_VERTEX_ATTRIBS - 1).
        /// </param>
        /// <param name="pname">
        /// Specifies the property to be used for the query. For 	 glGetVertexArrayIndexediv, it must be one of
        /// the following values: 	 GL_VERTEX_ATTRIB_ARRAY_ENABLED, 	 GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, 	 GL_VERTEX_ATTRIB_ARRAY_TYPE, 	 GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, 	 GL_VERTEX_ATTRIB_ARRAY_LONG, 	 GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or
        /// GL_VERTEX_ATTRIB_RELATIVE_OFFSET. For 	 glGetVertexArrayIndexed64v, it must be equal to
        /// GL_VERTEX_BINDING_OFFSET.
        /// </param>
        /// <param name="param">
        /// Returns the requested value.
        /// </param>
        public static void glGetVertexArrayIndexediv(uint vaobj, uint index, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetVertexArrayIndexediv(vaobj, index, pname, param_);
        }
        
        public static void glGetVertexArrayIntegeri_vEXT(uint vaobj, uint index, int pname, int* param) {
            Pointers.glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param);
        }
        
        public static void glGetVertexArrayIntegeri_vEXT(uint vaobj, uint index, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetVertexArrayIntegeri_vEXT(vaobj, index, pname, param_);
        }
        
        public static void glGetVertexArrayIntegervEXT(uint vaobj, int pname, int* param) {
            Pointers.glGetVertexArrayIntegervEXT(vaobj, pname, param);
        }
        
        public static void glGetVertexArrayIntegervEXT(uint vaobj, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetVertexArrayIntegervEXT(vaobj, pname, param_);
        }
        
        public static void glGetVertexArrayPointeri_vEXT(uint vaobj, uint index, int pname, IntPtr* param) {
            Pointers.glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param);
        }
        
        public static void glGetVertexArrayPointeri_vEXT(uint vaobj, uint index, int pname, IntPtr[] param) {
            fixed(IntPtr* param_ = &param[0])
                Pointers.glGetVertexArrayPointeri_vEXT(vaobj, index, pname, param_);
        }
        
        public static void glGetVertexArrayPointervEXT(uint vaobj, int pname, IntPtr* param) {
            Pointers.glGetVertexArrayPointervEXT(vaobj, pname, param);
        }
        
        public static void glGetVertexArrayPointervEXT(uint vaobj, int pname, out IntPtr param) {
            fixed(IntPtr* param_ = &param)
                Pointers.glGetVertexArrayPointervEXT(vaobj, pname, param_);
        }
        
        /// <summary>
        /// retrieve parameters of a vertex array object
        /// </summary>
        /// <param name="vaobj">
        /// specifies the name of the vertex array object to use for the query.
        /// </param>
        /// <param name="pname">
        /// Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.
        /// </param>
        /// <param name="param">
        /// Returns the requested value.
        /// </param>
        public static void glGetVertexArrayiv(uint vaobj, int pname, int* param) {
            Pointers.glGetVertexArrayiv(vaobj, pname, param);
        }
        
        /// <summary>
        /// retrieve parameters of a vertex array object
        /// </summary>
        /// <param name="vaobj">
        /// specifies the name of the vertex array object to use for the query.
        /// </param>
        /// <param name="pname">
        /// Name of the property to use for the query. Must be GL_ELEMENT_ARRAY_BUFFER_BINDING.
        /// </param>
        /// <param name="param">
        /// Returns the requested value.
        /// </param>
        public static void glGetVertexArrayiv(uint vaobj, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glGetVertexArrayiv(vaobj, pname, param_);
        }
        
        public static void glGetVertexAttribArrayObjectfvATI(uint index, int pname, float* _params) {
            Pointers.glGetVertexAttribArrayObjectfvATI(index, pname, _params);
        }
        
        public static void glGetVertexAttribArrayObjectfvATI(uint index, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetVertexAttribArrayObjectfvATI(index, pname, _params_);
        }
        
        public static void glGetVertexAttribArrayObjectivATI(uint index, int pname, int* _params) {
            Pointers.glGetVertexAttribArrayObjectivATI(index, pname, _params);
        }
        
        public static void glGetVertexAttribArrayObjectivATI(uint index, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetVertexAttribArrayObjectivATI(index, pname, _params_);
        }
        
        public static void glGetVertexAttribIiv(uint index, int pname, int* _params) {
            Pointers.glGetVertexAttribIiv(index, pname, _params);
        }
        
        public static void glGetVertexAttribIiv(uint index, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetVertexAttribIiv(index, pname, _params_);
        }
        
        public static void glGetVertexAttribIivEXT(uint index, int pname, int* _params) {
            Pointers.glGetVertexAttribIivEXT(index, pname, _params);
        }
        
        public static void glGetVertexAttribIivEXT(uint index, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetVertexAttribIivEXT(index, pname, _params_);
        }
        
        public static void glGetVertexAttribIuiv(uint index, int pname, uint* _params) {
            Pointers.glGetVertexAttribIuiv(index, pname, _params);
        }
        
        public static void glGetVertexAttribIuiv(uint index, int pname, out uint _params) {
            fixed(uint* _params_ = &_params)
                Pointers.glGetVertexAttribIuiv(index, pname, _params_);
        }
        
        public static void glGetVertexAttribIuivEXT(uint index, int pname, uint* _params) {
            Pointers.glGetVertexAttribIuivEXT(index, pname, _params);
        }
        
        public static void glGetVertexAttribIuivEXT(uint index, int pname, out uint _params) {
            fixed(uint* _params_ = &_params)
                Pointers.glGetVertexAttribIuivEXT(index, pname, _params_);
        }
        
        public static void glGetVertexAttribLdv(uint index, int pname, double* _params) {
            Pointers.glGetVertexAttribLdv(index, pname, _params);
        }
        
        public static void glGetVertexAttribLdv(uint index, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetVertexAttribLdv(index, pname, _params_);
        }
        
        public static void glGetVertexAttribLdvEXT(uint index, int pname, double* _params) {
            Pointers.glGetVertexAttribLdvEXT(index, pname, _params);
        }
        
        public static void glGetVertexAttribLdvEXT(uint index, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetVertexAttribLdvEXT(index, pname, _params_);
        }
        
        public static void glGetVertexAttribLi64vNV(uint index, int pname, long* _params) {
            Pointers.glGetVertexAttribLi64vNV(index, pname, _params);
        }
        
        public static void glGetVertexAttribLi64vNV(uint index, int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetVertexAttribLi64vNV(index, pname, _params_);
        }
        
        public static void glGetVertexAttribLui64vARB(uint index, int pname, ulong* _params) {
            Pointers.glGetVertexAttribLui64vARB(index, pname, _params);
        }
        
        public static void glGetVertexAttribLui64vARB(uint index, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetVertexAttribLui64vARB(index, pname, _params_);
        }
        
        public static void glGetVertexAttribLui64vNV(uint index, int pname, ulong* _params) {
            Pointers.glGetVertexAttribLui64vNV(index, pname, _params);
        }
        
        public static void glGetVertexAttribLui64vNV(uint index, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetVertexAttribLui64vNV(index, pname, _params_);
        }
        
        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>
        /// glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be
        /// queried, pname is a symbolic constant indicating the pointer to be returned, and params is a pointer
        /// to a location in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be
        /// GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        public static void glGetVertexAttribPointerv(uint index, int pname, IntPtr* pointer) {
            Pointers.glGetVertexAttribPointerv(index, pname, pointer);
        }
        
        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>
        /// glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be
        /// queried, pname is a symbolic constant indicating the pointer to be returned, and params is a pointer
        /// to a location in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be
        /// GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        public static void glGetVertexAttribPointerv(uint index, int pname, out IntPtr pointer) {
            fixed(IntPtr* pointer_ = &pointer)
                Pointers.glGetVertexAttribPointerv(index, pname, pointer_);
        }
        
        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>
        /// glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be
        /// queried, pname is a symbolic constant indicating the pointer to be returned, and params is a pointer
        /// to a location in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be
        /// GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        public static void glGetVertexAttribPointervARB(uint index, int pname, IntPtr* pointer) {
            Pointers.glGetVertexAttribPointervARB(index, pname, pointer);
        }
        
        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>
        /// glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be
        /// queried, pname is a symbolic constant indicating the pointer to be returned, and params is a pointer
        /// to a location in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be
        /// GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        public static void glGetVertexAttribPointervARB(uint index, int pname, out IntPtr pointer) {
            fixed(IntPtr* pointer_ = &pointer)
                Pointers.glGetVertexAttribPointervARB(index, pname, pointer_);
        }
        
        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>
        /// glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be
        /// queried, pname is a symbolic constant indicating the pointer to be returned, and params is a pointer
        /// to a location in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be
        /// GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        public static void glGetVertexAttribPointervNV(uint index, int pname, IntPtr* pointer) {
            Pointers.glGetVertexAttribPointervNV(index, pname, pointer);
        }
        
        /// <summary>
        /// return the address of the specified generic vertex attribute pointer
        /// <para>
        /// glGetVertexAttribPointerv returns pointer information. index is the generic vertex attribute to be
        /// queried, pname is a symbolic constant indicating the pointer to be returned, and params is a pointer
        /// to a location in which to place the returned data
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be returned.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the generic vertex attribute parameter to be returned. Must be
        /// GL_VERTEX_ATTRIB_ARRAY_POINTER.
        /// </param>
        /// <param name="pointer">
        /// Returns the pointer value.
        /// </param>
        public static void glGetVertexAttribPointervNV(uint index, int pname, out IntPtr pointer) {
            fixed(IntPtr* pointer_ = &pointer)
                Pointers.glGetVertexAttribPointervNV(index, pname, pointer_);
        }
        
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>
        /// glGetVertexAttrib returns in params the value of a generic vertex attribute parameter. The generic
        /// vertex attribute to be queried is specified by index, and the parameter to be queried is specified
        /// by pname
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are
        /// GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetVertexAttribdv(uint index, int pname, double* _params) {
            Pointers.glGetVertexAttribdv(index, pname, _params);
        }
        
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>
        /// glGetVertexAttrib returns in params the value of a generic vertex attribute parameter. The generic
        /// vertex attribute to be queried is specified by index, and the parameter to be queried is specified
        /// by pname
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are
        /// GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetVertexAttribdv(uint index, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetVertexAttribdv(index, pname, _params_);
        }
        
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>
        /// glGetVertexAttrib returns in params the value of a generic vertex attribute parameter. The generic
        /// vertex attribute to be queried is specified by index, and the parameter to be queried is specified
        /// by pname
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are
        /// GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetVertexAttribdvARB(uint index, int pname, double* _params) {
            Pointers.glGetVertexAttribdvARB(index, pname, _params);
        }
        
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>
        /// glGetVertexAttrib returns in params the value of a generic vertex attribute parameter. The generic
        /// vertex attribute to be queried is specified by index, and the parameter to be queried is specified
        /// by pname
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are
        /// GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetVertexAttribdvARB(uint index, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetVertexAttribdvARB(index, pname, _params_);
        }
        
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>
        /// glGetVertexAttrib returns in params the value of a generic vertex attribute parameter. The generic
        /// vertex attribute to be queried is specified by index, and the parameter to be queried is specified
        /// by pname
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are
        /// GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetVertexAttribdvNV(uint index, int pname, double* _params) {
            Pointers.glGetVertexAttribdvNV(index, pname, _params);
        }
        
        /// <summary>
        /// Return a generic vertex attribute parameter
        /// <para>
        /// glGetVertexAttrib returns in params the value of a generic vertex attribute parameter. The generic
        /// vertex attribute to be queried is specified by index, and the parameter to be queried is specified
        /// by pname
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the generic vertex attribute parameter to be queried.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the vertex attribute parameter to be queried. Accepted values are
        /// GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE,
        /// GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED,
        /// GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR, or GL_CURRENT_VERTEX_ATTRIB.
        /// </param>
        /// <param name="_params">
        /// Returns the requested data.
        /// </param>
        public static void glGetVertexAttribdvNV(uint index, int pname, out double _params) {
            fixed(double* _params_ = &_params)
                Pointers.glGetVertexAttribdvNV(index, pname, _params_);
        }
        
        public static void glGetVertexAttribfv(uint index, int pname, float* _params) {
            Pointers.glGetVertexAttribfv(index, pname, _params);
        }
        
        public static void glGetVertexAttribfv(uint index, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetVertexAttribfv(index, pname, _params_);
        }
        
        public static void glGetVertexAttribfvARB(uint index, int pname, float* _params) {
            Pointers.glGetVertexAttribfvARB(index, pname, _params);
        }
        
        public static void glGetVertexAttribfvARB(uint index, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetVertexAttribfvARB(index, pname, _params_);
        }
        
        public static void glGetVertexAttribfvNV(uint index, int pname, float* _params) {
            Pointers.glGetVertexAttribfvNV(index, pname, _params);
        }
        
        public static void glGetVertexAttribfvNV(uint index, int pname, out float _params) {
            fixed(float* _params_ = &_params)
                Pointers.glGetVertexAttribfvNV(index, pname, _params_);
        }
        
        public static void glGetVertexAttribiv(uint index, int pname, int* _params) {
            Pointers.glGetVertexAttribiv(index, pname, _params);
        }
        
        public static void glGetVertexAttribiv(uint index, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetVertexAttribiv(index, pname, _params_);
        }
        
        public static void glGetVertexAttribivARB(uint index, int pname, int* _params) {
            Pointers.glGetVertexAttribivARB(index, pname, _params);
        }
        
        public static void glGetVertexAttribivARB(uint index, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetVertexAttribivARB(index, pname, _params_);
        }
        
        public static void glGetVertexAttribivNV(uint index, int pname, int* _params) {
            Pointers.glGetVertexAttribivNV(index, pname, _params);
        }
        
        public static void glGetVertexAttribivNV(uint index, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glGetVertexAttribivNV(index, pname, _params_);
        }
        
        public static void glGetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, int pname, double* _params) {
            Pointers.glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, _params);
        }
        
        public static void glGetVideoCaptureStreamdvNV(uint video_capture_slot, uint stream, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetVideoCaptureStreamdvNV(video_capture_slot, stream, pname, _params_);
        }
        
        public static void glGetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, int pname, float* _params) {
            Pointers.glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, _params);
        }
        
        public static void glGetVideoCaptureStreamfvNV(uint video_capture_slot, uint stream, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetVideoCaptureStreamfvNV(video_capture_slot, stream, pname, _params_);
        }
        
        public static void glGetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, int pname, int* _params) {
            Pointers.glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, _params);
        }
        
        public static void glGetVideoCaptureStreamivNV(uint video_capture_slot, uint stream, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetVideoCaptureStreamivNV(video_capture_slot, stream, pname, _params_);
        }
        
        public static void glGetVideoCaptureivNV(uint video_capture_slot, int pname, int* _params) {
            Pointers.glGetVideoCaptureivNV(video_capture_slot, pname, _params);
        }
        
        public static void glGetVideoCaptureivNV(uint video_capture_slot, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetVideoCaptureivNV(video_capture_slot, pname, _params_);
        }
        
        public static void glGetVideoi64vNV(uint video_slot, int pname, long* _params) {
            Pointers.glGetVideoi64vNV(video_slot, pname, _params);
        }
        
        public static void glGetVideoi64vNV(uint video_slot, int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetVideoi64vNV(video_slot, pname, _params_);
        }
        
        public static void glGetVideoivNV(uint video_slot, int pname, int* _params) {
            Pointers.glGetVideoivNV(video_slot, pname, _params);
        }
        
        public static void glGetVideoivNV(uint video_slot, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetVideoivNV(video_slot, pname, _params_);
        }
        
        public static void glGetVideoui64vNV(uint video_slot, int pname, ulong* _params) {
            Pointers.glGetVideoui64vNV(video_slot, pname, _params);
        }
        
        public static void glGetVideoui64vNV(uint video_slot, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetVideoui64vNV(video_slot, pname, _params_);
        }
        
        public static void glGetVideouivNV(uint video_slot, int pname, uint* _params) {
            Pointers.glGetVideouivNV(video_slot, pname, _params);
        }
        
        public static void glGetVideouivNV(uint video_slot, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetVideouivNV(video_slot, pname, _params_);
        }
        
        public static void glGetnColorTable(int target, int format, int type, int bufSize, IntPtr table) {
            Pointers.glGetnColorTable(target, format, type, bufSize, table);
        }
        
        public static void glGetnColorTableARB(int target, int format, int type, int bufSize, IntPtr table) {
            Pointers.glGetnColorTableARB(target, format, type, bufSize, table);
        }
        
        public static void glGetnCompressedTexImage(int target, int lod, int bufSize, IntPtr pixels) {
            Pointers.glGetnCompressedTexImage(target, lod, bufSize, pixels);
        }
        
        public static void glGetnCompressedTexImageARB(int target, int lod, int bufSize, IntPtr img) {
            Pointers.glGetnCompressedTexImageARB(target, lod, bufSize, img);
        }
        
        public static void glGetnConvolutionFilter(int target, int format, int type, int bufSize, IntPtr image) {
            Pointers.glGetnConvolutionFilter(target, format, type, bufSize, image);
        }
        
        public static void glGetnConvolutionFilterARB(int target, int format, int type, int bufSize, IntPtr image) {
            Pointers.glGetnConvolutionFilterARB(target, format, type, bufSize, image);
        }
        
        public static void glGetnHistogram(int target, bool reset, int format, int type, int bufSize, IntPtr values) {
            Pointers.glGetnHistogram(target, reset, format, type, bufSize, values);
        }
        
        public static void glGetnHistogramARB(int target, bool reset, int format, int type, int bufSize, IntPtr values) {
            Pointers.glGetnHistogramARB(target, reset, format, type, bufSize, values);
        }
        
        public static void glGetnMapdv(int target, int query, int bufSize, double* v) {
            Pointers.glGetnMapdv(target, query, bufSize, v);
        }
        
        public static void glGetnMapdv(int target, int query, int bufSize, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glGetnMapdv(target, query, bufSize, v_);
        }
        
        public static void glGetnMapdvARB(int target, int query, int bufSize, double* v) {
            Pointers.glGetnMapdvARB(target, query, bufSize, v);
        }
        
        public static void glGetnMapdvARB(int target, int query, int bufSize, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glGetnMapdvARB(target, query, bufSize, v_);
        }
        
        public static void glGetnMapfv(int target, int query, int bufSize, float* v) {
            Pointers.glGetnMapfv(target, query, bufSize, v);
        }
        
        public static void glGetnMapfv(int target, int query, int bufSize, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glGetnMapfv(target, query, bufSize, v_);
        }
        
        public static void glGetnMapfvARB(int target, int query, int bufSize, float* v) {
            Pointers.glGetnMapfvARB(target, query, bufSize, v);
        }
        
        public static void glGetnMapfvARB(int target, int query, int bufSize, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glGetnMapfvARB(target, query, bufSize, v_);
        }
        
        public static void glGetnMapiv(int target, int query, int bufSize, int* v) {
            Pointers.glGetnMapiv(target, query, bufSize, v);
        }
        
        public static void glGetnMapiv(int target, int query, int bufSize, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glGetnMapiv(target, query, bufSize, v_);
        }
        
        public static void glGetnMapivARB(int target, int query, int bufSize, int* v) {
            Pointers.glGetnMapivARB(target, query, bufSize, v);
        }
        
        public static void glGetnMapivARB(int target, int query, int bufSize, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glGetnMapivARB(target, query, bufSize, v_);
        }
        
        public static void glGetnMinmax(int target, bool reset, int format, int type, int bufSize, IntPtr values) {
            Pointers.glGetnMinmax(target, reset, format, type, bufSize, values);
        }
        
        public static void glGetnMinmaxARB(int target, bool reset, int format, int type, int bufSize, IntPtr values) {
            Pointers.glGetnMinmaxARB(target, reset, format, type, bufSize, values);
        }
        
        public static void glGetnPixelMapfv(int map, int bufSize, float* values) {
            Pointers.glGetnPixelMapfv(map, bufSize, values);
        }
        
        public static void glGetnPixelMapfv(int map, int bufSize, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glGetnPixelMapfv(map, bufSize, values_);
        }
        
        public static void glGetnPixelMapfvARB(int map, int bufSize, float* values) {
            Pointers.glGetnPixelMapfvARB(map, bufSize, values);
        }
        
        public static void glGetnPixelMapfvARB(int map, int bufSize, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glGetnPixelMapfvARB(map, bufSize, values_);
        }
        
        public static void glGetnPixelMapuiv(int map, int bufSize, uint* values) {
            Pointers.glGetnPixelMapuiv(map, bufSize, values);
        }
        
        public static void glGetnPixelMapuiv(int map, int bufSize, uint[] values) {
            fixed(uint* values_ = &values[0])
                Pointers.glGetnPixelMapuiv(map, bufSize, values_);
        }
        
        public static void glGetnPixelMapuivARB(int map, int bufSize, uint* values) {
            Pointers.glGetnPixelMapuivARB(map, bufSize, values);
        }
        
        public static void glGetnPixelMapuivARB(int map, int bufSize, uint[] values) {
            fixed(uint* values_ = &values[0])
                Pointers.glGetnPixelMapuivARB(map, bufSize, values_);
        }
        
        public static void glGetnPixelMapusv(int map, int bufSize, ushort* values) {
            Pointers.glGetnPixelMapusv(map, bufSize, values);
        }
        
        public static void glGetnPixelMapusv(int map, int bufSize, ushort[] values) {
            fixed(ushort* values_ = &values[0])
                Pointers.glGetnPixelMapusv(map, bufSize, values_);
        }
        
        public static void glGetnPixelMapusvARB(int map, int bufSize, ushort* values) {
            Pointers.glGetnPixelMapusvARB(map, bufSize, values);
        }
        
        public static void glGetnPixelMapusvARB(int map, int bufSize, ushort[] values) {
            fixed(ushort* values_ = &values[0])
                Pointers.glGetnPixelMapusvARB(map, bufSize, values_);
        }
        
        public static void glGetnPolygonStipple(int bufSize, byte* pattern) {
            Pointers.glGetnPolygonStipple(bufSize, pattern);
        }
        
        public static void glGetnPolygonStipple(int bufSize, byte[] pattern) {
            fixed(byte* pattern_ = &pattern[0])
                Pointers.glGetnPolygonStipple(bufSize, pattern_);
        }
        
        public static void glGetnPolygonStippleARB(int bufSize, byte* pattern) {
            Pointers.glGetnPolygonStippleARB(bufSize, pattern);
        }
        
        public static void glGetnPolygonStippleARB(int bufSize, byte[] pattern) {
            fixed(byte* pattern_ = &pattern[0])
                Pointers.glGetnPolygonStippleARB(bufSize, pattern_);
        }
        
        public static void glGetnSeparableFilter(int target, int format, int type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span) {
            Pointers.glGetnSeparableFilter(target, format, type, rowBufSize, row, columnBufSize, column, span);
        }
        
        public static void glGetnSeparableFilterARB(int target, int format, int type, int rowBufSize, IntPtr row, int columnBufSize, IntPtr column, IntPtr span) {
            Pointers.glGetnSeparableFilterARB(target, format, type, rowBufSize, row, columnBufSize, column, span);
        }
        
        public static void glGetnTexImage(int target, int level, int format, int type, int bufSize, IntPtr pixels) {
            Pointers.glGetnTexImage(target, level, format, type, bufSize, pixels);
        }
        
        public static void glGetnTexImageARB(int target, int level, int format, int type, int bufSize, IntPtr img) {
            Pointers.glGetnTexImageARB(target, level, format, type, bufSize, img);
        }
        
        public static void glGetnUniformdv(uint program, int location, int bufSize, double* _params) {
            Pointers.glGetnUniformdv(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformdv(uint program, int location, int bufSize, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetnUniformdv(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformdvARB(uint program, int location, int bufSize, double* _params) {
            Pointers.glGetnUniformdvARB(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformdvARB(uint program, int location, int bufSize, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glGetnUniformdvARB(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformfv(uint program, int location, int bufSize, float* _params) {
            Pointers.glGetnUniformfv(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformfv(uint program, int location, int bufSize, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetnUniformfv(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformfvARB(uint program, int location, int bufSize, float* _params) {
            Pointers.glGetnUniformfvARB(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformfvARB(uint program, int location, int bufSize, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetnUniformfvARB(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformfvEXT(uint program, int location, int bufSize, float* _params) {
            Pointers.glGetnUniformfvEXT(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformfvEXT(uint program, int location, int bufSize, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetnUniformfvEXT(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformfvKHR(uint program, int location, int bufSize, float* _params) {
            Pointers.glGetnUniformfvKHR(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformfvKHR(uint program, int location, int bufSize, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glGetnUniformfvKHR(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformi64vARB(uint program, int location, int bufSize, long* _params) {
            Pointers.glGetnUniformi64vARB(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformi64vARB(uint program, int location, int bufSize, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glGetnUniformi64vARB(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformiv(uint program, int location, int bufSize, int* _params) {
            Pointers.glGetnUniformiv(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformiv(uint program, int location, int bufSize, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetnUniformiv(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformivARB(uint program, int location, int bufSize, int* _params) {
            Pointers.glGetnUniformivARB(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformivARB(uint program, int location, int bufSize, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetnUniformivARB(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformivEXT(uint program, int location, int bufSize, int* _params) {
            Pointers.glGetnUniformivEXT(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformivEXT(uint program, int location, int bufSize, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetnUniformivEXT(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformivKHR(uint program, int location, int bufSize, int* _params) {
            Pointers.glGetnUniformivKHR(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformivKHR(uint program, int location, int bufSize, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glGetnUniformivKHR(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformui64vARB(uint program, int location, int bufSize, ulong* _params) {
            Pointers.glGetnUniformui64vARB(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformui64vARB(uint program, int location, int bufSize, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glGetnUniformui64vARB(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformuiv(uint program, int location, int bufSize, uint* _params) {
            Pointers.glGetnUniformuiv(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformuiv(uint program, int location, int bufSize, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetnUniformuiv(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformuivARB(uint program, int location, int bufSize, uint* _params) {
            Pointers.glGetnUniformuivARB(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformuivARB(uint program, int location, int bufSize, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetnUniformuivARB(program, location, bufSize, _params_);
        }
        
        public static void glGetnUniformuivKHR(uint program, int location, int bufSize, uint* _params) {
            Pointers.glGetnUniformuivKHR(program, location, bufSize, _params);
        }
        
        public static void glGetnUniformuivKHR(uint program, int location, int bufSize, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glGetnUniformuivKHR(program, location, bufSize, _params_);
        }
        
        public static void glGlobalAlphaFactorbSUN(sbyte factor) {
            Pointers.glGlobalAlphaFactorbSUN(factor);
        }
        
        public static void glGlobalAlphaFactordSUN(double factor) {
            Pointers.glGlobalAlphaFactordSUN(factor);
        }
        
        public static void glGlobalAlphaFactorfSUN(float factor) {
            Pointers.glGlobalAlphaFactorfSUN(factor);
        }
        
        public static void glGlobalAlphaFactoriSUN(int factor) {
            Pointers.glGlobalAlphaFactoriSUN(factor);
        }
        
        public static void glGlobalAlphaFactorsSUN(short factor) {
            Pointers.glGlobalAlphaFactorsSUN(factor);
        }
        
        public static void glGlobalAlphaFactorubSUN(byte factor) {
            Pointers.glGlobalAlphaFactorubSUN(factor);
        }
        
        public static void glGlobalAlphaFactoruiSUN(uint factor) {
            Pointers.glGlobalAlphaFactoruiSUN(factor);
        }
        
        public static void glGlobalAlphaFactorusSUN(ushort factor) {
            Pointers.glGlobalAlphaFactorusSUN(factor);
        }
        
        /// <summary>
        /// specify implementation-specific hints
        /// <para>
        /// Certain aspects of GL behavior, when there is room for interpretation, can be controlled with hints.
        /// A hint is specified with two arguments. target is a symbolic constant indicating the behavior to be
        /// controlled, and mode is another symbolic constant indicating the desired behavior. The initial value
        /// for each target is GL_DONT_CARE. mode can be one of the following:
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating the behavior to be controlled. GL_LINE_SMOOTH_HINT,
        /// GL_POLYGON_SMOOTH_HINT, GL_TEXTURE_COMPRESSION_HINT, and GL_FRAGMENT_SHADER_DERIVATIVE_HINT are
        /// accepted.
        /// </param>
        /// <param name="mode">
        /// Specifies a symbolic constant indicating the desired behavior. GL_FASTEST, GL_NICEST, and
        /// GL_DONT_CARE are accepted.
        /// </param>
        public static void glHint(int target, int mode) {
            Pointers.glHint(target, mode);
        }
        
        public static void glHintPGI(int target, int mode) {
            Pointers.glHintPGI(target, mode);
        }
        
        /// <summary>
        /// define histogram table
        /// <para>
        /// When GL_HISTOGRAM is enabled, RGBA color components are converted to histogram table indices by
        /// clamping to the range [0,1], multiplying by the width of the histogram table, and rounding to the
        /// nearest integer. The table entries selected by the RGBA indices are then incremented. (If the
        /// internal format of the histogram table includes luminance, then the index derived from the R color
        /// component determines the luminance table entry to be incremented.) If a histogram table entry is
        /// incremented beyond its maximum value, then its value becomes undefined. (This is not an error.)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </param>
        /// <param name="width">
        /// The number of entries in the histogram table. Must be a power of 2.
        /// </param>
        /// <param name="internalformat">
        /// The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
        /// GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16,
        /// GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,
        /// GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4,
        /// GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="sink">
        /// If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading
        /// will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming.
        /// </param>
        public static void glHistogram(int target, int width, int internalformat, bool sink) {
            Pointers.glHistogram(target, width, internalformat, sink);
        }
        
        /// <summary>
        /// define histogram table
        /// <para>
        /// When GL_HISTOGRAM is enabled, RGBA color components are converted to histogram table indices by
        /// clamping to the range [0,1], multiplying by the width of the histogram table, and rounding to the
        /// nearest integer. The table entries selected by the RGBA indices are then incremented. (If the
        /// internal format of the histogram table includes luminance, then the index derived from the R color
        /// component determines the luminance table entry to be incremented.) If a histogram table entry is
        /// incremented beyond its maximum value, then its value becomes undefined. (This is not an error.)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The histogram whose parameters are to be set. Must be one of GL_HISTOGRAM or GL_PROXY_HISTOGRAM.
        /// </param>
        /// <param name="width">
        /// The number of entries in the histogram table. Must be a power of 2.
        /// </param>
        /// <param name="internalformat">
        /// The format of entries in the histogram table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
        /// GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16,
        /// GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,
        /// GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4,
        /// GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="sink">
        /// If GL_TRUE, pixels will be consumed by the histogramming process and no drawing or texture loading
        /// will take place. If GL_FALSE, pixels will proceed to the minmax process after histogramming.
        /// </param>
        public static void glHistogramEXT(int target, int width, int internalformat, bool sink) {
            Pointers.glHistogramEXT(target, width, internalformat, sink);
        }
        
        public static void glIglooInterfaceSGIX(int pname, IntPtr _params) {
            Pointers.glIglooInterfaceSGIX(pname, _params);
        }
        
        public static void glImageTransformParameterfHP(int target, int pname, float param) {
            Pointers.glImageTransformParameterfHP(target, pname, param);
        }
        
        public static void glImageTransformParameterfvHP(int target, int pname, float* _params) {
            Pointers.glImageTransformParameterfvHP(target, pname, _params);
        }
        
        public static void glImageTransformParameterfvHP(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glImageTransformParameterfvHP(target, pname, _params_);
        }
        
        public static void glImageTransformParameteriHP(int target, int pname, int param) {
            Pointers.glImageTransformParameteriHP(target, pname, param);
        }
        
        public static void glImageTransformParameterivHP(int target, int pname, int* _params) {
            Pointers.glImageTransformParameterivHP(target, pname, _params);
        }
        
        public static void glImageTransformParameterivHP(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glImageTransformParameterivHP(target, pname, _params_);
        }
        
        public static void glImportMemoryFdEXT(uint memory, ulong size, int handleType, int fd) {
            Pointers.glImportMemoryFdEXT(memory, size, handleType, fd);
        }
        
        public static void glImportMemoryWin32HandleEXT(uint memory, ulong size, int handleType, IntPtr handle) {
            Pointers.glImportMemoryWin32HandleEXT(memory, size, handleType, handle);
        }
        
        public static void glImportMemoryWin32NameEXT(uint memory, ulong size, int handleType, IntPtr name) {
            Pointers.glImportMemoryWin32NameEXT(memory, size, handleType, name);
        }
        
        public static void glImportSemaphoreFdEXT(uint semaphore, int handleType, int fd) {
            Pointers.glImportSemaphoreFdEXT(semaphore, handleType, fd);
        }
        
        public static void glImportSemaphoreWin32HandleEXT(uint semaphore, int handleType, IntPtr handle) {
            Pointers.glImportSemaphoreWin32HandleEXT(semaphore, handleType, handle);
        }
        
        public static void glImportSemaphoreWin32NameEXT(uint semaphore, int handleType, IntPtr name) {
            Pointers.glImportSemaphoreWin32NameEXT(semaphore, handleType, name);
        }
        
        public static IntPtr glImportSyncEXT(int external_sync_type, uint external_sync, uint flags) {
            return Pointers.glImportSyncEXT(external_sync_type, external_sync, flags);
        }
        
        public static void glIndexFormatNV(int type, int stride) {
            Pointers.glIndexFormatNV(type, stride);
        }
        
        public static void glIndexFuncEXT(int func, float _ref) {
            Pointers.glIndexFuncEXT(func, _ref);
        }
        
        /// <summary>
        /// control the writing of individual bits in the color index buffers
        /// <para>
        /// glIndexMask controls the writing of individual bits in the color index buffers. The least
        /// significant n bits of mask, where n is the number of bits in a color index buffer, specify a mask.
        /// Where a 1 (one) appears in the mask, it's possible to write to the corresponding bit in the color
        /// index buffer (or buffers). Where a 0 (zero) appears, the corresponding bit is write-protected
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable the writing of individual bits in the color index
        /// buffers. Initially, the mask is all 1's.
        /// </param>
        public static void glIndexMask(uint mask) {
            Pointers.glIndexMask(mask);
        }
        
        public static void glIndexMaterialEXT(int face, int mode) {
            Pointers.glIndexMaterialEXT(face, mode);
        }
        
        /// <summary>
        /// define an array of color indexes
        /// <para>
        /// glIndexPointer specifies the location and data format of an array of color indexes to use when
        /// rendering. type specifies the data type of each color index and stride specifies the byte stride
        /// from one color index to the next, allowing vertices and attributes to be packed into a single array
        /// or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the data type of each color index in the array. Symbolic constants GL_UNSIGNED_BYTE,
        /// GL_SHORT, GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive color indexes. If stride is 0, the color indexes are
        /// understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first index in the array. The initial value is 0.
        /// </param>
        public static void glIndexPointer(int type, int stride, IntPtr pointer) {
            Pointers.glIndexPointer(type, stride, pointer);
        }
        
        public static void glIndexPointerEXT(int type, int stride, int count, IntPtr pointer) {
            Pointers.glIndexPointerEXT(type, stride, count, pointer);
        }
        
        public static void glIndexPointerListIBM(int type, int stride, IntPtr* pointer, int ptrstride) {
            Pointers.glIndexPointerListIBM(type, stride, pointer, ptrstride);
        }
        
        public static void glIndexPointerListIBM(int type, int stride, IntPtr[] pointer, int ptrstride) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glIndexPointerListIBM(type, stride, pointer_, ptrstride);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexd(double c) {
            Pointers.glIndexd(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexdv(double* c) {
            Pointers.glIndexdv(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexdv(out double c) {
            fixed(double* c_ = &c)
                Pointers.glIndexdv(c_);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexf(float c) {
            Pointers.glIndexf(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexfv(float* c) {
            Pointers.glIndexfv(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexfv(out float c) {
            fixed(float* c_ = &c)
                Pointers.glIndexfv(c_);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexi(int c) {
            Pointers.glIndexi(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexiv(int* c) {
            Pointers.glIndexiv(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexiv(out int c) {
            fixed(int* c_ = &c)
                Pointers.glIndexiv(c_);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexs(short c) {
            Pointers.glIndexs(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexsv(short* c) {
            Pointers.glIndexsv(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexsv(out short c) {
            fixed(short* c_ = &c)
                Pointers.glIndexsv(c_);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexub(byte c) {
            Pointers.glIndexub(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexubv(byte* c) {
            Pointers.glIndexubv(c);
        }
        
        /// <summary>
        /// set the current color index
        /// <para>
        /// glIndex updates the current (single-valued) color index. It takes one argument, the new value for
        /// the current color index
        /// </para>
        /// </summary>
        /// <param name="c">
        /// Specifies the new value for the current color index.
        /// </param>
        public static void glIndexubv(out byte c) {
            fixed(byte* c_ = &c)
                Pointers.glIndexubv(c_);
        }
        
        public static void glIndexxOES(IntPtr component) {
            Pointers.glIndexxOES(component);
        }
        
        public static void glIndexxvOES(IntPtr* component) {
            Pointers.glIndexxvOES(component);
        }
        
        public static void glIndexxvOES(out IntPtr component) {
            fixed(IntPtr* component_ = &component)
                Pointers.glIndexxvOES(component_);
        }
        
        /// <summary>
        /// initialize the name stack
        /// <para>
        /// The name stack is used during selection mode to allow sets of rendering commands to be uniquely
        /// identified. It consists of an ordered set of unsigned integers. glInitNames causes the name stack to
        /// be initialized to its default empty state
        /// </para>
        /// </summary>
        public static void glInitNames() {
            Pointers.glInitNames();
        }
        
        public static void glInsertComponentEXT(uint res, uint src, uint num) {
            Pointers.glInsertComponentEXT(res, src, num);
        }
        
        public static void glInsertEventMarkerEXT(int length, string marker) {
            Pointers.glInsertEventMarkerEXT(length, marker);
        }
        
        public static void glInstrumentsBufferSGIX(int size, int* buffer) {
            Pointers.glInstrumentsBufferSGIX(size, buffer);
        }
        
        public static void glInstrumentsBufferSGIX(int size, int[] buffer) {
            fixed(int* buffer_ = &buffer[0])
                Pointers.glInstrumentsBufferSGIX(size, buffer_);
        }
        
        /// <summary>
        /// simultaneously specify and enable several interleaved arrays
        /// <para>
        /// glInterleavedArrays lets you specify and enable individual color, normal, texture and vertex arrays
        /// whose elements are part of a larger aggregate array element. For some implementations, this is more
        /// efficient than specifying the arrays separately
        /// </para>
        /// </summary>
        /// <param name="format">
        /// Specifies the type of array to enable. Symbolic constants GL_V2F, GL_V3F, GL_C4UB_V2F, GL_C4UB_V3F,
        /// GL_C3F_V3F, GL_N3F_V3F, GL_C4F_N3F_V3F, GL_T2F_V3F, GL_T4F_V4F, GL_T2F_C4UB_V3F, GL_T2F_C3F_V3F,
        /// GL_T2F_N3F_V3F, GL_T2F_C4F_N3F_V3F, and GL_T4F_C4F_N3F_V4F are accepted.
        /// </param>
        /// <param name="stride">
        /// Specifies the offset in bytes between each aggregate array element.
        /// </param>
        /// <param name="pointer"> </param>
        public static void glInterleavedArrays(int format, int stride, IntPtr pointer) {
            Pointers.glInterleavedArrays(format, stride, pointer);
        }
        
        public static void glInterpolatePathsNV(uint resultPath, uint pathA, uint pathB, float weight) {
            Pointers.glInterpolatePathsNV(resultPath, pathA, pathB, weight);
        }
        
        /// <summary>
        /// invalidate the content of a buffer object's data store
        /// <para>
        /// glInvalidateBufferData invalidates all of the content of the data store of a buffer object. After
        /// invalidation, the content of the buffer's data store becomes undefined
        /// </para>
        /// </summary>
        /// <param name="buffer">
        /// The name of a buffer object whose data store to invalidate.
        /// </param>
        public static void glInvalidateBufferData(uint buffer) {
            Pointers.glInvalidateBufferData(buffer);
        }
        
        /// <summary>
        /// invalidate a region of a buffer object's data store
        /// <para>
        /// glInvalidateBufferSubData invalidates all or part of the content of the data store of a buffer
        /// object. After invalidation, the content of the specified range of the buffer's data store becomes
        /// undefined. The start of the range is given by offset and its size is given by length, both measured
        /// in basic machine units
        /// </para>
        /// </summary>
        /// <param name="buffer">
        /// The name of a buffer object, a subrange of whose data store to invalidate.
        /// </param>
        /// <param name="offset">
        /// The offset within the buffer's data store of the start of the range to be invalidated.
        /// </param>
        /// <param name="length">
        /// The length of the range within the buffer's data store to be invalidated.
        /// </param>
        public static void glInvalidateBufferSubData(uint buffer, uint offset, uint length) {
            Pointers.glInvalidateBufferSubData(buffer, offset, length);
        }
        
        /// <summary>
        /// invalidate the content of some or all of a framebuffer's attachments
        /// <para>
        /// glInvalidateFramebuffer and glInvalidateNamedFramebufferData invalidate the entire contents of a
        /// specified set of attachments of a framebuffer
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies the number of entries in the attachments array.
        /// </param>
        /// <param name="attachments">
        /// Specifies a pointer to an array identifying the attachments to be invalidated.
        /// </param>
        public static void glInvalidateFramebuffer(int target, int numAttachments, uint* attachments) {
            Pointers.glInvalidateFramebuffer(target, numAttachments, attachments);
        }
        
        /// <summary>
        /// invalidate the content of some or all of a framebuffer's attachments
        /// <para>
        /// glInvalidateFramebuffer and glInvalidateNamedFramebufferData invalidate the entire contents of a
        /// specified set of attachments of a framebuffer
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is attached for glInvalidateFramebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies the number of entries in the attachments array.
        /// </param>
        /// <param name="attachments">
        /// Specifies a pointer to an array identifying the attachments to be invalidated.
        /// </param>
        public static void glInvalidateFramebuffer(int target, int numAttachments, uint[] attachments) {
            fixed(uint* attachments_ = &attachments[0])
                Pointers.glInvalidateFramebuffer(target, numAttachments, attachments_);
        }
        
        public static void glInvalidateNamedFramebufferData(uint framebuffer, int numAttachments, uint* attachments) {
            Pointers.glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
        }
        
        public static void glInvalidateNamedFramebufferData(uint framebuffer, int numAttachments, uint[] attachments) {
            fixed(uint* attachments_ = &attachments[0])
                Pointers.glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments_);
        }
        
        public static void glInvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, uint* attachments, int x, int y, int width, int height) {
            Pointers.glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
        }
        
        public static void glInvalidateNamedFramebufferSubData(uint framebuffer, int numAttachments, uint[] attachments, int x, int y, int width, int height) {
            fixed(uint* attachments_ = &attachments[0])
                Pointers.glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments_, x, y, width, height);
        }
        
        /// <summary>
        /// invalidate the content of a region of some or all of a framebuffer's attachments
        /// <para>
        /// glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData invalidate the contents of a
        /// specified region of a specified set of attachments of a framebuffer
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies the number of entries in the attachments array.
        /// </param>
        /// <param name="attachments">
        /// Specifies a pointer to an array identifying the attachments to be invalidated.
        /// </param>
        /// <param name="x">
        /// Specifies the X offset of the region to be invalidated.
        /// </param>
        /// <param name="y">
        /// Specifies the Y offset of the region to be invalidated.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the region to be invalidated.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the region to be invalidated.
        /// </param>
        public static void glInvalidateSubFramebuffer(int target, int numAttachments, uint* attachments, int x, int y, int width, int height) {
            Pointers.glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
        }
        
        /// <summary>
        /// invalidate the content of a region of some or all of a framebuffer's attachments
        /// <para>
        /// glInvalidateSubFramebuffer and glInvalidateNamedFramebufferSubData invalidate the contents of a
        /// specified region of a specified set of attachments of a framebuffer
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the framebuffer object is attached for glInvalidateSubFramebuffer.
        /// </param>
        /// <param name="numAttachments">
        /// Specifies the number of entries in the attachments array.
        /// </param>
        /// <param name="attachments">
        /// Specifies a pointer to an array identifying the attachments to be invalidated.
        /// </param>
        /// <param name="x">
        /// Specifies the X offset of the region to be invalidated.
        /// </param>
        /// <param name="y">
        /// Specifies the Y offset of the region to be invalidated.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the region to be invalidated.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the region to be invalidated.
        /// </param>
        public static void glInvalidateSubFramebuffer(int target, int numAttachments, uint[] attachments, int x, int y, int width, int height) {
            fixed(uint* attachments_ = &attachments[0])
                Pointers.glInvalidateSubFramebuffer(target, numAttachments, attachments_, x, y, width, height);
        }
        
        /// <summary>
        /// invalidate the entirety a texture image
        /// <para>
        /// glInvalidateTexSubImage invalidates all of a texture image. texture and level indicated which
        /// texture image is being invalidated. After this command, data in the texture image has undefined
        /// values
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// The name of a texture object to invalidate.
        /// </param>
        /// <param name="level">
        /// The level of detail of the texture object to invalidate.
        /// </param>
        public static void glInvalidateTexImage(uint texture, int level) {
            Pointers.glInvalidateTexImage(texture, level);
        }
        
        /// <summary>
        /// invalidate a region of a texture image
        /// <para>
        /// glInvalidateTexSubImage invalidates all or part of a texture image. texture and level indicated
        /// which texture image is being invalidated. After this command, data in that subregion have undefined
        /// values. xoffset, yoffset, zoffset, width, height, and depth are interpreted as they are in
        /// glTexSubImage3D. For texture targets that don't have certain dimensions, this command treats those
        /// dimensions as having a size of 1. For example, to invalidate a portion of a two- dimensional
        /// texture, the application would use zoffset equal to zero and depth equal to one. Cube map textures
        /// are treated as an array of six slices in the z-dimension, where a value of zoffset is interpreted as
        /// specifying face GL_TEXTURE_CUBE_MAP_POSITIVE_X + zoffset
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// The name of a texture object a subregion of which to invalidate.
        /// </param>
        /// <param name="level">
        /// The level of detail of the texture object within which the region resides.
        /// </param>
        /// <param name="xoffset">
        /// The X offset of the region to be invalidated.
        /// </param>
        /// <param name="yoffset">
        /// The Y offset of the region to be invalidated.
        /// </param>
        /// <param name="zoffset">
        /// The Z offset of the region to be invalidated.
        /// </param>
        /// <param name="width">
        /// The width of the region to be invalidated.
        /// </param>
        /// <param name="height">
        /// The height of the region to be invalidated.
        /// </param>
        /// <param name="depth">
        /// The depth of the region to be invalidated.
        /// </param>
        public static void glInvalidateTexSubImage(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth) {
            Pointers.glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
        }
        
        public static bool glIsAsyncMarkerSGIX(uint marker) {
            return Pointers.glIsAsyncMarkerSGIX(marker);
        }
        
        /// <summary>
        /// determine if a name corresponds to a buffer object
        /// <para>
        /// glIsBuffer returns GL_TRUE if buffer is currently the name of a buffer object. If buffer is zero, or
        /// is a non-zero value that is not currently the name of a buffer object, or if an error occurs,
        /// glIsBuffer returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="buffer">
        /// Specifies a value that may be the name of a buffer object.
        /// </param>
        public static bool glIsBuffer(uint buffer) {
            return Pointers.glIsBuffer(buffer);
        }
        
        /// <summary>
        /// determine if a name corresponds to a buffer object
        /// <para>
        /// glIsBuffer returns GL_TRUE if buffer is currently the name of a buffer object. If buffer is zero, or
        /// is a non-zero value that is not currently the name of a buffer object, or if an error occurs,
        /// glIsBuffer returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="buffer">
        /// Specifies a value that may be the name of a buffer object.
        /// </param>
        public static bool glIsBufferARB(uint buffer) {
            return Pointers.glIsBufferARB(buffer);
        }
        
        public static bool glIsBufferResidentNV(int target) {
            return Pointers.glIsBufferResidentNV(target);
        }
        
        public static bool glIsCommandListNV(uint list) {
            return Pointers.glIsCommandListNV(list);
        }
        
        /// <summary>
        /// test whether a capability is enabled
        /// <para>
        /// glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Boolean
        /// states that are indexed may be tested with glIsEnabledi. For glIsEnabledi, index specifies the index
        /// of the capability to test. index must be between zero and the count of indexed capabilities for cap.
        /// Initially all capabilities except GL_DITHER are disabled; GL_DITHER is initially enabled
        /// </para>
        /// </summary>
        /// <param name="cap">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        public static bool glIsEnabled(int cap) {
            return Pointers.glIsEnabled(cap);
        }
        
        /// <summary>
        /// test whether a capability is enabled
        /// <para>
        /// glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Boolean
        /// states that are indexed may be tested with glIsEnabledi. For glIsEnabledi, index specifies the index
        /// of the capability to test. index must be between zero and the count of indexed capabilities for cap.
        /// Initially all capabilities except GL_DITHER are disabled; GL_DITHER is initially enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the capability.
        /// </param>
        public static bool glIsEnabledIndexedEXT(int target, uint index) {
            return Pointers.glIsEnabledIndexedEXT(target, index);
        }
        
        /// <summary>
        /// test whether a capability is enabled
        /// <para>
        /// glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Boolean
        /// states that are indexed may be tested with glIsEnabledi. For glIsEnabledi, index specifies the index
        /// of the capability to test. index must be between zero and the count of indexed capabilities for cap.
        /// Initially all capabilities except GL_DITHER are disabled; GL_DITHER is initially enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the capability.
        /// </param>
        public static bool glIsEnabledi(int target, uint index) {
            return Pointers.glIsEnabledi(target, index);
        }
        
        /// <summary>
        /// test whether a capability is enabled
        /// <para>
        /// glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Boolean
        /// states that are indexed may be tested with glIsEnabledi. For glIsEnabledi, index specifies the index
        /// of the capability to test. index must be between zero and the count of indexed capabilities for cap.
        /// Initially all capabilities except GL_DITHER are disabled; GL_DITHER is initially enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the capability.
        /// </param>
        public static bool glIsEnablediEXT(int target, uint index) {
            return Pointers.glIsEnablediEXT(target, index);
        }
        
        /// <summary>
        /// test whether a capability is enabled
        /// <para>
        /// glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Boolean
        /// states that are indexed may be tested with glIsEnabledi. For glIsEnabledi, index specifies the index
        /// of the capability to test. index must be between zero and the count of indexed capabilities for cap.
        /// Initially all capabilities except GL_DITHER are disabled; GL_DITHER is initially enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the capability.
        /// </param>
        public static bool glIsEnablediNV(int target, uint index) {
            return Pointers.glIsEnablediNV(target, index);
        }
        
        /// <summary>
        /// test whether a capability is enabled
        /// <para>
        /// glIsEnabled returns GL_TRUE if cap is an enabled capability and returns GL_FALSE otherwise. Boolean
        /// states that are indexed may be tested with glIsEnabledi. For glIsEnabledi, index specifies the index
        /// of the capability to test. index must be between zero and the count of indexed capabilities for cap.
        /// Initially all capabilities except GL_DITHER are disabled; GL_DITHER is initially enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a symbolic constant indicating a GL capability.
        /// </param>
        /// <param name="index">
        /// Specifies the index of the capability.
        /// </param>
        public static bool glIsEnablediOES(int target, uint index) {
            return Pointers.glIsEnablediOES(target, index);
        }
        
        public static bool glIsFenceAPPLE(uint fence) {
            return Pointers.glIsFenceAPPLE(fence);
        }
        
        public static bool glIsFenceNV(uint fence) {
            return Pointers.glIsFenceNV(fence);
        }
        
        /// <summary>
        /// determine if a name corresponds to a framebuffer object
        /// <para>
        /// glIsFramebuffer returns GL_TRUE if framebuffer is currently the name of a framebuffer object. If
        /// framebuffer is zero, or if framebuffer is not the name of a framebuffer object, or if an error
        /// occurs, glIsFramebuffer returns GL_FALSE. If framebuffer is a name returned by glGenFramebuffers, by
        /// that has not yet been bound through a call to glBindFramebuffer, then the name is not a framebuffer
        /// object and glIsFramebuffer returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="framebuffer">
        /// Specifies a value that may be the name of a framebuffer object.
        /// </param>
        public static bool glIsFramebuffer(uint framebuffer) {
            return Pointers.glIsFramebuffer(framebuffer);
        }
        
        /// <summary>
        /// determine if a name corresponds to a framebuffer object
        /// <para>
        /// glIsFramebuffer returns GL_TRUE if framebuffer is currently the name of a framebuffer object. If
        /// framebuffer is zero, or if framebuffer is not the name of a framebuffer object, or if an error
        /// occurs, glIsFramebuffer returns GL_FALSE. If framebuffer is a name returned by glGenFramebuffers, by
        /// that has not yet been bound through a call to glBindFramebuffer, then the name is not a framebuffer
        /// object and glIsFramebuffer returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="framebuffer">
        /// Specifies a value that may be the name of a framebuffer object.
        /// </param>
        public static bool glIsFramebufferEXT(uint framebuffer) {
            return Pointers.glIsFramebufferEXT(framebuffer);
        }
        
        public static bool glIsFramebufferOES(uint framebuffer) {
            return Pointers.glIsFramebufferOES(framebuffer);
        }
        
        public static bool glIsImageHandleResidentARB(ulong handle) {
            return Pointers.glIsImageHandleResidentARB(handle);
        }
        
        public static bool glIsImageHandleResidentNV(ulong handle) {
            return Pointers.glIsImageHandleResidentNV(handle);
        }
        
        /// <summary>
        /// determine if a name corresponds to a display list
        /// <para>
        /// glIsList returns GL_TRUE if list is the name of a display list and returns GL_FALSE if it is not, or
        /// if an error occurs
        /// </para>
        /// </summary>
        /// <param name="list">
        /// Specifies a potential display list name.
        /// </param>
        public static bool glIsList(uint list) {
            return Pointers.glIsList(list);
        }
        
        public static bool glIsMemoryObjectEXT(uint memoryObject) {
            return Pointers.glIsMemoryObjectEXT(memoryObject);
        }
        
        public static bool glIsNameAMD(int identifier, uint name) {
            return Pointers.glIsNameAMD(identifier, name);
        }
        
        public static bool glIsNamedBufferResidentNV(uint buffer) {
            return Pointers.glIsNamedBufferResidentNV(buffer);
        }
        
        public static bool glIsNamedStringARB(int namelen, string name) {
            return Pointers.glIsNamedStringARB(namelen, name);
        }
        
        public static bool glIsObjectBufferATI(uint buffer) {
            return Pointers.glIsObjectBufferATI(buffer);
        }
        
        public static bool glIsOcclusionQueryNV(uint id) {
            return Pointers.glIsOcclusionQueryNV(id);
        }
        
        public static bool glIsPathNV(uint path) {
            return Pointers.glIsPathNV(path);
        }
        
        public static bool glIsPointInFillPathNV(uint path, uint mask, float x, float y) {
            return Pointers.glIsPointInFillPathNV(path, mask, x, y);
        }
        
        public static bool glIsPointInStrokePathNV(uint path, float x, float y) {
            return Pointers.glIsPointInStrokePathNV(path, x, y);
        }
        
        /// <summary>
        /// Determines if a name corresponds to a program object
        /// <para>
        /// glIsProgram returns GL_TRUE if program is the name of a program object previously created with
        /// glCreateProgram and not yet deleted with glDeleteProgram. If program is zero or a non-zero value
        /// that is not the name of a program object, or if an error occurs, glIsProgram returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies a potential program object.
        /// </param>
        public static bool glIsProgram(uint program) {
            return Pointers.glIsProgram(program);
        }
        
        public static bool glIsProgramARB(uint program) {
            return Pointers.glIsProgramARB(program);
        }
        
        public static bool glIsProgramNV(uint id) {
            return Pointers.glIsProgramNV(id);
        }
        
        /// <summary>
        /// determine if a name corresponds to a program pipeline object
        /// <para>
        /// glIsProgramPipeline returns GL_TRUE if pipeline is currently the name of a program pipeline object.
        /// If pipeline is zero, or if pipeline is not the name of a program pipeline object, or if an error
        /// occurs, glIsProgramPipeline returns GL_FALSE. If pipeline is a name returned by
        /// glGenProgramPipelines, but that has not yet been bound through a call to glBindProgramPipeline, then
        /// the name is not a program pipeline object and glIsProgramPipeline returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies a value that may be the name of a program pipeline object.
        /// </param>
        public static bool glIsProgramPipeline(uint pipeline) {
            return Pointers.glIsProgramPipeline(pipeline);
        }
        
        public static bool glIsProgramPipelineEXT(uint pipeline) {
            return Pointers.glIsProgramPipelineEXT(pipeline);
        }
        
        /// <summary>
        /// determine if a name corresponds to a query object
        /// <para>
        /// glIsQuery returns GL_TRUE if id is currently the name of a query object. If id is zero, or is a
        /// non-zero value that is not currently the name of a query object, or if an error occurs, glIsQuery
        /// returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a query object.
        /// </param>
        public static bool glIsQuery(uint id) {
            return Pointers.glIsQuery(id);
        }
        
        /// <summary>
        /// determine if a name corresponds to a query object
        /// <para>
        /// glIsQuery returns GL_TRUE if id is currently the name of a query object. If id is zero, or is a
        /// non-zero value that is not currently the name of a query object, or if an error occurs, glIsQuery
        /// returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a query object.
        /// </param>
        public static bool glIsQueryARB(uint id) {
            return Pointers.glIsQueryARB(id);
        }
        
        public static bool glIsQueryEXT(uint id) {
            return Pointers.glIsQueryEXT(id);
        }
        
        /// <summary>
        /// determine if a name corresponds to a renderbuffer object
        /// <para>
        /// glIsRenderbuffer returns GL_TRUE if renderbuffer is currently the name of a renderbuffer object. If
        /// renderbuffer is zero, or if renderbuffer is not the name of a renderbuffer object, or if an error
        /// occurs, glIsRenderbuffer returns GL_FALSE. If renderbuffer is a name returned by glGenRenderbuffers,
        /// by that has not yet been bound through a call to glBindRenderbuffer or glFramebufferRenderbuffer,
        /// then the name is not a renderbuffer object and glIsRenderbuffer returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="renderbuffer">
        /// Specifies a value that may be the name of a renderbuffer object.
        /// </param>
        public static bool glIsRenderbuffer(uint renderbuffer) {
            return Pointers.glIsRenderbuffer(renderbuffer);
        }
        
        /// <summary>
        /// determine if a name corresponds to a renderbuffer object
        /// <para>
        /// glIsRenderbuffer returns GL_TRUE if renderbuffer is currently the name of a renderbuffer object. If
        /// renderbuffer is zero, or if renderbuffer is not the name of a renderbuffer object, or if an error
        /// occurs, glIsRenderbuffer returns GL_FALSE. If renderbuffer is a name returned by glGenRenderbuffers,
        /// by that has not yet been bound through a call to glBindRenderbuffer or glFramebufferRenderbuffer,
        /// then the name is not a renderbuffer object and glIsRenderbuffer returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="renderbuffer">
        /// Specifies a value that may be the name of a renderbuffer object.
        /// </param>
        public static bool glIsRenderbufferEXT(uint renderbuffer) {
            return Pointers.glIsRenderbufferEXT(renderbuffer);
        }
        
        public static bool glIsRenderbufferOES(uint renderbuffer) {
            return Pointers.glIsRenderbufferOES(renderbuffer);
        }
        
        public static bool glIsSemaphoreEXT(uint semaphore) {
            return Pointers.glIsSemaphoreEXT(semaphore);
        }
        
        /// <summary>
        /// determine if a name corresponds to a sampler object
        /// <para>
        /// glIsSampler returns GL_TRUE if id is currently the name of a sampler object. If id is zero, or is a
        /// non-zero value that is not currently the name of a sampler object, or if an error occurs,
        /// glIsSampler returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies a value that may be the name of a sampler object.
        /// </param>
        public static bool glIsSampler(uint sampler) {
            return Pointers.glIsSampler(sampler);
        }
        
        /// <summary>
        /// Determines if a name corresponds to a shader object
        /// <para>
        /// glIsShader returns GL_TRUE if shader is the name of a shader object previously created with
        /// glCreateShader and not yet deleted with glDeleteShader. If shader is zero or a non-zero value that
        /// is not the name of a shader object, or if an error occurs, glIsShader returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies a potential shader object.
        /// </param>
        public static bool glIsShader(uint shader) {
            return Pointers.glIsShader(shader);
        }
        
        public static bool glIsStateNV(uint state) {
            return Pointers.glIsStateNV(state);
        }
        
        /// <summary>
        /// determine if a name corresponds to a sync object
        /// <para>
        /// glIsSync returns GL_TRUE if sync is currently the name of a sync object. If sync is not the name of
        /// a sync object, or if an error occurs, glIsSync returns GL_FALSE. Note that zero is not the name of a
        /// sync object
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies a value that may be the name of a sync object.
        /// </param>
        public static bool glIsSync(IntPtr sync) {
            return Pointers.glIsSync(sync);
        }
        
        /// <summary>
        /// determine if a name corresponds to a sync object
        /// <para>
        /// glIsSync returns GL_TRUE if sync is currently the name of a sync object. If sync is not the name of
        /// a sync object, or if an error occurs, glIsSync returns GL_FALSE. Note that zero is not the name of a
        /// sync object
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies a value that may be the name of a sync object.
        /// </param>
        public static bool glIsSyncAPPLE(IntPtr sync) {
            return Pointers.glIsSyncAPPLE(sync);
        }
        
        /// <summary>
        /// determine if a name corresponds to a texture
        /// <para>
        /// glIsTexture returns GL_TRUE if texture is currently the name of a texture. If texture is zero, or is
        /// a non-zero value that is not currently the name of a texture, or if an error occurs, glIsTexture
        /// returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies a value that may be the name of a texture.
        /// </param>
        public static bool glIsTexture(uint texture) {
            return Pointers.glIsTexture(texture);
        }
        
        public static bool glIsTextureEXT(uint texture) {
            return Pointers.glIsTextureEXT(texture);
        }
        
        public static bool glIsTextureHandleResidentARB(ulong handle) {
            return Pointers.glIsTextureHandleResidentARB(handle);
        }
        
        public static bool glIsTextureHandleResidentNV(ulong handle) {
            return Pointers.glIsTextureHandleResidentNV(handle);
        }
        
        /// <summary>
        /// determine if a name corresponds to a transform feedback object
        /// <para>
        /// glIsTransformFeedback returns GL_TRUE if id is currently the name of a transform feedback object. If
        /// id is zero, or if id is not the name of a transform feedback object, or if an error occurs,
        /// glIsTransformFeedback returns GL_FALSE. If id is a name returned by glGenTransformFeedbacks, but
        /// that has not yet been bound through a call to glBindTransformFeedback, then the name is not a
        /// transform feedback object and glIsTransformFeedback returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a transform feedback object.
        /// </param>
        public static bool glIsTransformFeedback(uint id) {
            return Pointers.glIsTransformFeedback(id);
        }
        
        /// <summary>
        /// determine if a name corresponds to a transform feedback object
        /// <para>
        /// glIsTransformFeedback returns GL_TRUE if id is currently the name of a transform feedback object. If
        /// id is zero, or if id is not the name of a transform feedback object, or if an error occurs,
        /// glIsTransformFeedback returns GL_FALSE. If id is a name returned by glGenTransformFeedbacks, but
        /// that has not yet been bound through a call to glBindTransformFeedback, then the name is not a
        /// transform feedback object and glIsTransformFeedback returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specifies a value that may be the name of a transform feedback object.
        /// </param>
        public static bool glIsTransformFeedbackNV(uint id) {
            return Pointers.glIsTransformFeedbackNV(id);
        }
        
        public static bool glIsVariantEnabledEXT(uint id, int cap) {
            return Pointers.glIsVariantEnabledEXT(id, cap);
        }
        
        /// <summary>
        /// determine if a name corresponds to a vertex array object
        /// <para>
        /// glIsVertexArray returns GL_TRUE if array is currently the name of a vertex array object. If array is
        /// zero, or if array is not the name of a vertex array object, or if an error occurs, glIsVertexArray
        /// returns GL_FALSE. If array is a name returned by glGenVertexArrays, by that has not yet been bound
        /// through a call to glBindVertexArray, then the name is not a vertex array object and glIsVertexArray
        /// returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="array">
        /// Specifies a value that may be the name of a vertex array object.
        /// </param>
        public static bool glIsVertexArray(uint array) {
            return Pointers.glIsVertexArray(array);
        }
        
        /// <summary>
        /// determine if a name corresponds to a vertex array object
        /// <para>
        /// glIsVertexArray returns GL_TRUE if array is currently the name of a vertex array object. If array is
        /// zero, or if array is not the name of a vertex array object, or if an error occurs, glIsVertexArray
        /// returns GL_FALSE. If array is a name returned by glGenVertexArrays, by that has not yet been bound
        /// through a call to glBindVertexArray, then the name is not a vertex array object and glIsVertexArray
        /// returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="array">
        /// Specifies a value that may be the name of a vertex array object.
        /// </param>
        public static bool glIsVertexArrayAPPLE(uint array) {
            return Pointers.glIsVertexArrayAPPLE(array);
        }
        
        /// <summary>
        /// determine if a name corresponds to a vertex array object
        /// <para>
        /// glIsVertexArray returns GL_TRUE if array is currently the name of a vertex array object. If array is
        /// zero, or if array is not the name of a vertex array object, or if an error occurs, glIsVertexArray
        /// returns GL_FALSE. If array is a name returned by glGenVertexArrays, by that has not yet been bound
        /// through a call to glBindVertexArray, then the name is not a vertex array object and glIsVertexArray
        /// returns GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="array">
        /// Specifies a value that may be the name of a vertex array object.
        /// </param>
        public static bool glIsVertexArrayOES(uint array) {
            return Pointers.glIsVertexArrayOES(array);
        }
        
        public static bool glIsVertexAttribEnabledAPPLE(uint index, int pname) {
            return Pointers.glIsVertexAttribEnabledAPPLE(index, pname);
        }
        
        public static void glLGPUCopyImageSubDataNVX(uint sourceGpu, uint destinationGpuMask, uint srcName, int srcTarget, int srcLevel, int srcX, int srxY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int width, int height, int depth) {
            Pointers.glLGPUCopyImageSubDataNVX(sourceGpu, destinationGpuMask, srcName, srcTarget, srcLevel, srcX, srxY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth);
        }
        
        public static void glLGPUInterlockNVX() {
            Pointers.glLGPUInterlockNVX();
        }
        
        public static void glLGPUNamedBufferSubDataNVX(uint gpuMask, uint buffer, uint offset, uint size, IntPtr data) {
            Pointers.glLGPUNamedBufferSubDataNVX(gpuMask, buffer, offset, size, data);
        }
        
        public static void glLabelObjectEXT(int type, uint _object, int length, string label) {
            Pointers.glLabelObjectEXT(type, _object, length, label);
        }
        
        public static void glLightEnviSGIX(int pname, int param) {
            Pointers.glLightEnviSGIX(pname, param);
        }
        
        /// <summary>
        /// set the lighting model parameters
        /// <para>
        /// glLightModel sets the lighting model parameter. pname names a parameter and params gives the new
        /// value. There are three lighting model parameters:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER,
        /// GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        /// <param name="param">
        /// Specifies the value that param will be set to.
        /// </param>
        public static void glLightModelf(int pname, float param) {
            Pointers.glLightModelf(pname, param);
        }
        
        /// <summary>
        /// set the lighting model parameters
        /// <para>
        /// glLightModel sets the lighting model parameter. pname names a parameter and params gives the new
        /// value. There are three lighting model parameters:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER,
        /// GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a lighting model parameter. GL_LIGHT_MODEL_AMBIENT, GL_LIGHT_MODEL_COLOR_CONTROL,
        /// GL_LIGHT_MODEL_LOCAL_VIEWER, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        public static void glLightModelfv(int pname, float* _params) {
            Pointers.glLightModelfv(pname, _params);
        }
        
        /// <summary>
        /// set the lighting model parameters
        /// <para>
        /// glLightModel sets the lighting model parameter. pname names a parameter and params gives the new
        /// value. There are three lighting model parameters:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER,
        /// GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a lighting model parameter. GL_LIGHT_MODEL_AMBIENT, GL_LIGHT_MODEL_COLOR_CONTROL,
        /// GL_LIGHT_MODEL_LOCAL_VIEWER, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        public static void glLightModelfv(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glLightModelfv(pname, _params_);
        }
        
        /// <summary>
        /// set the lighting model parameters
        /// <para>
        /// glLightModel sets the lighting model parameter. pname names a parameter and params gives the new
        /// value. There are three lighting model parameters:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER,
        /// GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        /// <param name="param">
        /// Specifies the value that param will be set to.
        /// </param>
        public static void glLightModeli(int pname, int param) {
            Pointers.glLightModeli(pname, param);
        }
        
        /// <summary>
        /// set the lighting model parameters
        /// <para>
        /// glLightModel sets the lighting model parameter. pname names a parameter and params gives the new
        /// value. There are three lighting model parameters:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER,
        /// GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a lighting model parameter. GL_LIGHT_MODEL_AMBIENT, GL_LIGHT_MODEL_COLOR_CONTROL,
        /// GL_LIGHT_MODEL_LOCAL_VIEWER, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        public static void glLightModeliv(int pname, int* _params) {
            Pointers.glLightModeliv(pname, _params);
        }
        
        /// <summary>
        /// set the lighting model parameters
        /// <para>
        /// glLightModel sets the lighting model parameter. pname names a parameter and params gives the new
        /// value. There are three lighting model parameters:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued lighting model parameter. GL_LIGHT_MODEL_LOCAL_VIEWER,
        /// GL_LIGHT_MODEL_COLOR_CONTROL, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a lighting model parameter. GL_LIGHT_MODEL_AMBIENT, GL_LIGHT_MODEL_COLOR_CONTROL,
        /// GL_LIGHT_MODEL_LOCAL_VIEWER, and GL_LIGHT_MODEL_TWO_SIDE are accepted.
        /// </param>
        public static void glLightModeliv(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glLightModeliv(pname, _params_);
        }
        
        public static void glLightModelx(int pname, IntPtr param) {
            Pointers.glLightModelx(pname, param);
        }
        
        public static void glLightModelxOES(int pname, IntPtr param) {
            Pointers.glLightModelxOES(pname, param);
        }
        
        public static void glLightModelxv(int pname, IntPtr* param) {
            Pointers.glLightModelxv(pname, param);
        }
        
        public static void glLightModelxv(int pname, IntPtr[] param) {
            fixed(IntPtr* param_ = &param[0])
                Pointers.glLightModelxv(pname, param_);
        }
        
        public static void glLightModelxvOES(int pname, IntPtr* param) {
            Pointers.glLightModelxvOES(pname, param);
        }
        
        public static void glLightModelxvOES(int pname, IntPtr[] param) {
            fixed(IntPtr* param_ = &param[0])
                Pointers.glLightModelxvOES(pname, param_);
        }
        
        /// <summary>
        /// set light source parameters
        /// <para>
        /// glLight sets the values of individual light source parameters. light names the light and is a
        /// symbolic name of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. pname
        /// specifies one of ten light source parameters, again by symbolic name. params is either a single
        /// value or a pointer to an array that contains the new values
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </param>
        public static void glLightf(int light, int pname, float param) {
            Pointers.glLightf(light, pname, param);
        }
        
        /// <summary>
        /// set light source parameters
        /// <para>
        /// glLight sets the values of individual light source parameters. light names the light and is a
        /// symbolic name of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. pname
        /// specifies one of ten light source parameters, again by symbolic name. params is either a single
        /// value or a pointer to an array that contains the new values
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        public static void glLightfv(int light, int pname, float* _params) {
            Pointers.glLightfv(light, pname, _params);
        }
        
        /// <summary>
        /// set light source parameters
        /// <para>
        /// glLight sets the values of individual light source parameters. light names the light and is a
        /// symbolic name of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. pname
        /// specifies one of ten light source parameters, again by symbolic name. params is either a single
        /// value or a pointer to an array that contains the new values
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        public static void glLightfv(int light, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glLightfv(light, pname, _params_);
        }
        
        /// <summary>
        /// set light source parameters
        /// <para>
        /// glLight sets the values of individual light source parameters. light names the light and is a
        /// symbolic name of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. pname
        /// specifies one of ten light source parameters, again by symbolic name. params is either a single
        /// value or a pointer to an array that contains the new values
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter pname of light source light will be set to.
        /// </param>
        public static void glLighti(int light, int pname, int param) {
            Pointers.glLighti(light, pname, param);
        }
        
        /// <summary>
        /// set light source parameters
        /// <para>
        /// glLight sets the values of individual light source parameters. light names the light and is a
        /// symbolic name of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. pname
        /// specifies one of ten light source parameters, again by symbolic name. params is either a single
        /// value or a pointer to an array that contains the new values
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        public static void glLightiv(int light, int pname, int* _params) {
            Pointers.glLightiv(light, pname, _params);
        }
        
        /// <summary>
        /// set light source parameters
        /// <para>
        /// glLight sets the values of individual light source parameters. light names the light and is a
        /// symbolic name of the form GL_LIGHT i, where i ranges from 0 to the value of GL_MAX_LIGHTS - 1. pname
        /// specifies one of ten light source parameters, again by symbolic name. params is either a single
        /// value or a pointer to an array that contains the new values
        /// </para>
        /// </summary>
        /// <param name="light">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        /// <param name="pname">
        /// Specifies a single-valued light source parameter for light. GL_SPOT_EXPONENT, GL_SPOT_CUTOFF,
        /// GL_CONSTANT_ATTENUATION, GL_LINEAR_ATTENUATION, and GL_QUADRATIC_ATTENUATION are accepted.
        /// </param>
        /// <param name="_params">
        /// Specifies a light. The number of lights depends on the implementation, but at least eight lights are
        /// supported. They are identified by symbolic names of the form GL_LIGHT i, where i ranges from 0 to
        /// the value of GL_MAX_LIGHTS - 1.
        /// </param>
        public static void glLightiv(int light, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glLightiv(light, pname, _params_);
        }
        
        public static void glLightx(int light, int pname, IntPtr param) {
            Pointers.glLightx(light, pname, param);
        }
        
        public static void glLightxOES(int light, int pname, IntPtr param) {
            Pointers.glLightxOES(light, pname, param);
        }
        
        public static void glLightxv(int light, int pname, IntPtr* _params) {
            Pointers.glLightxv(light, pname, _params);
        }
        
        public static void glLightxv(int light, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glLightxv(light, pname, _params_);
        }
        
        public static void glLightxvOES(int light, int pname, IntPtr* _params) {
            Pointers.glLightxvOES(light, pname, _params);
        }
        
        public static void glLightxvOES(int light, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glLightxvOES(light, pname, _params_);
        }
        
        /// <summary>
        /// specify the line stipple pattern
        /// <para>
        /// Line stippling masks out certain fragments produced by rasterization; those fragments will not be
        /// drawn. The masking is achieved by using three parameters: the 16-bit line stipple pattern pattern,
        /// the repeat count factor, and an integer stipple counter s
        /// </para>
        /// </summary>
        /// <param name="factor">
        /// Specifies a multiplier for each bit in the line stipple pattern. If factor is 3, for example, each
        /// bit in the pattern is used three times before the next bit in the pattern is used. factor is clamped
        /// to the range [1, 256] and defaults to 1.
        /// </param>
        /// <param name="pattern">
        /// Specifies a 16-bit integer whose bit pattern determines which fragments of a line will be drawn when
        /// the line is rasterized. Bit zero is used first; the default pattern is all 1's.
        /// </param>
        public static void glLineStipple(int factor, ushort pattern) {
            Pointers.glLineStipple(factor, pattern);
        }
        
        /// <summary>
        /// specify the width of rasterized lines
        /// <para>
        /// glLineWidth specifies the rasterized width of both aliased and antialiased lines. Using a line width
        /// other than 1 has different effects, depending on whether line antialiasing is enabled. To enable and
        /// disable line antialiasing, call glEnable and glDisable with argument GL_LINE_SMOOTH. Line
        /// antialiasing is initially disabled
        /// </para>
        /// </summary>
        /// <param name="width">
        /// Specifies the width of rasterized lines. The initial value is 1.
        /// </param>
        public static void glLineWidth(float width) {
            Pointers.glLineWidth(width);
        }
        
        public static void glLineWidthx(IntPtr width) {
            Pointers.glLineWidthx(width);
        }
        
        public static void glLineWidthxOES(IntPtr width) {
            Pointers.glLineWidthxOES(width);
        }
        
        /// <summary>
        /// Links a program object
        /// <para>
        /// glLinkProgram links the program object specified by program. If any shader objects of type
        /// GL_VERTEX_SHADER are attached to program, they will be used to create an executable that will run on
        /// the programmable vertex processor. If any shader objects of type GL_GEOMETRY_SHADER are attached to
        /// program, they will be used to create an executable that will run on the programmable geometry
        /// processor. If any shader objects of type GL_FRAGMENT_SHADER are attached to program, they will be
        /// used to create an executable that will run on the programmable fragment processor
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be linked.
        /// </param>
        public static void glLinkProgram(uint program) {
            Pointers.glLinkProgram(program);
        }
        
        /// <summary>
        /// Links a program object
        /// <para>
        /// glLinkProgram links the program object specified by program. If any shader objects of type
        /// GL_VERTEX_SHADER are attached to program, they will be used to create an executable that will run on
        /// the programmable vertex processor. If any shader objects of type GL_GEOMETRY_SHADER are attached to
        /// program, they will be used to create an executable that will run on the programmable geometry
        /// processor. If any shader objects of type GL_FRAGMENT_SHADER are attached to program, they will be
        /// used to create an executable that will run on the programmable fragment processor
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the handle of the program object to be linked.
        /// </param>
        public static void glLinkProgramARB(uint programObj) {
            Pointers.glLinkProgramARB(programObj);
        }
        
        /// <summary>
        /// set the display-list base for glCallLists
        /// <para>
        /// glCallLists specifies an array of offsets. Display-list names are generated by adding base to each
        /// offset. Names that reference valid display lists are executed; the others are ignored
        /// </para>
        /// </summary>
        /// <param name="_base">
        /// Specifies an integer offset that will be added to glCallLists offsets to generate display-list
        /// names. The initial value is 0.
        /// </param>
        public static void glListBase(uint _base) {
            Pointers.glListBase(_base);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int* sizes, uint* states, uint* fbos, uint count) {
            Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int* sizes, uint* states, uint[] fbos, uint count) {
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states, fbos_, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int* sizes, uint[] states, uint* fbos, uint count) {
            fixed(uint* states_ = &states[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states_, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int* sizes, uint[] states, uint[] fbos, uint count) {
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes, states_, fbos_, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int[] sizes, uint* states, uint* fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes_, states, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int[] sizes, uint* states, uint[] fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes_, states, fbos_, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int[] sizes, uint[] states, uint* fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes_, states_, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr* indirects, int[] sizes, uint[] states, uint[] fbos, uint count) {
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects, sizes_, states_, fbos_, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int* sizes, uint* states, uint* fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes, states, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int* sizes, uint* states, uint[] fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes, states, fbos_, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int* sizes, uint[] states, uint* fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
            fixed(uint* states_ = &states[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes, states_, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int* sizes, uint[] states, uint[] fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes, states_, fbos_, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int[] sizes, uint* states, uint* fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes_, states, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int[] sizes, uint* states, uint[] fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes_, states, fbos_, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int[] sizes, uint[] states, uint* fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes_, states_, fbos, count);
        }
        
        public static void glListDrawCommandsStatesClientNV(uint list, uint segment, IntPtr[] indirects, int[] sizes, uint[] states, uint[] fbos, uint count) {
            fixed(IntPtr* indirects_ = &indirects[0])
            fixed(int* sizes_ = &sizes[0])
            fixed(uint* states_ = &states[0])
            fixed(uint* fbos_ = &fbos[0])
                Pointers.glListDrawCommandsStatesClientNV(list, segment, indirects_, sizes_, states_, fbos_, count);
        }
        
        public static void glListParameterfSGIX(uint list, int pname, float param) {
            Pointers.glListParameterfSGIX(list, pname, param);
        }
        
        public static void glListParameterfvSGIX(uint list, int pname, float* _params) {
            Pointers.glListParameterfvSGIX(list, pname, _params);
        }
        
        public static void glListParameterfvSGIX(uint list, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glListParameterfvSGIX(list, pname, _params_);
        }
        
        public static void glListParameteriSGIX(uint list, int pname, int param) {
            Pointers.glListParameteriSGIX(list, pname, param);
        }
        
        public static void glListParameterivSGIX(uint list, int pname, int* _params) {
            Pointers.glListParameterivSGIX(list, pname, _params);
        }
        
        public static void glListParameterivSGIX(uint list, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glListParameterivSGIX(list, pname, _params_);
        }
        
        /// <summary>
        /// replace the current matrix with the identity matrix
        /// <para>
        /// glLoadIdentity replaces the current matrix with the identity matrix. It is semantically equivalent
        /// to calling glLoadMatrix with the identity matrix
        /// </para>
        /// </summary>
        public static void glLoadIdentity() {
            Pointers.glLoadIdentity();
        }
        
        public static void glLoadIdentityDeformationMapSGIX(uint mask) {
            Pointers.glLoadIdentityDeformationMapSGIX(mask);
        }
        
        public static void glLoadIdentityDeformationMapSGIX(Enums.FfdMaskSGIX mask) {
            Pointers.glLoadIdentityDeformationMapSGIX((uint)mask);
        }
        
        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>
        /// glLoadMatrix replaces the current matrix with the one whose elements are specified by m. The current
        /// matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current
        /// matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// column-major matrix.
        /// </param>
        public static void glLoadMatrixd(double* m) {
            Pointers.glLoadMatrixd(m);
        }
        
        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>
        /// glLoadMatrix replaces the current matrix with the one whose elements are specified by m. The current
        /// matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current
        /// matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// column-major matrix.
        /// </param>
        public static void glLoadMatrixd(double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glLoadMatrixd(m_);
        }
        
        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>
        /// glLoadMatrix replaces the current matrix with the one whose elements are specified by m. The current
        /// matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current
        /// matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// column-major matrix.
        /// </param>
        public static void glLoadMatrixf(float* m) {
            Pointers.glLoadMatrixf(m);
        }
        
        /// <summary>
        /// replace the current matrix with the specified matrix
        /// <para>
        /// glLoadMatrix replaces the current matrix with the one whose elements are specified by m. The current
        /// matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current
        /// matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// column-major matrix.
        /// </param>
        public static void glLoadMatrixf(float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glLoadMatrixf(m_);
        }
        
        public static void glLoadMatrixx(IntPtr* m) {
            Pointers.glLoadMatrixx(m);
        }
        
        public static void glLoadMatrixx(IntPtr[] m) {
            fixed(IntPtr* m_ = &m[0])
                Pointers.glLoadMatrixx(m_);
        }
        
        public static void glLoadMatrixxOES(IntPtr* m) {
            Pointers.glLoadMatrixxOES(m);
        }
        
        public static void glLoadMatrixxOES(IntPtr[] m) {
            fixed(IntPtr* m_ = &m[0])
                Pointers.glLoadMatrixxOES(m_);
        }
        
        /// <summary>
        /// load a name onto the name stack
        /// <para>
        /// The name stack is used during selection mode to allow sets of rendering commands to be uniquely
        /// identified. It consists of an ordered set of unsigned integers and is initially empty
        /// </para>
        /// </summary>
        /// <param name="name">
        /// Specifies a name that will replace the top value on the name stack.
        /// </param>
        public static void glLoadName(uint name) {
            Pointers.glLoadName(name);
        }
        
        public static void glLoadPaletteFromModelViewMatrixOES() {
            Pointers.glLoadPaletteFromModelViewMatrixOES();
        }
        
        public static void glLoadProgramNV(int target, uint id, int len, byte* program) {
            Pointers.glLoadProgramNV(target, id, len, program);
        }
        
        public static void glLoadProgramNV(int target, uint id, int len, byte[] program) {
            fixed(byte* program_ = &program[0])
                Pointers.glLoadProgramNV(target, id, len, program_);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixd(double* m) {
            Pointers.glLoadTransposeMatrixd(m);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixd(double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glLoadTransposeMatrixd(m_);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixdARB(double* m) {
            Pointers.glLoadTransposeMatrixdARB(m);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixdARB(double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glLoadTransposeMatrixdARB(m_);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixf(float* m) {
            Pointers.glLoadTransposeMatrixf(m);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixf(float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glLoadTransposeMatrixf(m_);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixfARB(float* m) {
            Pointers.glLoadTransposeMatrixfARB(m);
        }
        
        /// <summary>
        /// replace the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glLoadTransposeMatrix replaces the current matrix with the one whose elements are specified by m.
        /// The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the
        /// current matrix mode (see glMatrixMode)
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Specifies a pointer to 16 consecutive values, which are used as the elements of a 4 &times; 4
        /// row-major matrix.
        /// </param>
        public static void glLoadTransposeMatrixfARB(float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glLoadTransposeMatrixfARB(m_);
        }
        
        public static void glLoadTransposeMatrixxOES(IntPtr* m) {
            Pointers.glLoadTransposeMatrixxOES(m);
        }
        
        public static void glLoadTransposeMatrixxOES(IntPtr[] m) {
            fixed(IntPtr* m_ = &m[0])
                Pointers.glLoadTransposeMatrixxOES(m_);
        }
        
        public static void glLockArraysEXT(int first, int count) {
            Pointers.glLockArraysEXT(first, count);
        }
        
        /// <summary>
        /// specify a logical pixel operation for rendering
        /// <para>
        /// glLogicOp specifies a logical operation that, when enabled, is applied between the incoming RGBA
        /// color and the RGBA color at the corresponding location in the frame buffer. To enable or disable the
        /// logical operation, call glEnable and glDisable using the symbolic constant GL_COLOR_LOGIC_OP. The
        /// initial value is disabled
        /// </para>
        /// </summary>
        /// <param name="opcode">
        /// Specifies a symbolic constant that selects a logical operation. The following symbols are accepted:
        /// GL_CLEAR, GL_SET, GL_COPY, GL_COPY_INVERTED, GL_NOOP, GL_INVERT, GL_AND, GL_NAND, GL_OR, GL_NOR,
        /// GL_XOR, GL_EQUIV, GL_AND_REVERSE, GL_AND_INVERTED, GL_OR_REVERSE, and GL_OR_INVERTED. The initial
        /// value is GL_COPY.
        /// </param>
        public static void glLogicOp(int opcode) {
            Pointers.glLogicOp(opcode);
        }
        
        public static void glMakeBufferNonResidentNV(int target) {
            Pointers.glMakeBufferNonResidentNV(target);
        }
        
        public static void glMakeBufferResidentNV(int target, int access) {
            Pointers.glMakeBufferResidentNV(target, access);
        }
        
        public static void glMakeImageHandleNonResidentARB(ulong handle) {
            Pointers.glMakeImageHandleNonResidentARB(handle);
        }
        
        public static void glMakeImageHandleNonResidentNV(ulong handle) {
            Pointers.glMakeImageHandleNonResidentNV(handle);
        }
        
        public static void glMakeImageHandleResidentARB(ulong handle, int access) {
            Pointers.glMakeImageHandleResidentARB(handle, access);
        }
        
        public static void glMakeImageHandleResidentNV(ulong handle, int access) {
            Pointers.glMakeImageHandleResidentNV(handle, access);
        }
        
        public static void glMakeNamedBufferNonResidentNV(uint buffer) {
            Pointers.glMakeNamedBufferNonResidentNV(buffer);
        }
        
        public static void glMakeNamedBufferResidentNV(uint buffer, int access) {
            Pointers.glMakeNamedBufferResidentNV(buffer, access);
        }
        
        public static void glMakeTextureHandleNonResidentARB(ulong handle) {
            Pointers.glMakeTextureHandleNonResidentARB(handle);
        }
        
        public static void glMakeTextureHandleNonResidentNV(ulong handle) {
            Pointers.glMakeTextureHandleNonResidentNV(handle);
        }
        
        public static void glMakeTextureHandleResidentARB(ulong handle) {
            Pointers.glMakeTextureHandleResidentARB(handle);
        }
        
        public static void glMakeTextureHandleResidentNV(ulong handle) {
            Pointers.glMakeTextureHandleResidentNV(handle);
        }
        
        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL,
        /// GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and
        /// GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="stride">
        /// Specifies the number of floats or doubles between the beginning of one control point and the
        /// beginning of the next one in the data structure referenced in points. This allows control points to
        /// be embedded in arbitrary data structures. The only constraint is that the values for a particular
        /// control point must occupy contiguous memory locations.
        /// </param>
        /// <param name="order">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        /// <param name="points">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        public static void glMap1d(int target, double u1, double u2, int stride, int order, double* points) {
            Pointers.glMap1d(target, u1, u2, stride, order, points);
        }
        
        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL,
        /// GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and
        /// GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="stride">
        /// Specifies the number of floats or doubles between the beginning of one control point and the
        /// beginning of the next one in the data structure referenced in points. This allows control points to
        /// be embedded in arbitrary data structures. The only constraint is that the values for a particular
        /// control point must occupy contiguous memory locations.
        /// </param>
        /// <param name="order">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        /// <param name="points">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        public static void glMap1d(int target, double u1, double u2, int stride, int order, double[] points) {
            fixed(double* points_ = &points[0])
                Pointers.glMap1d(target, u1, u2, stride, order, points_);
        }
        
        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL,
        /// GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and
        /// GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="stride">
        /// Specifies the number of floats or doubles between the beginning of one control point and the
        /// beginning of the next one in the data structure referenced in points. This allows control points to
        /// be embedded in arbitrary data structures. The only constraint is that the values for a particular
        /// control point must occupy contiguous memory locations.
        /// </param>
        /// <param name="order">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        /// <param name="points">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        public static void glMap1f(int target, float u1, float u2, int stride, int order, float* points) {
            Pointers.glMap1f(target, u1, u2, stride, order, points);
        }
        
        /// <summary>
        /// define a one-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP1_VERTEX_3, GL_MAP1_VERTEX_4, GL_MAP1_INDEX, GL_MAP1_COLOR_4, GL_MAP1_NORMAL,
        /// GL_MAP1_TEXTURE_COORD_1, GL_MAP1_TEXTURE_COORD_2, GL_MAP1_TEXTURE_COORD_3, and
        /// GL_MAP1_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord1, to u&Hat; , the variable that is
        /// evaluated by the equations specified by this command.
        /// </param>
        /// <param name="stride">
        /// Specifies the number of floats or doubles between the beginning of one control point and the
        /// beginning of the next one in the data structure referenced in points. This allows control points to
        /// be embedded in arbitrary data structures. The only constraint is that the values for a particular
        /// control point must occupy contiguous memory locations.
        /// </param>
        /// <param name="order">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        /// <param name="points">
        /// Specifies the number of control points. Must be positive.
        /// </param>
        public static void glMap1f(int target, float u1, float u2, int stride, int order, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glMap1f(target, u1, u2, stride, order, points_);
        }
        
        public static void glMap1xOES(int target, IntPtr u1, IntPtr u2, int stride, int order, IntPtr points) {
            Pointers.glMap1xOES(target, u1, u2, stride, order, points);
        }
        
        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL,
        /// GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and
        /// GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="ustride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i + 1 &it; j , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of ustride is 0.
        /// </param>
        /// <param name="uorder">
        /// Specifies the dimension of the control point array in the u axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="v1">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="v2">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="vstride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i &af; j + 1 , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of vstride is 0.
        /// </param>
        /// <param name="vorder">
        /// Specifies the dimension of the control point array in the v axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) {
            Pointers.glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        
        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL,
        /// GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and
        /// GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="ustride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i + 1 &it; j , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of ustride is 0.
        /// </param>
        /// <param name="uorder">
        /// Specifies the dimension of the control point array in the u axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="v1">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="v2">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="vstride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i &af; j + 1 , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of vstride is 0.
        /// </param>
        /// <param name="vorder">
        /// Specifies the dimension of the control point array in the v axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        public static void glMap2d(int target, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points) {
            fixed(double* points_ = &points[0])
                Pointers.glMap2d(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_);
        }
        
        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL,
        /// GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and
        /// GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="ustride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i + 1 &it; j , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of ustride is 0.
        /// </param>
        /// <param name="uorder">
        /// Specifies the dimension of the control point array in the u axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="v1">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="v2">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="vstride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i &af; j + 1 , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of vstride is 0.
        /// </param>
        /// <param name="vorder">
        /// Specifies the dimension of the control point array in the v axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) {
            Pointers.glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        
        /// <summary>
        /// define a two-dimensional evaluator
        /// <para>
        /// Evaluators provide a way to use polynomial or rational polynomial mapping to produce vertices,
        /// normals, texture coordinates, and colors. The values produced by an evaluator are sent on to further
        /// stages of GL processing just as if they had been presented using glVertex, glNormal, glTexCoord, and
        /// glColor commands, except that the generated values do not update the current normal, texture
        /// coordinates, or color
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the kind of values that are generated by the evaluator. Symbolic constants
        /// GL_MAP2_VERTEX_3, GL_MAP2_VERTEX_4, GL_MAP2_INDEX, GL_MAP2_COLOR_4, GL_MAP2_NORMAL,
        /// GL_MAP2_TEXTURE_COORD_1, GL_MAP2_TEXTURE_COORD_2, GL_MAP2_TEXTURE_COORD_3, and
        /// GL_MAP2_TEXTURE_COORD_4 are accepted.
        /// </param>
        /// <param name="u1">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="u2">
        /// Specify a linear mapping of u, as presented to glEvalCoord2, to u&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, u1 is 0 and u2 is 1.
        /// </param>
        /// <param name="ustride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i + 1 &it; j , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of ustride is 0.
        /// </param>
        /// <param name="uorder">
        /// Specifies the dimension of the control point array in the u axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="v1">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="v2">
        /// Specify a linear mapping of v, as presented to glEvalCoord2, to v&Hat; , one of the two variables
        /// that are evaluated by the equations specified by this command. Initially, v1 is 0 and v2 is 1.
        /// </param>
        /// <param name="vstride">
        /// Specifies the number of floats or doubles between the beginning of control point R ij and the
        /// beginning of control point R i &af; j + 1 , where i and j are the u and v control point indices,
        /// respectively. This allows control points to be embedded in arbitrary data structures. The only
        /// constraint is that the values for a particular control point must occupy contiguous memory
        /// locations. The initial value of vstride is 0.
        /// </param>
        /// <param name="vorder">
        /// Specifies the dimension of the control point array in the v axis. Must be positive. The initial
        /// value is 1.
        /// </param>
        /// <param name="points">
        /// Specifies a pointer to the array of control points.
        /// </param>
        public static void glMap2f(int target, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glMap2f(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_);
        }
        
        public static void glMap2xOES(int target, IntPtr u1, IntPtr u2, int ustride, int uorder, IntPtr v1, IntPtr v2, int vstride, int vorder, IntPtr points) {
            Pointers.glMap2xOES(target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        
        /// <summary>
        /// map all of a buffer object's data store into the client's address space
        /// <para>
        /// glMapBuffer and glMapNamedBuffer map the entire data store of a specified buffer object into the
        /// client's address space. The data can then be directly read and/or written relative to the returned
        /// pointer, depending on the specified access policy
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        /// <param name="access">
        /// Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be
        /// possible to read from, write to, or both read from and write to the buffer object's mapped data
        /// store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
        /// </param>
        public static IntPtr glMapBuffer(int target, int access) {
            return Pointers.glMapBuffer(target, access);
        }
        
        /// <summary>
        /// map all of a buffer object's data store into the client's address space
        /// <para>
        /// glMapBuffer and glMapNamedBuffer map the entire data store of a specified buffer object into the
        /// client's address space. The data can then be directly read and/or written relative to the returned
        /// pointer, depending on the specified access policy
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        /// <param name="access">
        /// Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be
        /// possible to read from, write to, or both read from and write to the buffer object's mapped data
        /// store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
        /// </param>
        public static IntPtr glMapBufferARB(int target, int access) {
            return Pointers.glMapBufferARB(target, access);
        }
        
        /// <summary>
        /// map all of a buffer object's data store into the client's address space
        /// <para>
        /// glMapBuffer and glMapNamedBuffer map the entire data store of a specified buffer object into the
        /// client's address space. The data can then be directly read and/or written relative to the returned
        /// pointer, depending on the specified access policy
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glMapBuffer, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        /// <param name="access">
        /// Specifies the access policy for glMapBuffer and glMapNamedBuffer, indicating whether it will be
        /// possible to read from, write to, or both read from and write to the buffer object's mapped data
        /// store. The symbolic constant must be GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE.
        /// </param>
        public static IntPtr glMapBufferOES(int target, int access) {
            return Pointers.glMapBufferOES(target, access);
        }
        
        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>
        /// glMapBufferRange and glMapNamedBufferRange map all or part of the data store of a specified buffer
        /// object into the client's address space. offset and length indicate the range of data in the buffer
        /// object that is to be mapped, in terms of basic machine units. access is a bitfield containing flags
        /// which describe the requested mapping. These flags are described below
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the mapped range.
        /// </param>
        public static IntPtr glMapBufferRange(int target, uint offset, uint length, uint access) {
            return Pointers.glMapBufferRange(target, offset, length, access);
        }
        
        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>
        /// glMapBufferRange and glMapNamedBufferRange map all or part of the data store of a specified buffer
        /// object into the client's address space. offset and length indicate the range of data in the buffer
        /// object that is to be mapped, in terms of basic machine units. access is a bitfield containing flags
        /// which describe the requested mapping. These flags are described below
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the mapped range.
        /// </param>
        public static IntPtr glMapBufferRange(int target, uint offset, uint length, Enums.BufferAccessMask access) {
            return Pointers.glMapBufferRange(target, offset, length, (uint)access);
        }
        
        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>
        /// glMapBufferRange and glMapNamedBufferRange map all or part of the data store of a specified buffer
        /// object into the client's address space. offset and length indicate the range of data in the buffer
        /// object that is to be mapped, in terms of basic machine units. access is a bitfield containing flags
        /// which describe the requested mapping. These flags are described below
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the mapped range.
        /// </param>
        public static IntPtr glMapBufferRangeEXT(int target, uint offset, uint length, uint access) {
            return Pointers.glMapBufferRangeEXT(target, offset, length, access);
        }
        
        /// <summary>
        /// map all or part of a buffer object's data store into the client's address space
        /// <para>
        /// glMapBufferRange and glMapNamedBufferRange map all or part of the data store of a specified buffer
        /// object into the client's address space. offset and length indicate the range of data in the buffer
        /// object that is to be mapped, in terms of basic machine units. access is a bitfield containing flags
        /// which describe the requested mapping. These flags are described below
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glMapBufferRange, which must be one of
        /// the buffer binding targets in the following table:
        /// </param>
        /// <param name="offset">
        /// Specifies the starting offset within the buffer of the range to be mapped.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the range to be mapped.
        /// </param>
        /// <param name="access">
        /// Specifies a combination of access flags indicating the desired access to the mapped range.
        /// </param>
        public static IntPtr glMapBufferRangeEXT(int target, uint offset, uint length, Enums.BufferAccessMask access) {
            return Pointers.glMapBufferRangeEXT(target, offset, length, (uint)access);
        }
        
        public static void glMapControlPointsNV(int target, uint index, int type, int ustride, int vstride, int uorder, int vorder, bool packed, IntPtr points) {
            Pointers.glMapControlPointsNV(target, index, type, ustride, vstride, uorder, vorder, packed, points);
        }
        
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>
        /// glMapGrid and glEvalMesh are used together to efficiently generate and evaluate a series of
        /// evenly-spaced map domain values. glEvalMesh steps through the integer domain of a one- or
        /// two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and
        /// glMap2
        /// </para>
        /// </summary>
        /// <param name="un">
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </param>
        /// <param name="u1">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        /// <param name="u2">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        public static void glMapGrid1d(int un, double u1, double u2) {
            Pointers.glMapGrid1d(un, u1, u2);
        }
        
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>
        /// glMapGrid and glEvalMesh are used together to efficiently generate and evaluate a series of
        /// evenly-spaced map domain values. glEvalMesh steps through the integer domain of a one- or
        /// two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and
        /// glMap2
        /// </para>
        /// </summary>
        /// <param name="un">
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </param>
        /// <param name="u1">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        /// <param name="u2">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        public static void glMapGrid1f(int un, float u1, float u2) {
            Pointers.glMapGrid1f(un, u1, u2);
        }
        
        public static void glMapGrid1xOES(int n, IntPtr u1, IntPtr u2) {
            Pointers.glMapGrid1xOES(n, u1, u2);
        }
        
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>
        /// glMapGrid and glEvalMesh are used together to efficiently generate and evaluate a series of
        /// evenly-spaced map domain values. glEvalMesh steps through the integer domain of a one- or
        /// two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and
        /// glMap2
        /// </para>
        /// </summary>
        /// <param name="un">
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </param>
        /// <param name="u1">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        /// <param name="u2">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        /// <param name="vn">
        /// Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).
        /// </param>
        /// <param name="v1">
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </param>
        /// <param name="v2">
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </param>
        public static void glMapGrid2d(int un, double u1, double u2, int vn, double v1, double v2) {
            Pointers.glMapGrid2d(un, u1, u2, vn, v1, v2);
        }
        
        /// <summary>
        /// define a one- or two-dimensional mesh
        /// <para>
        /// glMapGrid and glEvalMesh are used together to efficiently generate and evaluate a series of
        /// evenly-spaced map domain values. glEvalMesh steps through the integer domain of a one- or
        /// two-dimensional grid, whose range is the domain of the evaluation maps specified by glMap1 and
        /// glMap2
        /// </para>
        /// </summary>
        /// <param name="un">
        /// Specifies the number of partitions in the grid range interval [u1, u2]. Must be positive.
        /// </param>
        /// <param name="u1">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        /// <param name="u2">
        /// Specify the mappings for integer grid domain values i = 0 and i = un .
        /// </param>
        /// <param name="vn">
        /// Specifies the number of partitions in the grid range interval [v1, v2] (glMapGrid2 only).
        /// </param>
        /// <param name="v1">
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </param>
        /// <param name="v2">
        /// Specify the mappings for integer grid domain values j = 0 and j = vn (glMapGrid2 only).
        /// </param>
        public static void glMapGrid2f(int un, float u1, float u2, int vn, float v1, float v2) {
            Pointers.glMapGrid2f(un, u1, u2, vn, v1, v2);
        }
        
        public static void glMapGrid2xOES(int n, IntPtr u1, IntPtr u2, IntPtr v1, IntPtr v2) {
            Pointers.glMapGrid2xOES(n, u1, u2, v1, v2);
        }
        
        public static IntPtr glMapNamedBuffer(uint buffer, int access) {
            return Pointers.glMapNamedBuffer(buffer, access);
        }
        
        public static IntPtr glMapNamedBufferEXT(uint buffer, int access) {
            return Pointers.glMapNamedBufferEXT(buffer, access);
        }
        
        public static IntPtr glMapNamedBufferRange(uint buffer, uint offset, uint length, uint access) {
            return Pointers.glMapNamedBufferRange(buffer, offset, length, access);
        }
        
        public static IntPtr glMapNamedBufferRange(uint buffer, uint offset, uint length, Enums.BufferAccessMask access) {
            return Pointers.glMapNamedBufferRange(buffer, offset, length, (uint)access);
        }
        
        public static IntPtr glMapNamedBufferRangeEXT(uint buffer, uint offset, uint length, uint access) {
            return Pointers.glMapNamedBufferRangeEXT(buffer, offset, length, access);
        }
        
        public static IntPtr glMapNamedBufferRangeEXT(uint buffer, uint offset, uint length, Enums.BufferAccessMask access) {
            return Pointers.glMapNamedBufferRangeEXT(buffer, offset, length, (uint)access);
        }
        
        public static IntPtr glMapObjectBufferATI(uint buffer) {
            return Pointers.glMapObjectBufferATI(buffer);
        }
        
        public static void glMapParameterfvNV(int target, int pname, float* _params) {
            Pointers.glMapParameterfvNV(target, pname, _params);
        }
        
        public static void glMapParameterfvNV(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glMapParameterfvNV(target, pname, _params_);
        }
        
        public static void glMapParameterivNV(int target, int pname, int* _params) {
            Pointers.glMapParameterivNV(target, pname, _params);
        }
        
        public static void glMapParameterivNV(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMapParameterivNV(target, pname, _params_);
        }
        
        public static IntPtr glMapTexture2DINTEL(uint texture, int level, uint access, int* stride, int* layout) {
            return Pointers.glMapTexture2DINTEL(texture, level, access, stride, layout);
        }
        
        public static IntPtr glMapTexture2DINTEL(uint texture, int level, uint access, int* stride, out int layout) {
            fixed(int* layout_ = &layout)
                return Pointers.glMapTexture2DINTEL(texture, level, access, stride, layout_);
        }
        
        public static IntPtr glMapTexture2DINTEL(uint texture, int level, uint access, out int stride, int* layout) {
            fixed(int* stride_ = &stride)
                return Pointers.glMapTexture2DINTEL(texture, level, access, stride_, layout);
        }
        
        public static IntPtr glMapTexture2DINTEL(uint texture, int level, uint access, out int stride, out int layout) {
            fixed(int* stride_ = &stride)
            fixed(int* layout_ = &layout)
                return Pointers.glMapTexture2DINTEL(texture, level, access, stride_, layout_);
        }
        
        public static void glMapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double* points) {
            Pointers.glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points);
        }
        
        public static void glMapVertexAttrib1dAPPLE(uint index, uint size, double u1, double u2, int stride, int order, double[] points) {
            fixed(double* points_ = &points[0])
                Pointers.glMapVertexAttrib1dAPPLE(index, size, u1, u2, stride, order, points_);
        }
        
        public static void glMapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float* points) {
            Pointers.glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points);
        }
        
        public static void glMapVertexAttrib1fAPPLE(uint index, uint size, float u1, float u2, int stride, int order, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glMapVertexAttrib1fAPPLE(index, size, u1, u2, stride, order, points_);
        }
        
        public static void glMapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double* points) {
            Pointers.glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        
        public static void glMapVertexAttrib2dAPPLE(uint index, uint size, double u1, double u2, int ustride, int uorder, double v1, double v2, int vstride, int vorder, double[] points) {
            fixed(double* points_ = &points[0])
                Pointers.glMapVertexAttrib2dAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_);
        }
        
        public static void glMapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float* points) {
            Pointers.glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points);
        }
        
        public static void glMapVertexAttrib2fAPPLE(uint index, uint size, float u1, float u2, int ustride, int uorder, float v1, float v2, int vstride, int vorder, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glMapVertexAttrib2fAPPLE(index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points_);
        }
        
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>
        /// glMaterial assigns values to material parameters. There are two matched sets of material parameters.
        /// One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when two-sided
        /// lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
        /// set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled.
        /// Refer to the glLightModel reference page for details concerning one- and two-sided lighting
        /// calculations
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="pname">
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be
        /// GL_SHININESS.
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </param>
        public static void glMaterialf(int face, int pname, float param) {
            Pointers.glMaterialf(face, pname, param);
        }
        
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>
        /// glMaterial assigns values to material parameters. There are two matched sets of material parameters.
        /// One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when two-sided
        /// lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
        /// set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled.
        /// Refer to the glLightModel reference page for details concerning one- and two-sided lighting
        /// calculations
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="pname">
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be
        /// GL_SHININESS.
        /// </param>
        /// <param name="_params">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        public static void glMaterialfv(int face, int pname, float* _params) {
            Pointers.glMaterialfv(face, pname, _params);
        }
        
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>
        /// glMaterial assigns values to material parameters. There are two matched sets of material parameters.
        /// One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when two-sided
        /// lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
        /// set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled.
        /// Refer to the glLightModel reference page for details concerning one- and two-sided lighting
        /// calculations
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="pname">
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be
        /// GL_SHININESS.
        /// </param>
        /// <param name="_params">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        public static void glMaterialfv(int face, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glMaterialfv(face, pname, _params_);
        }
        
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>
        /// glMaterial assigns values to material parameters. There are two matched sets of material parameters.
        /// One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when two-sided
        /// lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
        /// set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled.
        /// Refer to the glLightModel reference page for details concerning one- and two-sided lighting
        /// calculations
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="pname">
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be
        /// GL_SHININESS.
        /// </param>
        /// <param name="param">
        /// Specifies the value that parameter GL_SHININESS will be set to.
        /// </param>
        public static void glMateriali(int face, int pname, int param) {
            Pointers.glMateriali(face, pname, param);
        }
        
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>
        /// glMaterial assigns values to material parameters. There are two matched sets of material parameters.
        /// One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when two-sided
        /// lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
        /// set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled.
        /// Refer to the glLightModel reference page for details concerning one- and two-sided lighting
        /// calculations
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="pname">
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be
        /// GL_SHININESS.
        /// </param>
        /// <param name="_params">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        public static void glMaterialiv(int face, int pname, int* _params) {
            Pointers.glMaterialiv(face, pname, _params);
        }
        
        /// <summary>
        /// specify material parameters for the lighting model
        /// <para>
        /// glMaterial assigns values to material parameters. There are two matched sets of material parameters.
        /// One, the front-facing set, is used to shade points, lines, bitmaps, and all polygons (when two-sided
        /// lighting is disabled), or just front-facing polygons (when two-sided lighting is enabled). The other
        /// set, back-facing, is used to shade back-facing polygons only when two-sided lighting is enabled.
        /// Refer to the glLightModel reference page for details concerning one- and two-sided lighting
        /// calculations
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="pname">
        /// Specifies the single-valued material parameter of the face or faces that is being updated. Must be
        /// GL_SHININESS.
        /// </param>
        /// <param name="_params">
        /// Specifies which face or faces are being updated. Must be one of GL_FRONT, GL_BACK, or
        /// GL_FRONT_AND_BACK.
        /// </param>
        public static void glMaterialiv(int face, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMaterialiv(face, pname, _params_);
        }
        
        public static void glMaterialx(int face, int pname, IntPtr param) {
            Pointers.glMaterialx(face, pname, param);
        }
        
        public static void glMaterialxOES(int face, int pname, IntPtr param) {
            Pointers.glMaterialxOES(face, pname, param);
        }
        
        public static void glMaterialxv(int face, int pname, IntPtr* param) {
            Pointers.glMaterialxv(face, pname, param);
        }
        
        public static void glMaterialxv(int face, int pname, IntPtr[] param) {
            fixed(IntPtr* param_ = &param[0])
                Pointers.glMaterialxv(face, pname, param_);
        }
        
        public static void glMaterialxvOES(int face, int pname, IntPtr* param) {
            Pointers.glMaterialxvOES(face, pname, param);
        }
        
        public static void glMaterialxvOES(int face, int pname, IntPtr[] param) {
            fixed(IntPtr* param_ = &param[0])
                Pointers.glMaterialxvOES(face, pname, param_);
        }
        
        public static void glMatrixFrustumEXT(int mode, double left, double right, double bottom, double top, double zNear, double zFar) {
            Pointers.glMatrixFrustumEXT(mode, left, right, bottom, top, zNear, zFar);
        }
        
        public static void glMatrixIndexPointerARB(int size, int type, int stride, IntPtr pointer) {
            Pointers.glMatrixIndexPointerARB(size, type, stride, pointer);
        }
        
        public static void glMatrixIndexPointerOES(int size, int type, int stride, IntPtr pointer) {
            Pointers.glMatrixIndexPointerOES(size, type, stride, pointer);
        }
        
        public static void glMatrixIndexubvARB(int size, byte* indices) {
            Pointers.glMatrixIndexubvARB(size, indices);
        }
        
        public static void glMatrixIndexubvARB(int size, byte[] indices) {
            fixed(byte* indices_ = &indices[0])
                Pointers.glMatrixIndexubvARB(size, indices_);
        }
        
        public static void glMatrixIndexuivARB(int size, uint* indices) {
            Pointers.glMatrixIndexuivARB(size, indices);
        }
        
        public static void glMatrixIndexuivARB(int size, uint[] indices) {
            fixed(uint* indices_ = &indices[0])
                Pointers.glMatrixIndexuivARB(size, indices_);
        }
        
        public static void glMatrixIndexusvARB(int size, ushort* indices) {
            Pointers.glMatrixIndexusvARB(size, indices);
        }
        
        public static void glMatrixIndexusvARB(int size, ushort[] indices) {
            fixed(ushort* indices_ = &indices[0])
                Pointers.glMatrixIndexusvARB(size, indices_);
        }
        
        public static void glMatrixLoad3x2fNV(int matrixMode, float* m) {
            Pointers.glMatrixLoad3x2fNV(matrixMode, m);
        }
        
        public static void glMatrixLoad3x2fNV(int matrixMode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixLoad3x2fNV(matrixMode, m_);
        }
        
        public static void glMatrixLoad3x3fNV(int matrixMode, float* m) {
            Pointers.glMatrixLoad3x3fNV(matrixMode, m);
        }
        
        public static void glMatrixLoad3x3fNV(int matrixMode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixLoad3x3fNV(matrixMode, m_);
        }
        
        public static void glMatrixLoadIdentityEXT(int mode) {
            Pointers.glMatrixLoadIdentityEXT(mode);
        }
        
        public static void glMatrixLoadTranspose3x3fNV(int matrixMode, float* m) {
            Pointers.glMatrixLoadTranspose3x3fNV(matrixMode, m);
        }
        
        public static void glMatrixLoadTranspose3x3fNV(int matrixMode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixLoadTranspose3x3fNV(matrixMode, m_);
        }
        
        public static void glMatrixLoadTransposedEXT(int mode, double* m) {
            Pointers.glMatrixLoadTransposedEXT(mode, m);
        }
        
        public static void glMatrixLoadTransposedEXT(int mode, double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glMatrixLoadTransposedEXT(mode, m_);
        }
        
        public static void glMatrixLoadTransposefEXT(int mode, float* m) {
            Pointers.glMatrixLoadTransposefEXT(mode, m);
        }
        
        public static void glMatrixLoadTransposefEXT(int mode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixLoadTransposefEXT(mode, m_);
        }
        
        public static void glMatrixLoaddEXT(int mode, double* m) {
            Pointers.glMatrixLoaddEXT(mode, m);
        }
        
        public static void glMatrixLoaddEXT(int mode, double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glMatrixLoaddEXT(mode, m_);
        }
        
        public static void glMatrixLoadfEXT(int mode, float* m) {
            Pointers.glMatrixLoadfEXT(mode, m);
        }
        
        public static void glMatrixLoadfEXT(int mode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixLoadfEXT(mode, m_);
        }
        
        /// <summary>
        /// specify which matrix is the current matrix
        /// <para>
        /// glMatrixMode sets the current matrix mode. mode can assume one of four values:
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies which matrix stack is the target for subsequent matrix operations. Three values are
        /// accepted: GL_MODELVIEW, GL_PROJECTION, and GL_TEXTURE. The initial value is GL_MODELVIEW.
        /// Additionally, if the ARB_imaging extension is supported, GL_COLOR is also accepted.
        /// </param>
        public static void glMatrixMode(int mode) {
            Pointers.glMatrixMode(mode);
        }
        
        public static void glMatrixMult3x2fNV(int matrixMode, float* m) {
            Pointers.glMatrixMult3x2fNV(matrixMode, m);
        }
        
        public static void glMatrixMult3x2fNV(int matrixMode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixMult3x2fNV(matrixMode, m_);
        }
        
        public static void glMatrixMult3x3fNV(int matrixMode, float* m) {
            Pointers.glMatrixMult3x3fNV(matrixMode, m);
        }
        
        public static void glMatrixMult3x3fNV(int matrixMode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixMult3x3fNV(matrixMode, m_);
        }
        
        public static void glMatrixMultTranspose3x3fNV(int matrixMode, float* m) {
            Pointers.glMatrixMultTranspose3x3fNV(matrixMode, m);
        }
        
        public static void glMatrixMultTranspose3x3fNV(int matrixMode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixMultTranspose3x3fNV(matrixMode, m_);
        }
        
        public static void glMatrixMultTransposedEXT(int mode, double* m) {
            Pointers.glMatrixMultTransposedEXT(mode, m);
        }
        
        public static void glMatrixMultTransposedEXT(int mode, double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glMatrixMultTransposedEXT(mode, m_);
        }
        
        public static void glMatrixMultTransposefEXT(int mode, float* m) {
            Pointers.glMatrixMultTransposefEXT(mode, m);
        }
        
        public static void glMatrixMultTransposefEXT(int mode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixMultTransposefEXT(mode, m_);
        }
        
        public static void glMatrixMultdEXT(int mode, double* m) {
            Pointers.glMatrixMultdEXT(mode, m);
        }
        
        public static void glMatrixMultdEXT(int mode, double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glMatrixMultdEXT(mode, m_);
        }
        
        public static void glMatrixMultfEXT(int mode, float* m) {
            Pointers.glMatrixMultfEXT(mode, m);
        }
        
        public static void glMatrixMultfEXT(int mode, float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMatrixMultfEXT(mode, m_);
        }
        
        public static void glMatrixOrthoEXT(int mode, double left, double right, double bottom, double top, double zNear, double zFar) {
            Pointers.glMatrixOrthoEXT(mode, left, right, bottom, top, zNear, zFar);
        }
        
        public static void glMatrixPopEXT(int mode) {
            Pointers.glMatrixPopEXT(mode);
        }
        
        public static void glMatrixPushEXT(int mode) {
            Pointers.glMatrixPushEXT(mode);
        }
        
        public static void glMatrixRotatedEXT(int mode, double angle, double x, double y, double z) {
            Pointers.glMatrixRotatedEXT(mode, angle, x, y, z);
        }
        
        public static void glMatrixRotatefEXT(int mode, float angle, float x, float y, float z) {
            Pointers.glMatrixRotatefEXT(mode, angle, x, y, z);
        }
        
        public static void glMatrixScaledEXT(int mode, double x, double y, double z) {
            Pointers.glMatrixScaledEXT(mode, x, y, z);
        }
        
        public static void glMatrixScalefEXT(int mode, float x, float y, float z) {
            Pointers.glMatrixScalefEXT(mode, x, y, z);
        }
        
        public static void glMatrixTranslatedEXT(int mode, double x, double y, double z) {
            Pointers.glMatrixTranslatedEXT(mode, x, y, z);
        }
        
        public static void glMatrixTranslatefEXT(int mode, float x, float y, float z) {
            Pointers.glMatrixTranslatefEXT(mode, x, y, z);
        }
        
        public static void glMaxShaderCompilerThreadsKHR(uint count) {
            Pointers.glMaxShaderCompilerThreadsKHR(count);
        }
        
        public static void glMaxShaderCompilerThreadsARB(uint count) {
            Pointers.glMaxShaderCompilerThreadsARB(count);
        }
        
        /// <summary>
        /// defines a barrier ordering memory transactions
        /// </summary>
        /// <param name="barriers">
        /// Specifies the barriers to insert.
        /// </param>
        public static void glMemoryBarrier(uint barriers) {
            Pointers.glMemoryBarrier(barriers);
        }
        
        /// <summary>
        /// defines a barrier ordering memory transactions
        /// </summary>
        /// <param name="barriers">
        /// Specifies the barriers to insert.
        /// </param>
        public static void glMemoryBarrier(Enums.MemoryBarrierMask barriers) {
            Pointers.glMemoryBarrier((uint)barriers);
        }
        
        public static void glMemoryBarrierByRegion(uint barriers) {
            Pointers.glMemoryBarrierByRegion(barriers);
        }
        
        public static void glMemoryBarrierByRegion(Enums.MemoryBarrierMask barriers) {
            Pointers.glMemoryBarrierByRegion((uint)barriers);
        }
        
        /// <summary>
        /// defines a barrier ordering memory transactions
        /// </summary>
        /// <param name="barriers">
        /// Specifies the barriers to insert.
        /// </param>
        public static void glMemoryBarrierEXT(uint barriers) {
            Pointers.glMemoryBarrierEXT(barriers);
        }
        
        /// <summary>
        /// defines a barrier ordering memory transactions
        /// </summary>
        /// <param name="barriers">
        /// Specifies the barriers to insert.
        /// </param>
        public static void glMemoryBarrierEXT(Enums.MemoryBarrierMask barriers) {
            Pointers.glMemoryBarrierEXT((uint)barriers);
        }
        
        public static void glMemoryObjectParameterivEXT(uint memoryObject, int pname, int* _params) {
            Pointers.glMemoryObjectParameterivEXT(memoryObject, pname, _params);
        }
        
        public static void glMemoryObjectParameterivEXT(uint memoryObject, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMemoryObjectParameterivEXT(memoryObject, pname, _params_);
        }
        
        /// <summary>
        /// specifies minimum rate at which sample shaing takes place
        /// <para>
        /// glMinSampleShading specifies the rate at which samples are shaded within a covered pixel.
        /// Sample-rate shading is enabled by calling glEnable with the parameter GL_SAMPLE_SHADING. If
        /// GL_MULTISAMPLE or GL_SAMPLE_SHADING is disabled, sample shading has no effect. Otherwise, an
        /// implementation must provide at least as many unique color values for each covered fragment as
        /// specified by value times samples where samples is the value of GL_SAMPLES for the current
        /// framebuffer. At least 1 sample for each covered fragment is generated
        /// </para>
        /// </summary>
        /// <param name="value">
        /// Specifies the rate at which samples are shaded within each covered pixel.
        /// </param>
        public static void glMinSampleShading(float value) {
            Pointers.glMinSampleShading(value);
        }
        
        /// <summary>
        /// specifies minimum rate at which sample shaing takes place
        /// <para>
        /// glMinSampleShading specifies the rate at which samples are shaded within a covered pixel.
        /// Sample-rate shading is enabled by calling glEnable with the parameter GL_SAMPLE_SHADING. If
        /// GL_MULTISAMPLE or GL_SAMPLE_SHADING is disabled, sample shading has no effect. Otherwise, an
        /// implementation must provide at least as many unique color values for each covered fragment as
        /// specified by value times samples where samples is the value of GL_SAMPLES for the current
        /// framebuffer. At least 1 sample for each covered fragment is generated
        /// </para>
        /// </summary>
        /// <param name="value">
        /// Specifies the rate at which samples are shaded within each covered pixel.
        /// </param>
        public static void glMinSampleShadingARB(float value) {
            Pointers.glMinSampleShadingARB(value);
        }
        
        /// <summary>
        /// specifies minimum rate at which sample shaing takes place
        /// <para>
        /// glMinSampleShading specifies the rate at which samples are shaded within a covered pixel.
        /// Sample-rate shading is enabled by calling glEnable with the parameter GL_SAMPLE_SHADING. If
        /// GL_MULTISAMPLE or GL_SAMPLE_SHADING is disabled, sample shading has no effect. Otherwise, an
        /// implementation must provide at least as many unique color values for each covered fragment as
        /// specified by value times samples where samples is the value of GL_SAMPLES for the current
        /// framebuffer. At least 1 sample for each covered fragment is generated
        /// </para>
        /// </summary>
        /// <param name="value">
        /// Specifies the rate at which samples are shaded within each covered pixel.
        /// </param>
        public static void glMinSampleShadingOES(float value) {
            Pointers.glMinSampleShadingOES(value);
        }
        
        /// <summary>
        /// define minmax table
        /// <para>
        /// When GL_MINMAX is enabled, the RGBA components of incoming pixels are compared to the minimum and
        /// maximum values for each component, which are stored in the two-element minmax table. (The first
        /// element stores the minima, and the second element stores the maxima.) If a pixel component is
        /// greater than the corresponding component in the maximum element, then the maximum element is updated
        /// with the pixel component value. If a pixel component is less than the corresponding component in the
        /// minimum element, then the minimum element is updated with the pixel component value. (In both cases,
        /// if the internal format of the minmax table includes luminance, then the R color component of
        /// incoming pixels is used for comparison.) The contents of the minmax table may be retrieved at a
        /// later time by calling glGetMinmax. The minmax operation is enabled or disabled by calling glEnable
        /// or glDisable, respectively, with an argument of GL_MINMAX
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The minmax table whose parameters are to be set. Must be GL_MINMAX.
        /// </param>
        /// <param name="internalformat">
        /// The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
        /// GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16,
        /// GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,
        /// GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4,
        /// GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="sink">
        /// If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will
        /// take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax.
        /// </param>
        public static void glMinmax(int target, int internalformat, bool sink) {
            Pointers.glMinmax(target, internalformat, sink);
        }
        
        /// <summary>
        /// define minmax table
        /// <para>
        /// When GL_MINMAX is enabled, the RGBA components of incoming pixels are compared to the minimum and
        /// maximum values for each component, which are stored in the two-element minmax table. (The first
        /// element stores the minima, and the second element stores the maxima.) If a pixel component is
        /// greater than the corresponding component in the maximum element, then the maximum element is updated
        /// with the pixel component value. If a pixel component is less than the corresponding component in the
        /// minimum element, then the minimum element is updated with the pixel component value. (In both cases,
        /// if the internal format of the minmax table includes luminance, then the R color component of
        /// incoming pixels is used for comparison.) The contents of the minmax table may be retrieved at a
        /// later time by calling glGetMinmax. The minmax operation is enabled or disabled by calling glEnable
        /// or glDisable, respectively, with an argument of GL_MINMAX
        /// </para>
        /// </summary>
        /// <param name="target">
        /// The minmax table whose parameters are to be set. Must be GL_MINMAX.
        /// </param>
        /// <param name="internalformat">
        /// The format of entries in the minmax table. Must be one of GL_ALPHA, GL_ALPHA4, GL_ALPHA8,
        /// GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12, GL_LUMINANCE16,
        /// GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2, GL_LUMINANCE8_ALPHA8,
        /// GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16, GL_R3_G3_B2, GL_RGB, GL_RGB4,
        /// GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1, GL_RGBA8,
        /// GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="sink">
        /// If GL_TRUE, pixels will be consumed by the minmax process and no drawing or texture loading will
        /// take place. If GL_FALSE, pixels will proceed to the final conversion process after minmax.
        /// </param>
        public static void glMinmaxEXT(int target, int internalformat, bool sink) {
            Pointers.glMinmaxEXT(target, internalformat, sink);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>
        /// glMultMatrix multiplies the current matrix with the one specified using m, and replaces the current
        /// matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 column-major matrix.
        /// </param>
        public static void glMultMatrixd(double* m) {
            Pointers.glMultMatrixd(m);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>
        /// glMultMatrix multiplies the current matrix with the one specified using m, and replaces the current
        /// matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 column-major matrix.
        /// </param>
        public static void glMultMatrixd(double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glMultMatrixd(m_);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>
        /// glMultMatrix multiplies the current matrix with the one specified using m, and replaces the current
        /// matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 column-major matrix.
        /// </param>
        public static void glMultMatrixf(float* m) {
            Pointers.glMultMatrixf(m);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified matrix
        /// <para>
        /// glMultMatrix multiplies the current matrix with the one specified using m, and replaces the current
        /// matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 column-major matrix.
        /// </param>
        public static void glMultMatrixf(float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMultMatrixf(m_);
        }
        
        public static void glMultMatrixx(IntPtr* m) {
            Pointers.glMultMatrixx(m);
        }
        
        public static void glMultMatrixx(IntPtr[] m) {
            fixed(IntPtr* m_ = &m[0])
                Pointers.glMultMatrixx(m_);
        }
        
        public static void glMultMatrixxOES(IntPtr* m) {
            Pointers.glMultMatrixxOES(m);
        }
        
        public static void glMultMatrixxOES(IntPtr[] m) {
            fixed(IntPtr* m_ = &m[0])
                Pointers.glMultMatrixxOES(m_);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixd(double* m) {
            Pointers.glMultTransposeMatrixd(m);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixd(double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glMultTransposeMatrixd(m_);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixdARB(double* m) {
            Pointers.glMultTransposeMatrixdARB(m);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixdARB(double[] m) {
            fixed(double* m_ = &m[0])
                Pointers.glMultTransposeMatrixdARB(m_);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixf(float* m) {
            Pointers.glMultTransposeMatrixf(m);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixf(float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMultTransposeMatrixf(m_);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixfARB(float* m) {
            Pointers.glMultTransposeMatrixfARB(m);
        }
        
        /// <summary>
        /// multiply the current matrix with the specified row-major ordered matrix
        /// <para>
        /// glMultTransposeMatrix multiplies the current matrix with the one specified using m, and replaces the
        /// current matrix with the product
        /// </para>
        /// </summary>
        /// <param name="m">
        /// Points to 16 consecutive values that are used as the elements of a 4 &times; 4 row-major matrix.
        /// </param>
        public static void glMultTransposeMatrixfARB(float[] m) {
            fixed(float* m_ = &m[0])
                Pointers.glMultTransposeMatrixfARB(m_);
        }
        
        public static void glMultTransposeMatrixxOES(IntPtr* m) {
            Pointers.glMultTransposeMatrixxOES(m);
        }
        
        public static void glMultTransposeMatrixxOES(IntPtr[] m) {
            fixed(IntPtr* m_ = &m[0])
                Pointers.glMultTransposeMatrixxOES(m_);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArrays(int mode, int* first, int* count, int drawcount) {
            Pointers.glMultiDrawArrays(mode, first, count, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArrays(int mode, int* first, int[] count, int drawcount) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawArrays(mode, first, count_, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArrays(int mode, int[] first, int* count, int drawcount) {
            fixed(int* first_ = &first[0])
                Pointers.glMultiDrawArrays(mode, first_, count, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArrays(int mode, int[] first, int[] count, int drawcount) {
            fixed(int* first_ = &first[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawArrays(mode, first_, count_, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArraysEXT(int mode, int* first, int* count, int primcount) {
            Pointers.glMultiDrawArraysEXT(mode, first, count, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArraysEXT(int mode, int* first, int[] count, int primcount) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawArraysEXT(mode, first, count_, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArraysEXT(int mode, int[] first, int* count, int primcount) {
            fixed(int* first_ = &first[0])
                Pointers.glMultiDrawArraysEXT(mode, first_, count, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data
        /// <para>
        /// glMultiDrawArrays specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL procedure to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and colors and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawArrays
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="first">
        /// Points to an array of starting indices in the enabled arrays.
        /// </param>
        /// <param name="count">
        /// Points to an array of the number of indices to be rendered.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the first and count
        /// </param>
        public static void glMultiDrawArraysEXT(int mode, int[] first, int[] count, int primcount) {
            fixed(int* first_ = &first[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawArraysEXT(mode, first_, count_, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data, taking parameters from memory
        /// <para>
        /// glMultiDrawArraysIndirect specifies multiple geometric primitives with very few subroutine calls.
        /// glMultiDrawArraysIndirect behaves similarly to a multitude of calls to
        /// glDrawArraysInstancedBaseInstance, execept that the parameters to each call to
        /// glDrawArraysInstancedBaseInstance are stored in an array in memory at the address given by indirect,
        /// separated by the stride, in basic machine units, specified by stride. If stride is zero, then the
        /// array is assumed to be tightly packed in memory
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of an array of structures containing the draw parameters.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the the number of elements in the array of draw parameter structures.
        /// </param>
        /// <param name="stride">
        /// Specifies the distance in basic machine units between elements of the draw parameter array.
        /// </param>
        public static void glMultiDrawArraysIndirect(int mode, IntPtr indirect, int drawcount, int stride) {
            Pointers.glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data, taking parameters from memory
        /// <para>
        /// glMultiDrawArraysIndirect specifies multiple geometric primitives with very few subroutine calls.
        /// glMultiDrawArraysIndirect behaves similarly to a multitude of calls to
        /// glDrawArraysInstancedBaseInstance, execept that the parameters to each call to
        /// glDrawArraysInstancedBaseInstance are stored in an array in memory at the address given by indirect,
        /// separated by the stride, in basic machine units, specified by stride. If stride is zero, then the
        /// array is assumed to be tightly packed in memory
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of an array of structures containing the draw parameters.
        /// </param>
        /// <param name="primcount">
        /// Specifies the the number of elements in the array of draw parameter structures.
        /// </param>
        /// <param name="stride">
        /// Specifies the distance in basic machine units between elements of the draw parameter array.
        /// </param>
        public static void glMultiDrawArraysIndirectAMD(int mode, IntPtr indirect, int primcount, int stride) {
            Pointers.glMultiDrawArraysIndirectAMD(mode, indirect, primcount, stride);
        }
        
        public static void glMultiDrawArraysIndirectBindlessCountNV(int mode, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) {
            Pointers.glMultiDrawArraysIndirectBindlessCountNV(mode, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
        }
        
        public static void glMultiDrawArraysIndirectBindlessNV(int mode, IntPtr indirect, int drawCount, int stride, int vertexBufferCount) {
            Pointers.glMultiDrawArraysIndirectBindlessNV(mode, indirect, drawCount, stride, vertexBufferCount);
        }
        
        public static void glMultiDrawArraysIndirectCount(int mode, IntPtr indirect, uint drawcount, int maxdrawcount, int stride) {
            Pointers.glMultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride);
        }
        
        public static void glMultiDrawArraysIndirectCountARB(int mode, IntPtr indirect, uint drawcount, int maxdrawcount, int stride) {
            Pointers.glMultiDrawArraysIndirectCountARB(mode, indirect, drawcount, maxdrawcount, stride);
        }
        
        /// <summary>
        /// render multiple sets of primitives from array data, taking parameters from memory
        /// <para>
        /// glMultiDrawArraysIndirect specifies multiple geometric primitives with very few subroutine calls.
        /// glMultiDrawArraysIndirect behaves similarly to a multitude of calls to
        /// glDrawArraysInstancedBaseInstance, execept that the parameters to each call to
        /// glDrawArraysInstancedBaseInstance are stored in an array in memory at the address given by indirect,
        /// separated by the stride, in basic machine units, specified by stride. If stride is zero, then the
        /// array is assumed to be tightly packed in memory
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of an array of structures containing the draw parameters.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the the number of elements in the array of draw parameter structures.
        /// </param>
        /// <param name="stride">
        /// Specifies the distance in basic machine units between elements of the draw parameter array.
        /// </param>
        public static void glMultiDrawArraysIndirectEXT(int mode, IntPtr indirect, int drawcount, int stride) {
            Pointers.glMultiDrawArraysIndirectEXT(mode, indirect, drawcount, stride);
        }
        
        public static void glMultiDrawElementArrayAPPLE(int mode, int* first, int* count, int primcount) {
            Pointers.glMultiDrawElementArrayAPPLE(mode, first, count, primcount);
        }
        
        public static void glMultiDrawElementArrayAPPLE(int mode, int* first, int[] count, int primcount) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawElementArrayAPPLE(mode, first, count_, primcount);
        }
        
        public static void glMultiDrawElementArrayAPPLE(int mode, int[] first, int* count, int primcount) {
            fixed(int* first_ = &first[0])
                Pointers.glMultiDrawElementArrayAPPLE(mode, first_, count, primcount);
        }
        
        public static void glMultiDrawElementArrayAPPLE(int mode, int[] first, int[] count, int primcount) {
            fixed(int* first_ = &first[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawElementArrayAPPLE(mode, first_, count_, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElements(int mode, int* count, int type, IntPtr* indices, int drawcount) {
            Pointers.glMultiDrawElements(mode, count, type, indices, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElements(int mode, int* count, int type, IntPtr[] indices, int drawcount) {
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElements(mode, count, type, indices_, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElements(int mode, int[] count, int type, IntPtr* indices, int drawcount) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawElements(mode, count_, type, indices, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElements(int mode, int[] count, int type, IntPtr[] indices, int drawcount) {
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElements(mode, count_, type, indices_, drawcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int* count, int type, IntPtr* indices, int drawcount, int* basevertex) {
            Pointers.glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int* count, int type, IntPtr* indices, int drawcount, int[] basevertex) {
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int* count, int type, IntPtr[] indices, int drawcount, int* basevertex) {
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElementsBaseVertex(mode, count, type, indices_, drawcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int* count, int type, IntPtr[] indices, int drawcount, int[] basevertex) {
            fixed(IntPtr* indices_ = &indices[0])
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertex(mode, count, type, indices_, drawcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int[] count, int type, IntPtr* indices, int drawcount, int* basevertex) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawElementsBaseVertex(mode, count_, type, indices, drawcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int[] count, int type, IntPtr* indices, int drawcount, int[] basevertex) {
            fixed(int* count_ = &count[0])
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertex(mode, count_, type, indices, drawcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int[] count, int type, IntPtr[] indices, int drawcount, int* basevertex) {
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElementsBaseVertex(mode, count_, type, indices_, drawcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertex(int mode, int[] count, int type, IntPtr[] indices, int drawcount, int[] basevertex) {
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertex(mode, count_, type, indices_, drawcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int* count, int type, IntPtr* indices, int primcount, int* basevertex) {
            Pointers.glMultiDrawElementsBaseVertexEXT(mode, count, type, indices, primcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int* count, int type, IntPtr* indices, int primcount, int[] basevertex) {
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertexEXT(mode, count, type, indices, primcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int* count, int type, IntPtr[] indices, int primcount, int* basevertex) {
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElementsBaseVertexEXT(mode, count, type, indices_, primcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int* count, int type, IntPtr[] indices, int primcount, int[] basevertex) {
            fixed(IntPtr* indices_ = &indices[0])
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertexEXT(mode, count, type, indices_, primcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int[] count, int type, IntPtr* indices, int primcount, int* basevertex) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawElementsBaseVertexEXT(mode, count_, type, indices, primcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int[] count, int type, IntPtr* indices, int primcount, int[] basevertex) {
            fixed(int* count_ = &count[0])
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertexEXT(mode, count_, type, indices, primcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int[] count, int type, IntPtr[] indices, int primcount, int* basevertex) {
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElementsBaseVertexEXT(mode, count_, type, indices_, primcount, basevertex);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements and an index to apply to each index
        /// <para>
        /// glMultiDrawElementsBaseVertex behaves identically to glDrawElementsBaseVertex, except that drawcount
        /// separate lists of elements are specifried instead
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count, indices and basevertex arrays.
        /// </param>
        /// <param name="basevertex">
        /// Specifies a pointer to the location where the base vertices are stored.
        /// </param>
        public static void glMultiDrawElementsBaseVertexEXT(int mode, int[] count, int type, IntPtr[] indices, int primcount, int[] basevertex) {
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
            fixed(int* basevertex_ = &basevertex[0])
                Pointers.glMultiDrawElementsBaseVertexEXT(mode, count_, type, indices_, primcount, basevertex_);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElementsEXT(int mode, int* count, int type, IntPtr* indices, int primcount) {
            Pointers.glMultiDrawElementsEXT(mode, count, type, indices, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElementsEXT(int mode, int* count, int type, IntPtr[] indices, int primcount) {
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElementsEXT(mode, count, type, indices_, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElementsEXT(int mode, int[] count, int type, IntPtr* indices, int primcount) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawElementsEXT(mode, count_, type, indices, primcount);
        }
        
        /// <summary>
        /// render multiple sets of primitives by specifying indices of array data elements
        /// <para>
        /// glMultiDrawElements specifies multiple sets of geometric primitives with very few subroutine calls.
        /// Instead of calling a GL function to pass each individual vertex, normal, texture coordinate, edge
        /// flag, or color, you can prespecify separate arrays of vertices, normals, and so on, and use them to
        /// construct a sequence of primitives with a single call to glMultiDrawElements
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="count">
        /// Points to an array of the elements counts.
        /// </param>
        /// <param name="type">
        /// Specifies the type of the values in indices. Must be one of GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT, or
        /// GL_UNSIGNED_INT.
        /// </param>
        /// <param name="indices">
        /// Specifies a pointer to the location where the indices are stored.
        /// </param>
        /// <param name="primcount">
        /// Specifies the size of the count and indices arrays.
        /// </param>
        public static void glMultiDrawElementsEXT(int mode, int[] count, int type, IntPtr[] indices, int primcount) {
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiDrawElementsEXT(mode, count_, type, indices_, primcount);
        }
        
        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>
        /// glMultiDrawElementsIndirect specifies multiple indexed geometric primitives with very few subroutine
        /// calls. glMultiDrawElementsIndirect behaves similarly to a multitude of calls to
        /// glDrawElementsInstancedBaseVertexBaseInstance, execpt that the parameters to
        /// glDrawElementsInstancedBaseVertexBaseInstance are stored in an array in memory at the address given
        /// by indirect, separated by the stride, in basic machine units, specified by stride. If stride is
        /// zero, then the array is assumed to be tightly packed in memory
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing an array of draw parameters.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the number of elements in the array addressed by indirect.
        /// </param>
        /// <param name="stride">
        /// Specifies the distance in basic machine units between elements of the draw parameter array.
        /// </param>
        public static void glMultiDrawElementsIndirect(int mode, int type, IntPtr indirect, int drawcount, int stride) {
            Pointers.glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
        }
        
        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>
        /// glMultiDrawElementsIndirect specifies multiple indexed geometric primitives with very few subroutine
        /// calls. glMultiDrawElementsIndirect behaves similarly to a multitude of calls to
        /// glDrawElementsInstancedBaseVertexBaseInstance, execpt that the parameters to
        /// glDrawElementsInstancedBaseVertexBaseInstance are stored in an array in memory at the address given
        /// by indirect, separated by the stride, in basic machine units, specified by stride. If stride is
        /// zero, then the array is assumed to be tightly packed in memory
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing an array of draw parameters.
        /// </param>
        /// <param name="primcount">
        /// Specifies the number of elements in the array addressed by indirect.
        /// </param>
        /// <param name="stride">
        /// Specifies the distance in basic machine units between elements of the draw parameter array.
        /// </param>
        public static void glMultiDrawElementsIndirectAMD(int mode, int type, IntPtr indirect, int primcount, int stride) {
            Pointers.glMultiDrawElementsIndirectAMD(mode, type, indirect, primcount, stride);
        }
        
        public static void glMultiDrawElementsIndirectBindlessCountNV(int mode, int type, IntPtr indirect, int drawCount, int maxDrawCount, int stride, int vertexBufferCount) {
            Pointers.glMultiDrawElementsIndirectBindlessCountNV(mode, type, indirect, drawCount, maxDrawCount, stride, vertexBufferCount);
        }
        
        public static void glMultiDrawElementsIndirectBindlessNV(int mode, int type, IntPtr indirect, int drawCount, int stride, int vertexBufferCount) {
            Pointers.glMultiDrawElementsIndirectBindlessNV(mode, type, indirect, drawCount, stride, vertexBufferCount);
        }
        
        public static void glMultiDrawElementsIndirectCount(int mode, int type, IntPtr indirect, uint drawcount, int maxdrawcount, int stride) {
            Pointers.glMultiDrawElementsIndirectCount(mode, type, indirect, drawcount, maxdrawcount, stride);
        }
        
        public static void glMultiDrawElementsIndirectCountARB(int mode, int type, IntPtr indirect, uint drawcount, int maxdrawcount, int stride) {
            Pointers.glMultiDrawElementsIndirectCountARB(mode, type, indirect, drawcount, maxdrawcount, stride);
        }
        
        /// <summary>
        /// render indexed primitives from array data, taking parameters from memory
        /// <para>
        /// glMultiDrawElementsIndirect specifies multiple indexed geometric primitives with very few subroutine
        /// calls. glMultiDrawElementsIndirect behaves similarly to a multitude of calls to
        /// glDrawElementsInstancedBaseVertexBaseInstance, execpt that the parameters to
        /// glDrawElementsInstancedBaseVertexBaseInstance are stored in an array in memory at the address given
        /// by indirect, separated by the stride, in basic machine units, specified by stride. If stride is
        /// zero, then the array is assumed to be tightly packed in memory
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies what kind of primitives to render. Symbolic constants GL_POINTS, GL_LINE_STRIP,
        /// GL_LINE_LOOP, GL_LINES, GL_LINE_STRIP_ADJACENCY, GL_LINES_ADJACENCY, GL_TRIANGLE_STRIP,
        /// GL_TRIANGLE_FAN, GL_TRIANGLES, GL_TRIANGLE_STRIP_ADJACENCY, GL_TRIANGLES_ADJACENCY, and GL_PATCHES
        /// are accepted.
        /// </param>
        /// <param name="type">
        /// Specifies the type of data in the buffer bound to the GL_ELEMENT_ARRAY_BUFFER binding.
        /// </param>
        /// <param name="indirect">
        /// Specifies the address of a structure containing an array of draw parameters.
        /// </param>
        /// <param name="drawcount">
        /// Specifies the number of elements in the array addressed by indirect.
        /// </param>
        /// <param name="stride">
        /// Specifies the distance in basic machine units between elements of the draw parameter array.
        /// </param>
        public static void glMultiDrawElementsIndirectEXT(int mode, int type, IntPtr indirect, int drawcount, int stride) {
            Pointers.glMultiDrawElementsIndirectEXT(mode, type, indirect, drawcount, stride);
        }
        
        public static void glMultiDrawRangeElementArrayAPPLE(int mode, uint start, uint end, int* first, int* count, int primcount) {
            Pointers.glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count, primcount);
        }
        
        public static void glMultiDrawRangeElementArrayAPPLE(int mode, uint start, uint end, int* first, int[] count, int primcount) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawRangeElementArrayAPPLE(mode, start, end, first, count_, primcount);
        }
        
        public static void glMultiDrawRangeElementArrayAPPLE(int mode, uint start, uint end, int[] first, int* count, int primcount) {
            fixed(int* first_ = &first[0])
                Pointers.glMultiDrawRangeElementArrayAPPLE(mode, start, end, first_, count, primcount);
        }
        
        public static void glMultiDrawRangeElementArrayAPPLE(int mode, uint start, uint end, int[] first, int[] count, int primcount) {
            fixed(int* first_ = &first[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiDrawRangeElementArrayAPPLE(mode, start, end, first_, count_, primcount);
        }
        
        public static void glMultiModeDrawArraysIBM(uint* mode, int* first, int* count, int primcount, int modestride) {
            Pointers.glMultiModeDrawArraysIBM(mode, first, count, primcount, modestride);
        }
        
        public static void glMultiModeDrawArraysIBM(uint* mode, int* first, int[] count, int primcount, int modestride) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiModeDrawArraysIBM(mode, first, count_, primcount, modestride);
        }
        
        public static void glMultiModeDrawArraysIBM(uint* mode, int[] first, int* count, int primcount, int modestride) {
            fixed(int* first_ = &first[0])
                Pointers.glMultiModeDrawArraysIBM(mode, first_, count, primcount, modestride);
        }
        
        public static void glMultiModeDrawArraysIBM(uint* mode, int[] first, int[] count, int primcount, int modestride) {
            fixed(int* first_ = &first[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiModeDrawArraysIBM(mode, first_, count_, primcount, modestride);
        }
        
        public static void glMultiModeDrawArraysIBM(uint[] mode, int* first, int* count, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
                Pointers.glMultiModeDrawArraysIBM(mode_, first, count, primcount, modestride);
        }
        
        public static void glMultiModeDrawArraysIBM(uint[] mode, int* first, int[] count, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiModeDrawArraysIBM(mode_, first, count_, primcount, modestride);
        }
        
        public static void glMultiModeDrawArraysIBM(uint[] mode, int[] first, int* count, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
            fixed(int* first_ = &first[0])
                Pointers.glMultiModeDrawArraysIBM(mode_, first_, count, primcount, modestride);
        }
        
        public static void glMultiModeDrawArraysIBM(uint[] mode, int[] first, int[] count, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
            fixed(int* first_ = &first[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiModeDrawArraysIBM(mode_, first_, count_, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint* mode, int* count, int type, IntPtr* indices, int primcount, int modestride) {
            Pointers.glMultiModeDrawElementsIBM(mode, count, type, indices, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint* mode, int* count, int type, IntPtr[] indices, int primcount, int modestride) {
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiModeDrawElementsIBM(mode, count, type, indices_, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint* mode, int[] count, int type, IntPtr* indices, int primcount, int modestride) {
            fixed(int* count_ = &count[0])
                Pointers.glMultiModeDrawElementsIBM(mode, count_, type, indices, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint* mode, int[] count, int type, IntPtr[] indices, int primcount, int modestride) {
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiModeDrawElementsIBM(mode, count_, type, indices_, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint[] mode, int* count, int type, IntPtr* indices, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
                Pointers.glMultiModeDrawElementsIBM(mode_, count, type, indices, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint[] mode, int* count, int type, IntPtr[] indices, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiModeDrawElementsIBM(mode_, count, type, indices_, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint[] mode, int[] count, int type, IntPtr* indices, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
            fixed(int* count_ = &count[0])
                Pointers.glMultiModeDrawElementsIBM(mode_, count_, type, indices, primcount, modestride);
        }
        
        public static void glMultiModeDrawElementsIBM(uint[] mode, int[] count, int type, IntPtr[] indices, int primcount, int modestride) {
            fixed(uint* mode_ = &mode[0])
            fixed(int* count_ = &count[0])
            fixed(IntPtr* indices_ = &indices[0])
                Pointers.glMultiModeDrawElementsIBM(mode_, count_, type, indices_, primcount, modestride);
        }
        
        public static void glMultiTexBufferEXT(int texunit, int target, int internalformat, uint buffer) {
            Pointers.glMultiTexBufferEXT(texunit, target, internalformat, buffer);
        }
        
        public static void glMultiTexCoord1bOES(int texture, sbyte s) {
            Pointers.glMultiTexCoord1bOES(texture, s);
        }
        
        public static void glMultiTexCoord1bvOES(int texture, sbyte* coords) {
            Pointers.glMultiTexCoord1bvOES(texture, coords);
        }
        
        public static void glMultiTexCoord1bvOES(int texture, out sbyte coords) {
            fixed(sbyte* coords_ = &coords)
                Pointers.glMultiTexCoord1bvOES(texture, coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1d(int target, double s) {
            Pointers.glMultiTexCoord1d(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1dARB(int target, double s) {
            Pointers.glMultiTexCoord1dARB(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1dv(int target, double* v) {
            Pointers.glMultiTexCoord1dv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1dv(int target, out double v) {
            fixed(double* v_ = &v)
                Pointers.glMultiTexCoord1dv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1dvARB(int target, double* v) {
            Pointers.glMultiTexCoord1dvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1dvARB(int target, out double v) {
            fixed(double* v_ = &v)
                Pointers.glMultiTexCoord1dvARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1f(int target, float s) {
            Pointers.glMultiTexCoord1f(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1fARB(int target, float s) {
            Pointers.glMultiTexCoord1fARB(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1fv(int target, float* v) {
            Pointers.glMultiTexCoord1fv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1fv(int target, out float v) {
            fixed(float* v_ = &v)
                Pointers.glMultiTexCoord1fv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1fvARB(int target, float* v) {
            Pointers.glMultiTexCoord1fvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1fvARB(int target, out float v) {
            fixed(float* v_ = &v)
                Pointers.glMultiTexCoord1fvARB(target, v_);
        }
        
        public static void glMultiTexCoord1hNV(int target, short s) {
            Pointers.glMultiTexCoord1hNV(target, s);
        }
        
        public static void glMultiTexCoord1hvNV(int target, short* v) {
            Pointers.glMultiTexCoord1hvNV(target, v);
        }
        
        public static void glMultiTexCoord1hvNV(int target, out short v) {
            fixed(short* v_ = &v)
                Pointers.glMultiTexCoord1hvNV(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1i(int target, int s) {
            Pointers.glMultiTexCoord1i(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1iARB(int target, int s) {
            Pointers.glMultiTexCoord1iARB(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1iv(int target, int* v) {
            Pointers.glMultiTexCoord1iv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1iv(int target, out int v) {
            fixed(int* v_ = &v)
                Pointers.glMultiTexCoord1iv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1ivARB(int target, int* v) {
            Pointers.glMultiTexCoord1ivARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1ivARB(int target, out int v) {
            fixed(int* v_ = &v)
                Pointers.glMultiTexCoord1ivARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1s(int target, short s) {
            Pointers.glMultiTexCoord1s(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord1sARB(int target, short s) {
            Pointers.glMultiTexCoord1sARB(target, s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1sv(int target, short* v) {
            Pointers.glMultiTexCoord1sv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1sv(int target, out short v) {
            fixed(short* v_ = &v)
                Pointers.glMultiTexCoord1sv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1svARB(int target, short* v) {
            Pointers.glMultiTexCoord1svARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord1svARB(int target, out short v) {
            fixed(short* v_ = &v)
                Pointers.glMultiTexCoord1svARB(target, v_);
        }
        
        public static void glMultiTexCoord1xOES(int texture, IntPtr s) {
            Pointers.glMultiTexCoord1xOES(texture, s);
        }
        
        public static void glMultiTexCoord1xvOES(int texture, IntPtr* coords) {
            Pointers.glMultiTexCoord1xvOES(texture, coords);
        }
        
        public static void glMultiTexCoord1xvOES(int texture, out IntPtr coords) {
            fixed(IntPtr* coords_ = &coords)
                Pointers.glMultiTexCoord1xvOES(texture, coords_);
        }
        
        public static void glMultiTexCoord2bOES(int texture, sbyte s, sbyte t) {
            Pointers.glMultiTexCoord2bOES(texture, s, t);
        }
        
        public static void glMultiTexCoord2bvOES(int texture, sbyte* coords) {
            Pointers.glMultiTexCoord2bvOES(texture, coords);
        }
        
        public static void glMultiTexCoord2bvOES(int texture, sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glMultiTexCoord2bvOES(texture, coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2d(int target, double s, double t) {
            Pointers.glMultiTexCoord2d(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2dARB(int target, double s, double t) {
            Pointers.glMultiTexCoord2dARB(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2dv(int target, double* v) {
            Pointers.glMultiTexCoord2dv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2dv(int target, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glMultiTexCoord2dv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2dvARB(int target, double* v) {
            Pointers.glMultiTexCoord2dvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2dvARB(int target, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glMultiTexCoord2dvARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2f(int target, float s, float t) {
            Pointers.glMultiTexCoord2f(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2fARB(int target, float s, float t) {
            Pointers.glMultiTexCoord2fARB(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2fv(int target, float* v) {
            Pointers.glMultiTexCoord2fv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2fv(int target, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glMultiTexCoord2fv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2fvARB(int target, float* v) {
            Pointers.glMultiTexCoord2fvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2fvARB(int target, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glMultiTexCoord2fvARB(target, v_);
        }
        
        public static void glMultiTexCoord2hNV(int target, short s, short t) {
            Pointers.glMultiTexCoord2hNV(target, s, t);
        }
        
        public static void glMultiTexCoord2hvNV(int target, short* v) {
            Pointers.glMultiTexCoord2hvNV(target, v);
        }
        
        public static void glMultiTexCoord2hvNV(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord2hvNV(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2i(int target, int s, int t) {
            Pointers.glMultiTexCoord2i(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2iARB(int target, int s, int t) {
            Pointers.glMultiTexCoord2iARB(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2iv(int target, int* v) {
            Pointers.glMultiTexCoord2iv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2iv(int target, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glMultiTexCoord2iv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2ivARB(int target, int* v) {
            Pointers.glMultiTexCoord2ivARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2ivARB(int target, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glMultiTexCoord2ivARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2s(int target, short s, short t) {
            Pointers.glMultiTexCoord2s(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord2sARB(int target, short s, short t) {
            Pointers.glMultiTexCoord2sARB(target, s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2sv(int target, short* v) {
            Pointers.glMultiTexCoord2sv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2sv(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord2sv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2svARB(int target, short* v) {
            Pointers.glMultiTexCoord2svARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord2svARB(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord2svARB(target, v_);
        }
        
        public static void glMultiTexCoord2xOES(int texture, IntPtr s, IntPtr t) {
            Pointers.glMultiTexCoord2xOES(texture, s, t);
        }
        
        public static void glMultiTexCoord2xvOES(int texture, IntPtr* coords) {
            Pointers.glMultiTexCoord2xvOES(texture, coords);
        }
        
        public static void glMultiTexCoord2xvOES(int texture, IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glMultiTexCoord2xvOES(texture, coords_);
        }
        
        public static void glMultiTexCoord3bOES(int texture, sbyte s, sbyte t, sbyte r) {
            Pointers.glMultiTexCoord3bOES(texture, s, t, r);
        }
        
        public static void glMultiTexCoord3bvOES(int texture, sbyte* coords) {
            Pointers.glMultiTexCoord3bvOES(texture, coords);
        }
        
        public static void glMultiTexCoord3bvOES(int texture, sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glMultiTexCoord3bvOES(texture, coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3d(int target, double s, double t, double r) {
            Pointers.glMultiTexCoord3d(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3dARB(int target, double s, double t, double r) {
            Pointers.glMultiTexCoord3dARB(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3dv(int target, double* v) {
            Pointers.glMultiTexCoord3dv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3dv(int target, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glMultiTexCoord3dv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3dvARB(int target, double* v) {
            Pointers.glMultiTexCoord3dvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3dvARB(int target, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glMultiTexCoord3dvARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3f(int target, float s, float t, float r) {
            Pointers.glMultiTexCoord3f(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3fARB(int target, float s, float t, float r) {
            Pointers.glMultiTexCoord3fARB(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3fv(int target, float* v) {
            Pointers.glMultiTexCoord3fv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3fv(int target, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glMultiTexCoord3fv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3fvARB(int target, float* v) {
            Pointers.glMultiTexCoord3fvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3fvARB(int target, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glMultiTexCoord3fvARB(target, v_);
        }
        
        public static void glMultiTexCoord3hNV(int target, short s, short t, short r) {
            Pointers.glMultiTexCoord3hNV(target, s, t, r);
        }
        
        public static void glMultiTexCoord3hvNV(int target, short* v) {
            Pointers.glMultiTexCoord3hvNV(target, v);
        }
        
        public static void glMultiTexCoord3hvNV(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord3hvNV(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3i(int target, int s, int t, int r) {
            Pointers.glMultiTexCoord3i(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3iARB(int target, int s, int t, int r) {
            Pointers.glMultiTexCoord3iARB(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3iv(int target, int* v) {
            Pointers.glMultiTexCoord3iv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3iv(int target, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glMultiTexCoord3iv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3ivARB(int target, int* v) {
            Pointers.glMultiTexCoord3ivARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3ivARB(int target, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glMultiTexCoord3ivARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3s(int target, short s, short t, short r) {
            Pointers.glMultiTexCoord3s(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord3sARB(int target, short s, short t, short r) {
            Pointers.glMultiTexCoord3sARB(target, s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3sv(int target, short* v) {
            Pointers.glMultiTexCoord3sv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3sv(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord3sv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3svARB(int target, short* v) {
            Pointers.glMultiTexCoord3svARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord3svARB(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord3svARB(target, v_);
        }
        
        public static void glMultiTexCoord3xOES(int texture, IntPtr s, IntPtr t, IntPtr r) {
            Pointers.glMultiTexCoord3xOES(texture, s, t, r);
        }
        
        public static void glMultiTexCoord3xvOES(int texture, IntPtr* coords) {
            Pointers.glMultiTexCoord3xvOES(texture, coords);
        }
        
        public static void glMultiTexCoord3xvOES(int texture, IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glMultiTexCoord3xvOES(texture, coords_);
        }
        
        public static void glMultiTexCoord4bOES(int texture, sbyte s, sbyte t, sbyte r, sbyte q) {
            Pointers.glMultiTexCoord4bOES(texture, s, t, r, q);
        }
        
        public static void glMultiTexCoord4bvOES(int texture, sbyte* coords) {
            Pointers.glMultiTexCoord4bvOES(texture, coords);
        }
        
        public static void glMultiTexCoord4bvOES(int texture, sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glMultiTexCoord4bvOES(texture, coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4d(int target, double s, double t, double r, double q) {
            Pointers.glMultiTexCoord4d(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4dARB(int target, double s, double t, double r, double q) {
            Pointers.glMultiTexCoord4dARB(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4dv(int target, double* v) {
            Pointers.glMultiTexCoord4dv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4dv(int target, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glMultiTexCoord4dv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4dvARB(int target, double* v) {
            Pointers.glMultiTexCoord4dvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4dvARB(int target, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glMultiTexCoord4dvARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4f(int target, float s, float t, float r, float q) {
            Pointers.glMultiTexCoord4f(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4fARB(int target, float s, float t, float r, float q) {
            Pointers.glMultiTexCoord4fARB(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4fv(int target, float* v) {
            Pointers.glMultiTexCoord4fv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4fv(int target, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glMultiTexCoord4fv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4fvARB(int target, float* v) {
            Pointers.glMultiTexCoord4fvARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4fvARB(int target, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glMultiTexCoord4fvARB(target, v_);
        }
        
        public static void glMultiTexCoord4hNV(int target, short s, short t, short r, short q) {
            Pointers.glMultiTexCoord4hNV(target, s, t, r, q);
        }
        
        public static void glMultiTexCoord4hvNV(int target, short* v) {
            Pointers.glMultiTexCoord4hvNV(target, v);
        }
        
        public static void glMultiTexCoord4hvNV(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord4hvNV(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4i(int target, int s, int t, int r, int q) {
            Pointers.glMultiTexCoord4i(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4iARB(int target, int s, int t, int r, int q) {
            Pointers.glMultiTexCoord4iARB(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4iv(int target, int* v) {
            Pointers.glMultiTexCoord4iv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4iv(int target, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glMultiTexCoord4iv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4ivARB(int target, int* v) {
            Pointers.glMultiTexCoord4ivARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4ivARB(int target, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glMultiTexCoord4ivARB(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4s(int target, short s, short t, short r, short q) {
            Pointers.glMultiTexCoord4s(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates for target texture unit. Not all parameters are present
        /// in all forms of the command.
        /// </param>
        public static void glMultiTexCoord4sARB(int target, short s, short t, short r, short q) {
            Pointers.glMultiTexCoord4sARB(target, s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4sv(int target, short* v) {
            Pointers.glMultiTexCoord4sv(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4sv(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord4sv(target, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4svARB(int target, short* v) {
            Pointers.glMultiTexCoord4svARB(target, v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glMultiTexCoord specifies texture coordinates in one, two, three, or four dimensions.
        /// glMultiTexCoord1 sets the current texture coordinates to s 0 0 1 ; a call to glMultiTexCoord2 sets
        /// them to s t 0 1 . Similarly, glMultiTexCoord3 specifies the texture coordinates as s t r 1 , and
        /// glMultiTexCoord4 defines all four components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        /// <param name="v">
        /// Specifies the texture unit whose coordinates should be modified. The number of texture units is
        /// implementation dependent, but must be at least two. Symbolic constant must be one of GL_TEXTUREi,
        /// where i ranges from 0 to GL_MAX_TEXTURE_COORDS - 1, which is an implementation-dependent value.
        /// </param>
        public static void glMultiTexCoord4svARB(int target, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glMultiTexCoord4svARB(target, v_);
        }
        
        public static void glMultiTexCoord4x(int texture, IntPtr s, IntPtr t, IntPtr r, IntPtr q) {
            Pointers.glMultiTexCoord4x(texture, s, t, r, q);
        }
        
        public static void glMultiTexCoord4xOES(int texture, IntPtr s, IntPtr t, IntPtr r, IntPtr q) {
            Pointers.glMultiTexCoord4xOES(texture, s, t, r, q);
        }
        
        public static void glMultiTexCoord4xvOES(int texture, IntPtr* coords) {
            Pointers.glMultiTexCoord4xvOES(texture, coords);
        }
        
        public static void glMultiTexCoord4xvOES(int texture, IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glMultiTexCoord4xvOES(texture, coords_);
        }
        
        public static void glMultiTexCoordP1ui(int texture, int type, uint coords) {
            Pointers.glMultiTexCoordP1ui(texture, type, coords);
        }
        
        public static void glMultiTexCoordP1uiv(int texture, int type, uint* coords) {
            Pointers.glMultiTexCoordP1uiv(texture, type, coords);
        }
        
        public static void glMultiTexCoordP1uiv(int texture, int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glMultiTexCoordP1uiv(texture, type, coords_);
        }
        
        public static void glMultiTexCoordP2ui(int texture, int type, uint coords) {
            Pointers.glMultiTexCoordP2ui(texture, type, coords);
        }
        
        public static void glMultiTexCoordP2uiv(int texture, int type, uint* coords) {
            Pointers.glMultiTexCoordP2uiv(texture, type, coords);
        }
        
        public static void glMultiTexCoordP2uiv(int texture, int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glMultiTexCoordP2uiv(texture, type, coords_);
        }
        
        public static void glMultiTexCoordP3ui(int texture, int type, uint coords) {
            Pointers.glMultiTexCoordP3ui(texture, type, coords);
        }
        
        public static void glMultiTexCoordP3uiv(int texture, int type, uint* coords) {
            Pointers.glMultiTexCoordP3uiv(texture, type, coords);
        }
        
        public static void glMultiTexCoordP3uiv(int texture, int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glMultiTexCoordP3uiv(texture, type, coords_);
        }
        
        public static void glMultiTexCoordP4ui(int texture, int type, uint coords) {
            Pointers.glMultiTexCoordP4ui(texture, type, coords);
        }
        
        public static void glMultiTexCoordP4uiv(int texture, int type, uint* coords) {
            Pointers.glMultiTexCoordP4uiv(texture, type, coords);
        }
        
        public static void glMultiTexCoordP4uiv(int texture, int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glMultiTexCoordP4uiv(texture, type, coords_);
        }
        
        public static void glMultiTexCoordPointerEXT(int texunit, int size, int type, int stride, IntPtr pointer) {
            Pointers.glMultiTexCoordPointerEXT(texunit, size, type, stride, pointer);
        }
        
        public static void glMultiTexEnvfEXT(int texunit, int target, int pname, float param) {
            Pointers.glMultiTexEnvfEXT(texunit, target, pname, param);
        }
        
        public static void glMultiTexEnvfvEXT(int texunit, int target, int pname, float* _params) {
            Pointers.glMultiTexEnvfvEXT(texunit, target, pname, _params);
        }
        
        public static void glMultiTexEnvfvEXT(int texunit, int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glMultiTexEnvfvEXT(texunit, target, pname, _params_);
        }
        
        public static void glMultiTexEnviEXT(int texunit, int target, int pname, int param) {
            Pointers.glMultiTexEnviEXT(texunit, target, pname, param);
        }
        
        public static void glMultiTexEnvivEXT(int texunit, int target, int pname, int* _params) {
            Pointers.glMultiTexEnvivEXT(texunit, target, pname, _params);
        }
        
        public static void glMultiTexEnvivEXT(int texunit, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMultiTexEnvivEXT(texunit, target, pname, _params_);
        }
        
        public static void glMultiTexGendEXT(int texunit, int coord, int pname, double param) {
            Pointers.glMultiTexGendEXT(texunit, coord, pname, param);
        }
        
        public static void glMultiTexGendvEXT(int texunit, int coord, int pname, double* _params) {
            Pointers.glMultiTexGendvEXT(texunit, coord, pname, _params);
        }
        
        public static void glMultiTexGendvEXT(int texunit, int coord, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glMultiTexGendvEXT(texunit, coord, pname, _params_);
        }
        
        public static void glMultiTexGenfEXT(int texunit, int coord, int pname, float param) {
            Pointers.glMultiTexGenfEXT(texunit, coord, pname, param);
        }
        
        public static void glMultiTexGenfvEXT(int texunit, int coord, int pname, float* _params) {
            Pointers.glMultiTexGenfvEXT(texunit, coord, pname, _params);
        }
        
        public static void glMultiTexGenfvEXT(int texunit, int coord, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glMultiTexGenfvEXT(texunit, coord, pname, _params_);
        }
        
        public static void glMultiTexGeniEXT(int texunit, int coord, int pname, int param) {
            Pointers.glMultiTexGeniEXT(texunit, coord, pname, param);
        }
        
        public static void glMultiTexGenivEXT(int texunit, int coord, int pname, int* _params) {
            Pointers.glMultiTexGenivEXT(texunit, coord, pname, _params);
        }
        
        public static void glMultiTexGenivEXT(int texunit, int coord, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMultiTexGenivEXT(texunit, coord, pname, _params_);
        }
        
        public static void glMultiTexImage1DEXT(int texunit, int target, int level, int internalformat, int width, int border, int format, int type, IntPtr pixels) {
            Pointers.glMultiTexImage1DEXT(texunit, target, level, internalformat, width, border, format, type, pixels);
        }
        
        public static void glMultiTexImage2DEXT(int texunit, int target, int level, int internalformat, int width, int height, int border, int format, int type, IntPtr pixels) {
            Pointers.glMultiTexImage2DEXT(texunit, target, level, internalformat, width, height, border, format, type, pixels);
        }
        
        public static void glMultiTexImage3DEXT(int texunit, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels) {
            Pointers.glMultiTexImage3DEXT(texunit, target, level, internalformat, width, height, depth, border, format, type, pixels);
        }
        
        public static void glMultiTexParameterIivEXT(int texunit, int target, int pname, int* _params) {
            Pointers.glMultiTexParameterIivEXT(texunit, target, pname, _params);
        }
        
        public static void glMultiTexParameterIivEXT(int texunit, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMultiTexParameterIivEXT(texunit, target, pname, _params_);
        }
        
        public static void glMultiTexParameterIuivEXT(int texunit, int target, int pname, uint* _params) {
            Pointers.glMultiTexParameterIuivEXT(texunit, target, pname, _params);
        }
        
        public static void glMultiTexParameterIuivEXT(int texunit, int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glMultiTexParameterIuivEXT(texunit, target, pname, _params_);
        }
        
        public static void glMultiTexParameterfEXT(int texunit, int target, int pname, float param) {
            Pointers.glMultiTexParameterfEXT(texunit, target, pname, param);
        }
        
        public static void glMultiTexParameterfvEXT(int texunit, int target, int pname, float* _params) {
            Pointers.glMultiTexParameterfvEXT(texunit, target, pname, _params);
        }
        
        public static void glMultiTexParameterfvEXT(int texunit, int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glMultiTexParameterfvEXT(texunit, target, pname, _params_);
        }
        
        public static void glMultiTexParameteriEXT(int texunit, int target, int pname, int param) {
            Pointers.glMultiTexParameteriEXT(texunit, target, pname, param);
        }
        
        public static void glMultiTexParameterivEXT(int texunit, int target, int pname, int* _params) {
            Pointers.glMultiTexParameterivEXT(texunit, target, pname, _params);
        }
        
        public static void glMultiTexParameterivEXT(int texunit, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMultiTexParameterivEXT(texunit, target, pname, _params_);
        }
        
        public static void glMultiTexRenderbufferEXT(int texunit, int target, uint renderbuffer) {
            Pointers.glMultiTexRenderbufferEXT(texunit, target, renderbuffer);
        }
        
        public static void glMultiTexSubImage1DEXT(int texunit, int target, int level, int xoffset, int width, int format, int type, IntPtr pixels) {
            Pointers.glMultiTexSubImage1DEXT(texunit, target, level, xoffset, width, format, type, pixels);
        }
        
        public static void glMultiTexSubImage2DEXT(int texunit, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels) {
            Pointers.glMultiTexSubImage2DEXT(texunit, target, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        
        public static void glMultiTexSubImage3DEXT(int texunit, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels) {
            Pointers.glMultiTexSubImage3DEXT(texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        public static void glMulticastBarrierNV() {
            Pointers.glMulticastBarrierNV();
        }
        
        public static void glMulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, uint mask, int filter) {
            Pointers.glMulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
        }
        
        public static void glMulticastBlitFramebufferNV(uint srcGpu, uint dstGpu, int srcX0, int srcY0, int srcX1, int srcY1, int dstX0, int dstY0, int dstX1, int dstY1, Enums.ClearBufferMask mask, int filter) {
            Pointers.glMulticastBlitFramebufferNV(srcGpu, dstGpu, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, (uint)mask, filter);
        }
        
        public static void glMulticastBufferSubDataNV(uint gpuMask, uint buffer, uint offset, uint size, IntPtr data) {
            Pointers.glMulticastBufferSubDataNV(gpuMask, buffer, offset, size, data);
        }
        
        public static void glMulticastCopyBufferSubDataNV(uint readGpu, uint writeGpuMask, uint readBuffer, uint writeBuffer, uint readOffset, uint writeOffset, uint size) {
            Pointers.glMulticastCopyBufferSubDataNV(readGpu, writeGpuMask, readBuffer, writeBuffer, readOffset, writeOffset, size);
        }
        
        public static void glMulticastCopyImageSubDataNV(uint srcGpu, uint dstGpuMask, uint srcName, int srcTarget, int srcLevel, int srcX, int srcY, int srcZ, uint dstName, int dstTarget, int dstLevel, int dstX, int dstY, int dstZ, int srcWidth, int srcHeight, int srcDepth) {
            Pointers.glMulticastCopyImageSubDataNV(srcGpu, dstGpuMask, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
        }
        
        public static void glMulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, float* v) {
            Pointers.glMulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v);
        }
        
        public static void glMulticastFramebufferSampleLocationsfvNV(uint gpu, uint framebuffer, uint start, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glMulticastFramebufferSampleLocationsfvNV(gpu, framebuffer, start, count, v_);
        }
        
        public static void glMulticastGetQueryObjecti64vNV(uint gpu, uint id, int pname, long* _params) {
            Pointers.glMulticastGetQueryObjecti64vNV(gpu, id, pname, _params);
        }
        
        public static void glMulticastGetQueryObjecti64vNV(uint gpu, uint id, int pname, long[] _params) {
            fixed(long* _params_ = &_params[0])
                Pointers.glMulticastGetQueryObjecti64vNV(gpu, id, pname, _params_);
        }
        
        public static void glMulticastGetQueryObjectivNV(uint gpu, uint id, int pname, int* _params) {
            Pointers.glMulticastGetQueryObjectivNV(gpu, id, pname, _params);
        }
        
        public static void glMulticastGetQueryObjectivNV(uint gpu, uint id, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glMulticastGetQueryObjectivNV(gpu, id, pname, _params_);
        }
        
        public static void glMulticastGetQueryObjectui64vNV(uint gpu, uint id, int pname, ulong* _params) {
            Pointers.glMulticastGetQueryObjectui64vNV(gpu, id, pname, _params);
        }
        
        public static void glMulticastGetQueryObjectui64vNV(uint gpu, uint id, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glMulticastGetQueryObjectui64vNV(gpu, id, pname, _params_);
        }
        
        public static void glMulticastGetQueryObjectuivNV(uint gpu, uint id, int pname, uint* _params) {
            Pointers.glMulticastGetQueryObjectuivNV(gpu, id, pname, _params);
        }
        
        public static void glMulticastGetQueryObjectuivNV(uint gpu, uint id, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glMulticastGetQueryObjectuivNV(gpu, id, pname, _params_);
        }
        
        public static void glMulticastWaitSyncNV(uint signalGpu, uint waitGpuMask) {
            Pointers.glMulticastWaitSyncNV(signalGpu, waitGpuMask);
        }
        
        public static void glNamedBufferData(uint buffer, uint size, IntPtr data, int usage) {
            Pointers.glNamedBufferData(buffer, size, data, usage);
        }
        
        public static void glNamedBufferDataEXT(uint buffer, uint size, IntPtr data, int usage) {
            Pointers.glNamedBufferDataEXT(buffer, size, data, usage);
        }
        
        public static void glNamedBufferPageCommitmentARB(uint buffer, uint offset, uint size, bool commit) {
            Pointers.glNamedBufferPageCommitmentARB(buffer, offset, size, commit);
        }
        
        public static void glNamedBufferPageCommitmentEXT(uint buffer, uint offset, uint size, bool commit) {
            Pointers.glNamedBufferPageCommitmentEXT(buffer, offset, size, commit);
        }
        
        public static void glNamedBufferStorage(uint buffer, uint size, IntPtr data, uint flags) {
            Pointers.glNamedBufferStorage(buffer, size, data, flags);
        }
        
        public static void glNamedBufferStorage(uint buffer, uint size, IntPtr data, Enums.MapBufferUsageMask flags) {
            Pointers.glNamedBufferStorage(buffer, size, data, (uint)flags);
        }
        
        public static void glNamedBufferStorageExternalEXT(uint buffer, uint offset, uint size, IntPtr clientBuffer, uint flags) {
            Pointers.glNamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, flags);
        }
        
        public static void glNamedBufferStorageExternalEXT(uint buffer, uint offset, uint size, IntPtr clientBuffer, Enums.MapBufferUsageMask flags) {
            Pointers.glNamedBufferStorageExternalEXT(buffer, offset, size, clientBuffer, (uint)flags);
        }
        
        public static void glNamedBufferStorageEXT(uint buffer, uint size, IntPtr data, uint flags) {
            Pointers.glNamedBufferStorageEXT(buffer, size, data, flags);
        }
        
        public static void glNamedBufferStorageEXT(uint buffer, uint size, IntPtr data, Enums.MapBufferUsageMask flags) {
            Pointers.glNamedBufferStorageEXT(buffer, size, data, (uint)flags);
        }
        
        public static void glNamedBufferStorageMemEXT(uint buffer, uint size, uint memory, ulong offset) {
            Pointers.glNamedBufferStorageMemEXT(buffer, size, memory, offset);
        }
        
        public static void glNamedBufferSubData(uint buffer, uint offset, uint size, IntPtr data) {
            Pointers.glNamedBufferSubData(buffer, offset, size, data);
        }
        
        public static void glNamedBufferSubDataEXT(uint buffer, uint offset, uint size, IntPtr data) {
            Pointers.glNamedBufferSubDataEXT(buffer, offset, size, data);
        }
        
        public static void glNamedCopyBufferSubDataEXT(uint readBuffer, uint writeBuffer, uint readOffset, uint writeOffset, uint size) {
            Pointers.glNamedCopyBufferSubDataEXT(readBuffer, writeBuffer, readOffset, writeOffset, size);
        }
        
        public static void glNamedFramebufferDrawBuffer(uint framebuffer, int buf) {
            Pointers.glNamedFramebufferDrawBuffer(framebuffer, buf);
        }
        
        public static void glNamedFramebufferDrawBuffers(uint framebuffer, int n, uint* bufs) {
            Pointers.glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
        }
        
        public static void glNamedFramebufferDrawBuffers(uint framebuffer, int n, uint[] bufs) {
            fixed(uint* bufs_ = &bufs[0])
                Pointers.glNamedFramebufferDrawBuffers(framebuffer, n, bufs_);
        }
        
        public static void glNamedFramebufferParameteri(uint framebuffer, int pname, int param) {
            Pointers.glNamedFramebufferParameteri(framebuffer, pname, param);
        }
        
        public static void glNamedFramebufferParameteriEXT(uint framebuffer, int pname, int param) {
            Pointers.glNamedFramebufferParameteriEXT(framebuffer, pname, param);
        }
        
        public static void glNamedFramebufferReadBuffer(uint framebuffer, int src) {
            Pointers.glNamedFramebufferReadBuffer(framebuffer, src);
        }
        
        public static void glNamedFramebufferRenderbuffer(uint framebuffer, int attachment, int renderbuffertarget, uint renderbuffer) {
            Pointers.glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
        }
        
        public static void glNamedFramebufferRenderbufferEXT(uint framebuffer, int attachment, int renderbuffertarget, uint renderbuffer) {
            Pointers.glNamedFramebufferRenderbufferEXT(framebuffer, attachment, renderbuffertarget, renderbuffer);
        }
        
        public static void glNamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, float* v) {
            Pointers.glNamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v);
        }
        
        public static void glNamedFramebufferSampleLocationsfvARB(uint framebuffer, uint start, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glNamedFramebufferSampleLocationsfvARB(framebuffer, start, count, v_);
        }
        
        public static void glNamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, float* v) {
            Pointers.glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v);
        }
        
        public static void glNamedFramebufferSampleLocationsfvNV(uint framebuffer, uint start, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glNamedFramebufferSampleLocationsfvNV(framebuffer, start, count, v_);
        }
        
        public static void glNamedFramebufferTexture(uint framebuffer, int attachment, uint texture, int level) {
            Pointers.glNamedFramebufferTexture(framebuffer, attachment, texture, level);
        }
        
        public static void glNamedFramebufferSamplePositionsfvAMD(uint framebuffer, uint numsamples, uint pixelindex, float* values) {
            Pointers.glNamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values);
        }
        
        public static void glNamedFramebufferSamplePositionsfvAMD(uint framebuffer, uint numsamples, uint pixelindex, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glNamedFramebufferSamplePositionsfvAMD(framebuffer, numsamples, pixelindex, values_);
        }
        
        public static void glNamedFramebufferTexture1DEXT(uint framebuffer, int attachment, int textarget, uint texture, int level) {
            Pointers.glNamedFramebufferTexture1DEXT(framebuffer, attachment, textarget, texture, level);
        }
        
        public static void glNamedFramebufferTexture2DEXT(uint framebuffer, int attachment, int textarget, uint texture, int level) {
            Pointers.glNamedFramebufferTexture2DEXT(framebuffer, attachment, textarget, texture, level);
        }
        
        public static void glNamedFramebufferTexture3DEXT(uint framebuffer, int attachment, int textarget, uint texture, int level, int zoffset) {
            Pointers.glNamedFramebufferTexture3DEXT(framebuffer, attachment, textarget, texture, level, zoffset);
        }
        
        public static void glNamedFramebufferTextureEXT(uint framebuffer, int attachment, uint texture, int level) {
            Pointers.glNamedFramebufferTextureEXT(framebuffer, attachment, texture, level);
        }
        
        public static void glNamedFramebufferTextureFaceEXT(uint framebuffer, int attachment, uint texture, int level, int face) {
            Pointers.glNamedFramebufferTextureFaceEXT(framebuffer, attachment, texture, level, face);
        }
        
        public static void glNamedFramebufferTextureLayer(uint framebuffer, int attachment, uint texture, int level, int layer) {
            Pointers.glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
        }
        
        public static void glNamedFramebufferTextureLayerEXT(uint framebuffer, int attachment, uint texture, int level, int layer) {
            Pointers.glNamedFramebufferTextureLayerEXT(framebuffer, attachment, texture, level, layer);
        }
        
        public static void glNamedProgramLocalParameter4dEXT(uint program, int target, uint index, double x, double y, double z, double w) {
            Pointers.glNamedProgramLocalParameter4dEXT(program, target, index, x, y, z, w);
        }
        
        public static void glNamedProgramLocalParameter4dvEXT(uint program, int target, uint index, double* _params) {
            Pointers.glNamedProgramLocalParameter4dvEXT(program, target, index, _params);
        }
        
        public static void glNamedProgramLocalParameter4dvEXT(uint program, int target, uint index, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glNamedProgramLocalParameter4dvEXT(program, target, index, _params_);
        }
        
        public static void glNamedProgramLocalParameter4fEXT(uint program, int target, uint index, float x, float y, float z, float w) {
            Pointers.glNamedProgramLocalParameter4fEXT(program, target, index, x, y, z, w);
        }
        
        public static void glNamedProgramLocalParameter4fvEXT(uint program, int target, uint index, float* _params) {
            Pointers.glNamedProgramLocalParameter4fvEXT(program, target, index, _params);
        }
        
        public static void glNamedProgramLocalParameter4fvEXT(uint program, int target, uint index, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glNamedProgramLocalParameter4fvEXT(program, target, index, _params_);
        }
        
        public static void glNamedProgramLocalParameterI4iEXT(uint program, int target, uint index, int x, int y, int z, int w) {
            Pointers.glNamedProgramLocalParameterI4iEXT(program, target, index, x, y, z, w);
        }
        
        public static void glNamedProgramLocalParameterI4ivEXT(uint program, int target, uint index, int* _params) {
            Pointers.glNamedProgramLocalParameterI4ivEXT(program, target, index, _params);
        }
        
        public static void glNamedProgramLocalParameterI4ivEXT(uint program, int target, uint index, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glNamedProgramLocalParameterI4ivEXT(program, target, index, _params_);
        }
        
        public static void glNamedProgramLocalParameterI4uiEXT(uint program, int target, uint index, uint x, uint y, uint z, uint w) {
            Pointers.glNamedProgramLocalParameterI4uiEXT(program, target, index, x, y, z, w);
        }
        
        public static void glNamedProgramLocalParameterI4uivEXT(uint program, int target, uint index, uint* _params) {
            Pointers.glNamedProgramLocalParameterI4uivEXT(program, target, index, _params);
        }
        
        public static void glNamedProgramLocalParameterI4uivEXT(uint program, int target, uint index, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glNamedProgramLocalParameterI4uivEXT(program, target, index, _params_);
        }
        
        public static void glNamedProgramLocalParameters4fvEXT(uint program, int target, uint index, int count, float* _params) {
            Pointers.glNamedProgramLocalParameters4fvEXT(program, target, index, count, _params);
        }
        
        public static void glNamedProgramLocalParameters4fvEXT(uint program, int target, uint index, int count, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glNamedProgramLocalParameters4fvEXT(program, target, index, count, _params_);
        }
        
        public static void glNamedProgramLocalParametersI4ivEXT(uint program, int target, uint index, int count, int* _params) {
            Pointers.glNamedProgramLocalParametersI4ivEXT(program, target, index, count, _params);
        }
        
        public static void glNamedProgramLocalParametersI4ivEXT(uint program, int target, uint index, int count, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glNamedProgramLocalParametersI4ivEXT(program, target, index, count, _params_);
        }
        
        public static void glNamedProgramLocalParametersI4uivEXT(uint program, int target, uint index, int count, uint* _params) {
            Pointers.glNamedProgramLocalParametersI4uivEXT(program, target, index, count, _params);
        }
        
        public static void glNamedProgramLocalParametersI4uivEXT(uint program, int target, uint index, int count, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glNamedProgramLocalParametersI4uivEXT(program, target, index, count, _params_);
        }
        
        public static void glNamedProgramStringEXT(uint program, int target, int format, int len, IntPtr _string) {
            Pointers.glNamedProgramStringEXT(program, target, format, len, _string);
        }
        
        public static void glNamedRenderbufferStorage(uint renderbuffer, int internalformat, int width, int height) {
            Pointers.glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
        }
        
        public static void glNamedRenderbufferStorageEXT(uint renderbuffer, int internalformat, int width, int height) {
            Pointers.glNamedRenderbufferStorageEXT(renderbuffer, internalformat, width, height);
        }
        
        public static void glNamedRenderbufferStorageMultisample(uint renderbuffer, int samples, int internalformat, int width, int height) {
            Pointers.glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
        }
        
        public static void glNamedRenderbufferStorageMultisampleCoverageEXT(uint renderbuffer, int coverageSamples, int colorSamples, int internalformat, int width, int height) {
            Pointers.glNamedRenderbufferStorageMultisampleCoverageEXT(renderbuffer, coverageSamples, colorSamples, internalformat, width, height);
        }
        
        public static void glNamedRenderbufferStorageMultisampleEXT(uint renderbuffer, int samples, int internalformat, int width, int height) {
            Pointers.glNamedRenderbufferStorageMultisampleEXT(renderbuffer, samples, internalformat, width, height);
        }
        
        public static void glNamedStringARB(int type, int namelen, string name, int stringlen, string _string) {
            Pointers.glNamedStringARB(type, namelen, name, stringlen, _string);
        }
        
        /// <summary>
        /// create or replace a display list
        /// <para>
        /// Display lists are groups of GL commands that have been stored for subsequent execution. Display
        /// lists are created with glNewList. All subsequent commands are placed in the display list, in the
        /// order issued, until glEndList is called
        /// </para>
        /// </summary>
        /// <param name="list">
        /// Specifies the display-list name.
        /// </param>
        /// <param name="mode">
        /// Specifies the compilation mode, which can be GL_COMPILE or GL_COMPILE_AND_EXECUTE.
        /// </param>
        public static void glNewList(uint list, int mode) {
            Pointers.glNewList(list, mode);
        }
        
        public static uint glNewObjectBufferATI(int size, IntPtr pointer, int usage) {
            return Pointers.glNewObjectBufferATI(size, pointer, usage);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="nx">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="ny">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="nz">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        public static void glNormal3b(sbyte nx, sbyte ny, sbyte nz) {
            Pointers.glNormal3b(nx, ny, nz);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3bv(sbyte* v) {
            Pointers.glNormal3bv(v);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3bv(sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glNormal3bv(v_);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="nx">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="ny">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="nz">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        public static void glNormal3d(double nx, double ny, double nz) {
            Pointers.glNormal3d(nx, ny, nz);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3dv(double* v) {
            Pointers.glNormal3dv(v);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glNormal3dv(v_);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="nx">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="ny">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="nz">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        public static void glNormal3f(float nx, float ny, float nz) {
            Pointers.glNormal3f(nx, ny, nz);
        }
        
        public static void glNormal3fVertex3fSUN(float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glNormal3fVertex3fSUN(nx, ny, nz, x, y, z);
        }
        
        public static void glNormal3fVertex3fvSUN(float* n, float* v) {
            Pointers.glNormal3fVertex3fvSUN(n, v);
        }
        
        public static void glNormal3fVertex3fvSUN(float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glNormal3fVertex3fvSUN(n, v_);
        }
        
        public static void glNormal3fVertex3fvSUN(float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glNormal3fVertex3fvSUN(n_, v);
        }
        
        public static void glNormal3fVertex3fvSUN(float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glNormal3fVertex3fvSUN(n_, v_);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3fv(float* v) {
            Pointers.glNormal3fv(v);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glNormal3fv(v_);
        }
        
        public static void glNormal3hNV(short nx, short ny, short nz) {
            Pointers.glNormal3hNV(nx, ny, nz);
        }
        
        public static void glNormal3hvNV(short* v) {
            Pointers.glNormal3hvNV(v);
        }
        
        public static void glNormal3hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glNormal3hvNV(v_);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="nx">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="ny">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="nz">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        public static void glNormal3i(int nx, int ny, int nz) {
            Pointers.glNormal3i(nx, ny, nz);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3iv(int* v) {
            Pointers.glNormal3iv(v);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glNormal3iv(v_);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="nx">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="ny">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        /// <param name="nz">
        /// Specify the x, y, and z coordinates of the new current normal. The initial value of the current
        /// normal is the unit vector, (0, 0, 1).
        /// </param>
        public static void glNormal3s(short nx, short ny, short nz) {
            Pointers.glNormal3s(nx, ny, nz);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3sv(short* v) {
            Pointers.glNormal3sv(v);
        }
        
        /// <summary>
        /// set the current normal vector
        /// <para>
        /// The current normal is set to the given coordinates whenever glNormal is issued. Byte, short, or
        /// integer arguments are converted to floating-point format with a linear mapping that maps the most
        /// positive representable integer value to 1.0 and the most negative representable integer value to
        /// -1.0
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of three elements: the x, y, and z coordinates of the new current
        /// normal.
        /// </param>
        public static void glNormal3sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glNormal3sv(v_);
        }
        
        public static void glNormal3x(IntPtr nx, IntPtr ny, IntPtr nz) {
            Pointers.glNormal3x(nx, ny, nz);
        }
        
        public static void glNormal3xOES(IntPtr nx, IntPtr ny, IntPtr nz) {
            Pointers.glNormal3xOES(nx, ny, nz);
        }
        
        public static void glNormal3xvOES(IntPtr* coords) {
            Pointers.glNormal3xvOES(coords);
        }
        
        public static void glNormal3xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glNormal3xvOES(coords_);
        }
        
        public static void glNormalFormatNV(int type, int stride) {
            Pointers.glNormalFormatNV(type, stride);
        }
        
        public static void glNormalP3ui(int type, uint coords) {
            Pointers.glNormalP3ui(type, coords);
        }
        
        public static void glNormalP3uiv(int type, uint* coords) {
            Pointers.glNormalP3uiv(type, coords);
        }
        
        public static void glNormalP3uiv(int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glNormalP3uiv(type, coords_);
        }
        
        /// <summary>
        /// define an array of normals
        /// <para>
        /// glNormalPointer specifies the location and data format of an array of normals to use when rendering.
        /// type specifies the data type of each normal coordinate, and stride specifies the byte stride from
        /// one normal to the next, allowing vertices and attributes to be packed into a single array or stored
        /// in separate arrays. (Single-array storage may be more efficient on some implementations; see
        /// glInterleavedArrays.)
        /// </para>
        /// </summary>
        /// <param name="type">
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_BYTE, GL_SHORT,
        /// GL_INT, GL_FLOAT, and GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive normals. If stride is 0, the normals are understood to
        /// be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first coordinate of the first normal in the array. The initial value is
        /// 0.
        /// </param>
        public static void glNormalPointer(int type, int stride, IntPtr pointer) {
            Pointers.glNormalPointer(type, stride, pointer);
        }
        
        public static void glNormalPointerEXT(int type, int stride, int count, IntPtr pointer) {
            Pointers.glNormalPointerEXT(type, stride, count, pointer);
        }
        
        public static void glNormalPointerListIBM(int type, int stride, IntPtr* pointer, int ptrstride) {
            Pointers.glNormalPointerListIBM(type, stride, pointer, ptrstride);
        }
        
        public static void glNormalPointerListIBM(int type, int stride, IntPtr[] pointer, int ptrstride) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glNormalPointerListIBM(type, stride, pointer_, ptrstride);
        }
        
        public static void glNormalPointervINTEL(int type, IntPtr* pointer) {
            Pointers.glNormalPointervINTEL(type, pointer);
        }
        
        public static void glNormalPointervINTEL(int type, IntPtr[] pointer) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glNormalPointervINTEL(type, pointer_);
        }
        
        public static void glNormalStream3bATI(int stream, sbyte nx, sbyte ny, sbyte nz) {
            Pointers.glNormalStream3bATI(stream, nx, ny, nz);
        }
        
        public static void glNormalStream3bvATI(int stream, sbyte* coords) {
            Pointers.glNormalStream3bvATI(stream, coords);
        }
        
        public static void glNormalStream3bvATI(int stream, sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glNormalStream3bvATI(stream, coords_);
        }
        
        public static void glNormalStream3dATI(int stream, double nx, double ny, double nz) {
            Pointers.glNormalStream3dATI(stream, nx, ny, nz);
        }
        
        public static void glNormalStream3dvATI(int stream, double* coords) {
            Pointers.glNormalStream3dvATI(stream, coords);
        }
        
        public static void glNormalStream3dvATI(int stream, double[] coords) {
            fixed(double* coords_ = &coords[0])
                Pointers.glNormalStream3dvATI(stream, coords_);
        }
        
        public static void glNormalStream3fATI(int stream, float nx, float ny, float nz) {
            Pointers.glNormalStream3fATI(stream, nx, ny, nz);
        }
        
        public static void glNormalStream3fvATI(int stream, float* coords) {
            Pointers.glNormalStream3fvATI(stream, coords);
        }
        
        public static void glNormalStream3fvATI(int stream, float[] coords) {
            fixed(float* coords_ = &coords[0])
                Pointers.glNormalStream3fvATI(stream, coords_);
        }
        
        public static void glNormalStream3iATI(int stream, int nx, int ny, int nz) {
            Pointers.glNormalStream3iATI(stream, nx, ny, nz);
        }
        
        public static void glNormalStream3ivATI(int stream, int* coords) {
            Pointers.glNormalStream3ivATI(stream, coords);
        }
        
        public static void glNormalStream3ivATI(int stream, int[] coords) {
            fixed(int* coords_ = &coords[0])
                Pointers.glNormalStream3ivATI(stream, coords_);
        }
        
        public static void glNormalStream3sATI(int stream, short nx, short ny, short nz) {
            Pointers.glNormalStream3sATI(stream, nx, ny, nz);
        }
        
        public static void glNormalStream3svATI(int stream, short* coords) {
            Pointers.glNormalStream3svATI(stream, coords);
        }
        
        public static void glNormalStream3svATI(int stream, short[] coords) {
            fixed(short* coords_ = &coords[0])
                Pointers.glNormalStream3svATI(stream, coords_);
        }
        
        /// <summary>
        /// label a named object identified within a namespace
        /// <para>
        /// glObjectLabel labels the object identified by name within the namespace given by identifier.
        /// identifier must be one of GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,
        /// GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER, GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,
        /// to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects,
        /// query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and
        /// frame buffers, respectively
        /// </para>
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object to label.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">
        /// The address of a string containing the label to assign to the object.
        /// </param>
        public static void glObjectLabel(int identifier, uint name, int length, string label) {
            Pointers.glObjectLabel(identifier, name, length, label);
        }
        
        /// <summary>
        /// label a named object identified within a namespace
        /// <para>
        /// glObjectLabel labels the object identified by name within the namespace given by identifier.
        /// identifier must be one of GL_BUFFER, GL_SHADER, GL_PROGRAM, GL_VERTEX_ARRAY, GL_QUERY,
        /// GL_PROGRAM_PIPELINE, GL_TRANSFORM_FEEDBACK, GL_SAMPLER, GL_TEXTURE, GL_RENDERBUFFER, GL_FRAMEBUFFER,
        /// to indicate the namespace containing the names of buffers, shaders, programs, vertex array objects,
        /// query objects, program pipelines, transform feedback objects, samplers, textures, renderbuffers and
        /// frame buffers, respectively
        /// </para>
        /// </summary>
        /// <param name="identifier">
        /// The namespace from which the name of the object is allocated.
        /// </param>
        /// <param name="name">
        /// The name of the object to label.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">
        /// The address of a string containing the label to assign to the object.
        /// </param>
        public static void glObjectLabelKHR(int identifier, uint name, int length, string label) {
            Pointers.glObjectLabelKHR(identifier, name, length, label);
        }
        
        /// <summary>
        /// label a a sync object identified by a pointer
        /// <para>
        /// glObjectPtrLabel labels the sync object identified by ptr
        /// </para>
        /// </summary>
        /// <param name="ptr">
        /// A pointer identifying a sync object.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">
        /// The address of a string containing the label to assign to the object.
        /// </param>
        public static void glObjectPtrLabel(IntPtr ptr, int length, string label) {
            Pointers.glObjectPtrLabel(ptr, length, label);
        }
        
        /// <summary>
        /// label a a sync object identified by a pointer
        /// <para>
        /// glObjectPtrLabel labels the sync object identified by ptr
        /// </para>
        /// </summary>
        /// <param name="ptr">
        /// A pointer identifying a sync object.
        /// </param>
        /// <param name="length">
        /// The length of the label to be used for the object.
        /// </param>
        /// <param name="label">
        /// The address of a string containing the label to assign to the object.
        /// </param>
        public static void glObjectPtrLabelKHR(IntPtr ptr, int length, string label) {
            Pointers.glObjectPtrLabelKHR(ptr, length, label);
        }
        
        public static int glObjectPurgeableAPPLE(int objectType, uint name, int option) {
            return Pointers.glObjectPurgeableAPPLE(objectType, name, option);
        }
        
        public static int glObjectUnpurgeableAPPLE(int objectType, uint name, int option) {
            return Pointers.glObjectUnpurgeableAPPLE(objectType, name, option);
        }
        
        /// <summary>
        /// multiply the current matrix with an orthographic matrix
        /// <para>
        /// glOrtho describes a transformation that produces a parallel projection. The current matrix (see
        /// glMatrixMode) is multiplied by this matrix and the result replaces the current matrix, as if
        /// glMultMatrix were called with the following matrix as its argument:
        /// </para>
        /// </summary>
        /// <param name="left">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="right">
        /// Specify the coordinates for the left and right vertical clipping planes.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="top">
        /// Specify the coordinates for the bottom and top horizontal clipping planes.
        /// </param>
        /// <param name="zNear">
        /// Specify the distances to the nearer and farther depth clipping planes. These values are negative if
        /// the plane is to be behind the viewer.
        /// </param>
        /// <param name="zFar">
        /// Specify the distances to the nearer and farther depth clipping planes. These values are negative if
        /// the plane is to be behind the viewer.
        /// </param>
        public static void glOrtho(double left, double right, double bottom, double top, double zNear, double zFar) {
            Pointers.glOrtho(left, right, bottom, top, zNear, zFar);
        }
        
        public static void glOrthof(float l, float r, float b, float t, float n, float f) {
            Pointers.glOrthof(l, r, b, t, n, f);
        }
        
        public static void glOrthofOES(float l, float r, float b, float t, float n, float f) {
            Pointers.glOrthofOES(l, r, b, t, n, f);
        }
        
        public static void glOrthox(IntPtr l, IntPtr r, IntPtr b, IntPtr t, IntPtr n, IntPtr f) {
            Pointers.glOrthox(l, r, b, t, n, f);
        }
        
        public static void glOrthoxOES(IntPtr l, IntPtr r, IntPtr b, IntPtr t, IntPtr n, IntPtr f) {
            Pointers.glOrthoxOES(l, r, b, t, n, f);
        }
        
        public static void glPNTrianglesfATI(int pname, float param) {
            Pointers.glPNTrianglesfATI(pname, param);
        }
        
        public static void glPNTrianglesiATI(int pname, int param) {
            Pointers.glPNTrianglesiATI(pname, param);
        }
        
        public static void glPassTexCoordATI(uint dst, uint coord, int swizzle) {
            Pointers.glPassTexCoordATI(dst, coord, swizzle);
        }
        
        /// <summary>
        /// place a marker in the feedback buffer
        /// <para>
        /// 
        /// </para>
        /// </summary>
        /// <param name="token">
        /// Specifies a marker value to be placed in the feedback buffer following a GL_PASS_THROUGH_TOKEN.
        /// </param>
        public static void glPassThrough(float token) {
            Pointers.glPassThrough(token);
        }
        
        public static void glPassThroughxOES(IntPtr token) {
            Pointers.glPassThroughxOES(token);
        }
        
        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>
        /// glPatchParameter specifies the parameters that will be used for patch primitives. pname specifies
        /// the parameter to modify and must be either GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL or
        /// GL_PATCH_DEFAULT_INNER_LEVEL. For glPatchParameteri, value specifies the new value for the parameter
        /// specified by pname. For glPatchParameterfv, values specifies the address of an array containing the
        /// new values for the parameter specified by pname
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES,
        /// GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an array containing the new values for the parameter given by pname.
        /// </param>
        public static void glPatchParameterfv(int pname, float* values) {
            Pointers.glPatchParameterfv(pname, values);
        }
        
        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>
        /// glPatchParameter specifies the parameters that will be used for patch primitives. pname specifies
        /// the parameter to modify and must be either GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL or
        /// GL_PATCH_DEFAULT_INNER_LEVEL. For glPatchParameteri, value specifies the new value for the parameter
        /// specified by pname. For glPatchParameterfv, values specifies the address of an array containing the
        /// new values for the parameter specified by pname
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES,
        /// GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted.
        /// </param>
        /// <param name="values">
        /// Specifies the address of an array containing the new values for the parameter given by pname.
        /// </param>
        public static void glPatchParameterfv(int pname, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glPatchParameterfv(pname, values_);
        }
        
        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>
        /// glPatchParameter specifies the parameters that will be used for patch primitives. pname specifies
        /// the parameter to modify and must be either GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL or
        /// GL_PATCH_DEFAULT_INNER_LEVEL. For glPatchParameteri, value specifies the new value for the parameter
        /// specified by pname. For glPatchParameterfv, values specifies the address of an array containing the
        /// new values for the parameter specified by pname
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES,
        /// GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted.
        /// </param>
        /// <param name="value">
        /// Specifies the new value for the parameter given by pname.
        /// </param>
        public static void glPatchParameteri(int pname, int value) {
            Pointers.glPatchParameteri(pname, value);
        }
        
        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>
        /// glPatchParameter specifies the parameters that will be used for patch primitives. pname specifies
        /// the parameter to modify and must be either GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL or
        /// GL_PATCH_DEFAULT_INNER_LEVEL. For glPatchParameteri, value specifies the new value for the parameter
        /// specified by pname. For glPatchParameterfv, values specifies the address of an array containing the
        /// new values for the parameter specified by pname
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES,
        /// GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted.
        /// </param>
        /// <param name="value">
        /// Specifies the new value for the parameter given by pname.
        /// </param>
        public static void glPatchParameteriEXT(int pname, int value) {
            Pointers.glPatchParameteriEXT(pname, value);
        }
        
        /// <summary>
        /// specifies the parameters for patch primitives
        /// <para>
        /// glPatchParameter specifies the parameters that will be used for patch primitives. pname specifies
        /// the parameter to modify and must be either GL_PATCH_VERTICES, GL_PATCH_DEFAULT_OUTER_LEVEL or
        /// GL_PATCH_DEFAULT_INNER_LEVEL. For glPatchParameteri, value specifies the new value for the parameter
        /// specified by pname. For glPatchParameterfv, values specifies the address of an array containing the
        /// new values for the parameter specified by pname
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the name of the parameter to set. The symbolc constants GL_PATCH_VERTICES,
        /// GL_PATCH_DEFAULT_OUTER_LEVEL, and GL_PATCH_DEFAULT_INNER_LEVEL are accepted.
        /// </param>
        /// <param name="value">
        /// Specifies the new value for the parameter given by pname.
        /// </param>
        public static void glPatchParameteriOES(int pname, int value) {
            Pointers.glPatchParameteriOES(pname, value);
        }
        
        public static void glPathColorGenNV(int color, int genMode, int colorFormat, float* coeffs) {
            Pointers.glPathColorGenNV(color, genMode, colorFormat, coeffs);
        }
        
        public static void glPathColorGenNV(int color, int genMode, int colorFormat, float[] coeffs) {
            fixed(float* coeffs_ = &coeffs[0])
                Pointers.glPathColorGenNV(color, genMode, colorFormat, coeffs_);
        }
        
        public static void glPathCommandsNV(uint path, int numCommands, byte* commands, int numCoords, int coordType, IntPtr coords) {
            Pointers.glPathCommandsNV(path, numCommands, commands, numCoords, coordType, coords);
        }
        
        public static void glPathCommandsNV(uint path, int numCommands, byte[] commands, int numCoords, int coordType, IntPtr coords) {
            fixed(byte* commands_ = &commands[0])
                Pointers.glPathCommandsNV(path, numCommands, commands_, numCoords, coordType, coords);
        }
        
        public static void glPathCoordsNV(uint path, int numCoords, int coordType, IntPtr coords) {
            Pointers.glPathCoordsNV(path, numCoords, coordType, coords);
        }
        
        public static void glPathCoverDepthFuncNV(int func) {
            Pointers.glPathCoverDepthFuncNV(func);
        }
        
        public static void glPathDashArrayNV(uint path, int dashCount, float* dashArray) {
            Pointers.glPathDashArrayNV(path, dashCount, dashArray);
        }
        
        public static void glPathDashArrayNV(uint path, int dashCount, float[] dashArray) {
            fixed(float* dashArray_ = &dashArray[0])
                Pointers.glPathDashArrayNV(path, dashCount, dashArray_);
        }
        
        public static void glPathFogGenNV(int genMode) {
            Pointers.glPathFogGenNV(genMode);
        }
        
        public static int glPathGlyphIndexArrayNV(uint firstPathName, int fontTarget, IntPtr fontName, uint fontStyle, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) {
            return Pointers.glPathGlyphIndexArrayNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
        }
        
        public static int glPathGlyphIndexRangeNV(int fontTarget, IntPtr fontName, uint fontStyle, uint pathParameterTemplate, float emScale, uint[] baseAndCount) {
            return Pointers.glPathGlyphIndexRangeNV(fontTarget, fontName, fontStyle, pathParameterTemplate, emScale, baseAndCount);
        }
        
        public static void glPathGlyphRangeNV(uint firstPathName, int fontTarget, IntPtr fontName, uint fontStyle, uint firstGlyph, int numGlyphs, int handleMissingGlyphs, uint pathParameterTemplate, float emScale) {
            Pointers.glPathGlyphRangeNV(firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale);
        }
        
        public static void glPathGlyphsNV(uint firstPathName, int fontTarget, IntPtr fontName, uint fontStyle, int numGlyphs, int type, IntPtr charcodes, int handleMissingGlyphs, uint pathParameterTemplate, float emScale) {
            Pointers.glPathGlyphsNV(firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale);
        }
        
        public static int glPathMemoryGlyphIndexArrayNV(uint firstPathName, int fontTarget, uint fontSize, IntPtr fontData, int faceIndex, uint firstGlyphIndex, int numGlyphs, uint pathParameterTemplate, float emScale) {
            return Pointers.glPathMemoryGlyphIndexArrayNV(firstPathName, fontTarget, fontSize, fontData, faceIndex, firstGlyphIndex, numGlyphs, pathParameterTemplate, emScale);
        }
        
        public static void glPathParameterfNV(uint path, int pname, float value) {
            Pointers.glPathParameterfNV(path, pname, value);
        }
        
        public static void glPathParameterfvNV(uint path, int pname, float* value) {
            Pointers.glPathParameterfvNV(path, pname, value);
        }
        
        public static void glPathParameterfvNV(uint path, int pname, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glPathParameterfvNV(path, pname, value_);
        }
        
        public static void glPathParameteriNV(uint path, int pname, int value) {
            Pointers.glPathParameteriNV(path, pname, value);
        }
        
        public static void glPathParameterivNV(uint path, int pname, int* value) {
            Pointers.glPathParameterivNV(path, pname, value);
        }
        
        public static void glPathParameterivNV(uint path, int pname, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glPathParameterivNV(path, pname, value_);
        }
        
        public static void glPathStencilDepthOffsetNV(float factor, float units) {
            Pointers.glPathStencilDepthOffsetNV(factor, units);
        }
        
        public static void glPathStencilFuncNV(int func, int _ref, uint mask) {
            Pointers.glPathStencilFuncNV(func, _ref, mask);
        }
        
        public static void glPathStringNV(uint path, int format, int length, IntPtr pathString) {
            Pointers.glPathStringNV(path, format, length, pathString);
        }
        
        public static void glPathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte* commands, int numCoords, int coordType, IntPtr coords) {
            Pointers.glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords);
        }
        
        public static void glPathSubCommandsNV(uint path, int commandStart, int commandsToDelete, int numCommands, byte[] commands, int numCoords, int coordType, IntPtr coords) {
            fixed(byte* commands_ = &commands[0])
                Pointers.glPathSubCommandsNV(path, commandStart, commandsToDelete, numCommands, commands_, numCoords, coordType, coords);
        }
        
        public static void glPathSubCoordsNV(uint path, int coordStart, int numCoords, int coordType, IntPtr coords) {
            Pointers.glPathSubCoordsNV(path, coordStart, numCoords, coordType, coords);
        }
        
        public static void glPathTexGenNV(int texCoordSet, int genMode, int components, float* coeffs) {
            Pointers.glPathTexGenNV(texCoordSet, genMode, components, coeffs);
        }
        
        public static void glPathTexGenNV(int texCoordSet, int genMode, int components, float[] coeffs) {
            fixed(float* coeffs_ = &coeffs[0])
                Pointers.glPathTexGenNV(texCoordSet, genMode, components, coeffs_);
        }
        
        /// <summary>
        /// pause transform feedback operations
        /// <para>
        /// glPauseTransformFeedback pauses transform feedback operations on the currently active transform
        /// feedback object. When transform feedback operations are paused, transform feedback is still
        /// considered active and changing most transform feedback state related to the object results in an
        /// error. However, a new transform feedback object may be bound while transform feedback is paused
        /// </para>
        /// </summary>
        public static void glPauseTransformFeedback() {
            Pointers.glPauseTransformFeedback();
        }
        
        /// <summary>
        /// pause transform feedback operations
        /// <para>
        /// glPauseTransformFeedback pauses transform feedback operations on the currently active transform
        /// feedback object. When transform feedback operations are paused, transform feedback is still
        /// considered active and changing most transform feedback state related to the object results in an
        /// error. However, a new transform feedback object may be bound while transform feedback is paused
        /// </para>
        /// </summary>
        public static void glPauseTransformFeedbackNV() {
            Pointers.glPauseTransformFeedbackNV();
        }
        
        public static void glPixelDataRangeNV(int target, int length, IntPtr pointer) {
            Pointers.glPixelDataRangeNV(target, length, pointer);
        }
        
        /// <summary>
        /// set up pixel transfer maps
        /// <para>
        /// glPixelMap sets up translation tables, or maps, used by glCopyPixels, glCopyTexImage1D,
        /// glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D, glDrawPixels,
        /// glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, and
        /// glTexSubImage3D. Additionally, if the ARB_imaging subset is supported, the routines glColorTable,
        /// glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D, glHistogram, glMinmax, and
        /// glSeparableFilter2D. Use of these maps is described completely in the glPixelTransfer reference
        /// page, and partly in the reference pages for the pixel and texture image commands. Only the
        /// specification of the maps is described in this reference page
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of mapsize values.
        /// </param>
        public static void glPixelMapfv(int map, int mapsize, float* values) {
            Pointers.glPixelMapfv(map, mapsize, values);
        }
        
        /// <summary>
        /// set up pixel transfer maps
        /// <para>
        /// glPixelMap sets up translation tables, or maps, used by glCopyPixels, glCopyTexImage1D,
        /// glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D, glDrawPixels,
        /// glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, and
        /// glTexSubImage3D. Additionally, if the ARB_imaging subset is supported, the routines glColorTable,
        /// glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D, glHistogram, glMinmax, and
        /// glSeparableFilter2D. Use of these maps is described completely in the glPixelTransfer reference
        /// page, and partly in the reference pages for the pixel and texture image commands. Only the
        /// specification of the maps is described in this reference page
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of mapsize values.
        /// </param>
        public static void glPixelMapfv(int map, int mapsize, float[] values) {
            fixed(float* values_ = &values[0])
                Pointers.glPixelMapfv(map, mapsize, values_);
        }
        
        /// <summary>
        /// set up pixel transfer maps
        /// <para>
        /// glPixelMap sets up translation tables, or maps, used by glCopyPixels, glCopyTexImage1D,
        /// glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D, glDrawPixels,
        /// glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, and
        /// glTexSubImage3D. Additionally, if the ARB_imaging subset is supported, the routines glColorTable,
        /// glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D, glHistogram, glMinmax, and
        /// glSeparableFilter2D. Use of these maps is described completely in the glPixelTransfer reference
        /// page, and partly in the reference pages for the pixel and texture image commands. Only the
        /// specification of the maps is described in this reference page
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of mapsize values.
        /// </param>
        public static void glPixelMapuiv(int map, int mapsize, uint* values) {
            Pointers.glPixelMapuiv(map, mapsize, values);
        }
        
        /// <summary>
        /// set up pixel transfer maps
        /// <para>
        /// glPixelMap sets up translation tables, or maps, used by glCopyPixels, glCopyTexImage1D,
        /// glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D, glDrawPixels,
        /// glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, and
        /// glTexSubImage3D. Additionally, if the ARB_imaging subset is supported, the routines glColorTable,
        /// glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D, glHistogram, glMinmax, and
        /// glSeparableFilter2D. Use of these maps is described completely in the glPixelTransfer reference
        /// page, and partly in the reference pages for the pixel and texture image commands. Only the
        /// specification of the maps is described in this reference page
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of mapsize values.
        /// </param>
        public static void glPixelMapuiv(int map, int mapsize, uint[] values) {
            fixed(uint* values_ = &values[0])
                Pointers.glPixelMapuiv(map, mapsize, values_);
        }
        
        /// <summary>
        /// set up pixel transfer maps
        /// <para>
        /// glPixelMap sets up translation tables, or maps, used by glCopyPixels, glCopyTexImage1D,
        /// glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D, glDrawPixels,
        /// glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, and
        /// glTexSubImage3D. Additionally, if the ARB_imaging subset is supported, the routines glColorTable,
        /// glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D, glHistogram, glMinmax, and
        /// glSeparableFilter2D. Use of these maps is described completely in the glPixelTransfer reference
        /// page, and partly in the reference pages for the pixel and texture image commands. Only the
        /// specification of the maps is described in this reference page
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of mapsize values.
        /// </param>
        public static void glPixelMapusv(int map, int mapsize, ushort* values) {
            Pointers.glPixelMapusv(map, mapsize, values);
        }
        
        /// <summary>
        /// set up pixel transfer maps
        /// <para>
        /// glPixelMap sets up translation tables, or maps, used by glCopyPixels, glCopyTexImage1D,
        /// glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D, glDrawPixels,
        /// glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D, glTexSubImage2D, and
        /// glTexSubImage3D. Additionally, if the ARB_imaging subset is supported, the routines glColorTable,
        /// glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D, glHistogram, glMinmax, and
        /// glSeparableFilter2D. Use of these maps is described completely in the glPixelTransfer reference
        /// page, and partly in the reference pages for the pixel and texture image commands. Only the
        /// specification of the maps is described in this reference page
        /// </para>
        /// </summary>
        /// <param name="map">
        /// Specifies a symbolic map name. Must be one of the following: GL_PIXEL_MAP_I_TO_I,
        /// GL_PIXEL_MAP_S_TO_S, GL_PIXEL_MAP_I_TO_R, GL_PIXEL_MAP_I_TO_G, GL_PIXEL_MAP_I_TO_B,
        /// GL_PIXEL_MAP_I_TO_A, GL_PIXEL_MAP_R_TO_R, GL_PIXEL_MAP_G_TO_G, GL_PIXEL_MAP_B_TO_B, or
        /// GL_PIXEL_MAP_A_TO_A.
        /// </param>
        /// <param name="mapsize">
        /// Specifies the size of the map being defined.
        /// </param>
        /// <param name="values">
        /// Specifies an array of mapsize values.
        /// </param>
        public static void glPixelMapusv(int map, int mapsize, ushort[] values) {
            fixed(ushort* values_ = &values[0])
                Pointers.glPixelMapusv(map, mapsize, values_);
        }
        
        public static void glPixelMapx(int map, int size, IntPtr* values) {
            Pointers.glPixelMapx(map, size, values);
        }
        
        public static void glPixelMapx(int map, int size, IntPtr[] values) {
            fixed(IntPtr* values_ = &values[0])
                Pointers.glPixelMapx(map, size, values_);
        }
        
        /// <summary>
        /// set pixel storage modes
        /// <para>
        /// glPixelStore sets pixel storage modes that affect the operation of subsequent glReadPixels as well
        /// as the unpacking of texture patterns (see glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D,
        /// glTexSubImage2D, glTexSubImage3D), glCompressedTexImage1D, glCompressedTexImage2D,
        /// glCompressedTexImage3D, glCompressedTexSubImage1D, glCompressedTexSubImage2D or
        /// glCompressedTexSubImage1D
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data
        /// into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT,
        /// GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect
        /// the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST,
        /// GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS,
        /// GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname is set to.
        /// </param>
        public static void glPixelStoref(int pname, float param) {
            Pointers.glPixelStoref(pname, param);
        }
        
        /// <summary>
        /// set pixel storage modes
        /// <para>
        /// glPixelStore sets pixel storage modes that affect the operation of subsequent glReadPixels as well
        /// as the unpacking of texture patterns (see glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D,
        /// glTexSubImage2D, glTexSubImage3D), glCompressedTexImage1D, glCompressedTexImage2D,
        /// glCompressedTexImage3D, glCompressedTexSubImage1D, glCompressedTexSubImage2D or
        /// glCompressedTexSubImage1D
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the symbolic name of the parameter to be set. Six values affect the packing of pixel data
        /// into memory: GL_PACK_SWAP_BYTES, GL_PACK_LSB_FIRST, GL_PACK_ROW_LENGTH, GL_PACK_IMAGE_HEIGHT,
        /// GL_PACK_SKIP_PIXELS, GL_PACK_SKIP_ROWS, GL_PACK_SKIP_IMAGES, and GL_PACK_ALIGNMENT. Six more affect
        /// the unpacking of pixel data from memory: GL_UNPACK_SWAP_BYTES, GL_UNPACK_LSB_FIRST,
        /// GL_UNPACK_ROW_LENGTH, GL_UNPACK_IMAGE_HEIGHT, GL_UNPACK_SKIP_PIXELS, GL_UNPACK_SKIP_ROWS,
        /// GL_UNPACK_SKIP_IMAGES, and GL_UNPACK_ALIGNMENT.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname is set to.
        /// </param>
        public static void glPixelStorei(int pname, int param) {
            Pointers.glPixelStorei(pname, param);
        }
        
        public static void glPixelStorex(int pname, IntPtr param) {
            Pointers.glPixelStorex(pname, param);
        }
        
        public static void glPixelTexGenParameterfSGIS(int pname, float param) {
            Pointers.glPixelTexGenParameterfSGIS(pname, param);
        }
        
        public static void glPixelTexGenParameterfvSGIS(int pname, float* _params) {
            Pointers.glPixelTexGenParameterfvSGIS(pname, _params);
        }
        
        public static void glPixelTexGenParameterfvSGIS(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glPixelTexGenParameterfvSGIS(pname, _params_);
        }
        
        public static void glPixelTexGenParameteriSGIS(int pname, int param) {
            Pointers.glPixelTexGenParameteriSGIS(pname, param);
        }
        
        public static void glPixelTexGenParameterivSGIS(int pname, int* _params) {
            Pointers.glPixelTexGenParameterivSGIS(pname, _params);
        }
        
        public static void glPixelTexGenParameterivSGIS(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glPixelTexGenParameterivSGIS(pname, _params_);
        }
        
        public static void glPixelTexGenSGIX(int mode) {
            Pointers.glPixelTexGenSGIX(mode);
        }
        
        /// <summary>
        /// set pixel transfer modes
        /// <para>
        /// glPixelTransfer sets pixel transfer modes that affect the operation of subsequent glCopyPixels,
        /// glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D,
        /// glDrawPixels, glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D,
        /// glTexSubImage2D, and glTexSubImage3D commands. Additionally, if the ARB_imaging subset is supported,
        /// the routines glColorTable, glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D,
        /// glHistogram, glMinmax, and glSeparableFilter2D are also affected. The algorithms that are specified
        /// by pixel transfer modes operate on pixels after they are read from the frame buffer (glCopyPixels
        /// glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D,
        /// and glReadPixels), or unpacked from client memory (glDrawPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, and glTexSubImage3D). Pixel transfer operations
        /// happen in the same order, and in the same manner, regardless of the command that resulted in the
        /// pixel operation. Pixel storage modes (see glPixelStore) control the unpacking of pixels being read
        /// from client memory and the packing of pixels being written back into client memory
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following:
        /// GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS,
        /// GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS,
        /// GL_DEPTH_SCALE, or GL_DEPTH_BIAS.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname is set to.
        /// </param>
        public static void glPixelTransferf(int pname, float param) {
            Pointers.glPixelTransferf(pname, param);
        }
        
        /// <summary>
        /// set pixel transfer modes
        /// <para>
        /// glPixelTransfer sets pixel transfer modes that affect the operation of subsequent glCopyPixels,
        /// glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D,
        /// glDrawPixels, glReadPixels, glTexImage1D, glTexImage2D, glTexImage3D, glTexSubImage1D,
        /// glTexSubImage2D, and glTexSubImage3D commands. Additionally, if the ARB_imaging subset is supported,
        /// the routines glColorTable, glColorSubTable, glConvolutionFilter1D, glConvolutionFilter2D,
        /// glHistogram, glMinmax, and glSeparableFilter2D are also affected. The algorithms that are specified
        /// by pixel transfer modes operate on pixels after they are read from the frame buffer (glCopyPixels
        /// glCopyTexImage1D, glCopyTexImage2D, glCopyTexSubImage1D, glCopyTexSubImage2D, glCopyTexSubImage3D,
        /// and glReadPixels), or unpacked from client memory (glDrawPixels, glTexImage1D, glTexImage2D,
        /// glTexImage3D, glTexSubImage1D, glTexSubImage2D, and glTexSubImage3D). Pixel transfer operations
        /// happen in the same order, and in the same manner, regardless of the command that resulted in the
        /// pixel operation. Pixel storage modes (see glPixelStore) control the unpacking of pixels being read
        /// from client memory and the packing of pixels being written back into client memory
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies the symbolic name of the pixel transfer parameter to be set. Must be one of the following:
        /// GL_MAP_COLOR, GL_MAP_STENCIL, GL_INDEX_SHIFT, GL_INDEX_OFFSET, GL_RED_SCALE, GL_RED_BIAS,
        /// GL_GREEN_SCALE, GL_GREEN_BIAS, GL_BLUE_SCALE, GL_BLUE_BIAS, GL_ALPHA_SCALE, GL_ALPHA_BIAS,
        /// GL_DEPTH_SCALE, or GL_DEPTH_BIAS.
        /// </param>
        /// <param name="param">
        /// Specifies the value that pname is set to.
        /// </param>
        public static void glPixelTransferi(int pname, int param) {
            Pointers.glPixelTransferi(pname, param);
        }
        
        public static void glPixelTransferxOES(int pname, IntPtr param) {
            Pointers.glPixelTransferxOES(pname, param);
        }
        
        public static void glPixelTransformParameterfEXT(int target, int pname, float param) {
            Pointers.glPixelTransformParameterfEXT(target, pname, param);
        }
        
        public static void glPixelTransformParameterfvEXT(int target, int pname, float* _params) {
            Pointers.glPixelTransformParameterfvEXT(target, pname, _params);
        }
        
        public static void glPixelTransformParameterfvEXT(int target, int pname, out float _params) {
            fixed(float* _params_ = &_params)
                Pointers.glPixelTransformParameterfvEXT(target, pname, _params_);
        }
        
        public static void glPixelTransformParameteriEXT(int target, int pname, int param) {
            Pointers.glPixelTransformParameteriEXT(target, pname, param);
        }
        
        public static void glPixelTransformParameterivEXT(int target, int pname, int* _params) {
            Pointers.glPixelTransformParameterivEXT(target, pname, _params);
        }
        
        public static void glPixelTransformParameterivEXT(int target, int pname, out int _params) {
            fixed(int* _params_ = &_params)
                Pointers.glPixelTransformParameterivEXT(target, pname, _params_);
        }
        
        /// <summary>
        /// specify the pixel zoom factors
        /// <para>
        /// glPixelZoom specifies values for the x and y zoom factors. During the execution of glDrawPixels or
        /// glCopyPixels, if ( xr , yr ) is the current raster position, and a given element is in the mth row
        /// and nth column of the pixel rectangle, then pixels whose centers are in the rectangle with corners
        /// at
        /// </para>
        /// </summary>
        /// <param name="xfactor">
        /// Specify the x and y zoom factors for pixel write operations.
        /// </param>
        /// <param name="yfactor">
        /// Specify the x and y zoom factors for pixel write operations.
        /// </param>
        public static void glPixelZoom(float xfactor, float yfactor) {
            Pointers.glPixelZoom(xfactor, yfactor);
        }
        
        public static void glPixelZoomxOES(IntPtr xfactor, IntPtr yfactor) {
            Pointers.glPixelZoomxOES(xfactor, yfactor);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, float* tangentY) {
            return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, float* tangentX, out float tangentY) {
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX, tangentY_);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, out float tangentX, float* tangentY) {
            fixed(float* tangentX_ = &tangentX)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX_, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, float* y, out float tangentX, out float tangentY) {
            fixed(float* tangentX_ = &tangentX)
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y, tangentX_, tangentY_);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, out float y, float* tangentX, float* tangentY) {
            fixed(float* y_ = &y)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y_, tangentX, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, out float y, float* tangentX, out float tangentY) {
            fixed(float* y_ = &y)
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y_, tangentX, tangentY_);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, out float y, out float tangentX, float* tangentY) {
            fixed(float* y_ = &y)
            fixed(float* tangentX_ = &tangentX)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y_, tangentX_, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, float* x, out float y, out float tangentX, out float tangentY) {
            fixed(float* y_ = &y)
            fixed(float* tangentX_ = &tangentX)
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x, y_, tangentX_, tangentY_);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, float* y, float* tangentX, float* tangentY) {
            fixed(float* x_ = &x)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y, tangentX, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, float* y, float* tangentX, out float tangentY) {
            fixed(float* x_ = &x)
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y, tangentX, tangentY_);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, float* y, out float tangentX, float* tangentY) {
            fixed(float* x_ = &x)
            fixed(float* tangentX_ = &tangentX)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y, tangentX_, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, float* y, out float tangentX, out float tangentY) {
            fixed(float* x_ = &x)
            fixed(float* tangentX_ = &tangentX)
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y, tangentX_, tangentY_);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, out float y, float* tangentX, float* tangentY) {
            fixed(float* x_ = &x)
            fixed(float* y_ = &y)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y_, tangentX, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, out float y, float* tangentX, out float tangentY) {
            fixed(float* x_ = &x)
            fixed(float* y_ = &y)
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y_, tangentX, tangentY_);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, out float y, out float tangentX, float* tangentY) {
            fixed(float* x_ = &x)
            fixed(float* y_ = &y)
            fixed(float* tangentX_ = &tangentX)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y_, tangentX_, tangentY);
        }
        
        public static bool glPointAlongPathNV(uint path, int startSegment, int numSegments, float distance, out float x, out float y, out float tangentX, out float tangentY) {
            fixed(float* x_ = &x)
            fixed(float* y_ = &y)
            fixed(float* tangentX_ = &tangentX)
            fixed(float* tangentY_ = &tangentY)
                return Pointers.glPointAlongPathNV(path, startSegment, numSegments, distance, x_, y_, tangentX_, tangentY_);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="param">
        /// For glPointParameterf and glPointParameteri, specifies the value that pname will be set to.
        /// </param>
        public static void glPointParameterf(int pname, float param) {
            Pointers.glPointParameterf(pname, param);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="param">
        /// For glPointParameterf and glPointParameteri, specifies the value that pname will be set to.
        /// </param>
        public static void glPointParameterfARB(int pname, float param) {
            Pointers.glPointParameterfARB(pname, param);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="param">
        /// For glPointParameterf and glPointParameteri, specifies the value that pname will be set to.
        /// </param>
        public static void glPointParameterfEXT(int pname, float param) {
            Pointers.glPointParameterfEXT(pname, param);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="param">
        /// For glPointParameterf and glPointParameteri, specifies the value that pname will be set to.
        /// </param>
        public static void glPointParameterfSGIS(int pname, float param) {
            Pointers.glPointParameterfSGIS(pname, param);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfv(int pname, float* _params) {
            Pointers.glPointParameterfv(pname, _params);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfv(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glPointParameterfv(pname, _params_);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfvARB(int pname, float* _params) {
            Pointers.glPointParameterfvARB(pname, _params);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfvARB(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glPointParameterfvARB(pname, _params_);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfvEXT(int pname, float* _params) {
            Pointers.glPointParameterfvEXT(pname, _params);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfvEXT(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glPointParameterfvEXT(pname, _params_);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfvSGIS(int pname, float* _params) {
            Pointers.glPointParameterfvSGIS(pname, _params);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterfvSGIS(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glPointParameterfvSGIS(pname, _params_);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="param">
        /// For glPointParameterf and glPointParameteri, specifies the value that pname will be set to.
        /// </param>
        public static void glPointParameteri(int pname, int param) {
            Pointers.glPointParameteri(pname, param);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="param">
        /// For glPointParameterf and glPointParameteri, specifies the value that pname will be set to.
        /// </param>
        public static void glPointParameteriNV(int pname, int param) {
            Pointers.glPointParameteriNV(pname, param);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameteriv(int pname, int* _params) {
            Pointers.glPointParameteriv(pname, _params);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameteriv(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glPointParameteriv(pname, _params_);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterivNV(int pname, int* _params) {
            Pointers.glPointParameterivNV(pname, _params);
        }
        
        /// <summary>
        /// specify point parameters
        /// <para>
        /// The following values are accepted for pname:
        /// </para>
        /// </summary>
        /// <param name="pname">
        /// Specifies a single-valued point parameter. GL_POINT_FADE_THRESHOLD_SIZE, and
        /// GL_POINT_SPRITE_COORD_ORIGIN are accepted.
        /// </param>
        /// <param name="_params">
        /// For glPointParameterfv and glPointParameteriv, specifies a pointer to an array where the value or
        /// values to be assigned to pname are stored.
        /// </param>
        public static void glPointParameterivNV(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glPointParameterivNV(pname, _params_);
        }
        
        public static void glPointParameterx(int pname, IntPtr param) {
            Pointers.glPointParameterx(pname, param);
        }
        
        public static void glPointParameterxOES(int pname, IntPtr param) {
            Pointers.glPointParameterxOES(pname, param);
        }
        
        public static void glPointParameterxv(int pname, IntPtr* _params) {
            Pointers.glPointParameterxv(pname, _params);
        }
        
        public static void glPointParameterxv(int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glPointParameterxv(pname, _params_);
        }
        
        public static void glPointParameterxvOES(int pname, IntPtr* _params) {
            Pointers.glPointParameterxvOES(pname, _params);
        }
        
        public static void glPointParameterxvOES(int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glPointParameterxvOES(pname, _params_);
        }
        
        /// <summary>
        /// specify the diameter of rasterized points
        /// <para>
        /// glPointSize specifies the rasterized diameter of points. If point size mode is disabled (see
        /// glEnable with parameter GL_PROGRAM_POINT_SIZE), this value will be used to rasterize points.
        /// Otherwise, the value written to the shading language built-in variable gl_PointSize will be used
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the diameter of rasterized points. The initial value is 1.
        /// </param>
        public static void glPointSize(float size) {
            Pointers.glPointSize(size);
        }
        
        public static void glPointSizePointerOES(int type, int stride, IntPtr pointer) {
            Pointers.glPointSizePointerOES(type, stride, pointer);
        }
        
        public static void glPointSizex(IntPtr size) {
            Pointers.glPointSizex(size);
        }
        
        public static void glPointSizexOES(IntPtr size) {
            Pointers.glPointSizexOES(size);
        }
        
        public static int glPollAsyncSGIX(uint* markerp) {
            return Pointers.glPollAsyncSGIX(markerp);
        }
        
        public static int glPollAsyncSGIX(out uint markerp) {
            fixed(uint* markerp_ = &markerp)
                return Pointers.glPollAsyncSGIX(markerp_);
        }
        
        public static int glPollInstrumentsSGIX(int* marker_p) {
            return Pointers.glPollInstrumentsSGIX(marker_p);
        }
        
        public static int glPollInstrumentsSGIX(out int marker_p) {
            fixed(int* marker_p_ = &marker_p)
                return Pointers.glPollInstrumentsSGIX(marker_p_);
        }
        
        /// <summary>
        /// select a polygon rasterization mode
        /// <para>
        /// glPolygonMode controls the interpretation of polygons for rasterization. face describes which
        /// polygons mode applies to: both front and back-facing polygons (GL_FRONT_AND_BACK). The polygon mode
        /// affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and
        /// the polygon is clipped and possibly culled before these modes are applied
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing
        /// polygons.
        /// </param>
        /// <param name="mode">
        /// Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The
        /// initial value is GL_FILL for both front- and back-facing polygons.
        /// </param>
        public static void glPolygonMode(int face, int mode) {
            Pointers.glPolygonMode(face, mode);
        }
        
        /// <summary>
        /// select a polygon rasterization mode
        /// <para>
        /// glPolygonMode controls the interpretation of polygons for rasterization. face describes which
        /// polygons mode applies to: both front and back-facing polygons (GL_FRONT_AND_BACK). The polygon mode
        /// affects only the final rasterization of polygons. In particular, a polygon's vertices are lit and
        /// the polygon is clipped and possibly culled before these modes are applied
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies the polygons that mode applies to. Must be GL_FRONT_AND_BACK for front- and back-facing
        /// polygons.
        /// </param>
        /// <param name="mode">
        /// Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. The
        /// initial value is GL_FILL for both front- and back-facing polygons.
        /// </param>
        public static void glPolygonModeNV(int face, int mode) {
            Pointers.glPolygonModeNV(face, mode);
        }
        
        /// <summary>
        /// set the scale and units used to calculate depth values
        /// <para>
        /// When GL_POLYGON_OFFSET_FILL, GL_POLYGON_OFFSET_LINE, or GL_POLYGON_OFFSET_POINT is enabled, each
        /// fragment's depth value will be offset after it is interpolated from the depth values of the
        /// appropriate vertices. The value of the offset is factor &times; DZ + r &times; units , where DZ is a
        /// measurement of the change in depth relative to the screen area of the polygon, and r is the smallest
        /// value that is guaranteed to produce a resolvable offset for a given implementation. The offset is
        /// added before the depth test is performed and before the value is written into the depth buffer
        /// </para>
        /// </summary>
        /// <param name="factor">
        /// Specifies a scale factor that is used to create a variable depth offset for each polygon. The
        /// initial value is 0.
        /// </param>
        /// <param name="units">
        /// Is multiplied by an implementation-specific value to create a constant depth offset. The initial
        /// value is 0.
        /// </param>
        public static void glPolygonOffset(float factor, float units) {
            Pointers.glPolygonOffset(factor, units);
        }
        
        public static void glPolygonOffsetClamp(float factor, float units, float clamp) {
            Pointers.glPolygonOffsetClamp(factor, units, clamp);
        }
        
        public static void glPolygonOffsetClampEXT(float factor, float units, float clamp) {
            Pointers.glPolygonOffsetClampEXT(factor, units, clamp);
        }
        
        public static void glPolygonOffsetEXT(float factor, float bias) {
            Pointers.glPolygonOffsetEXT(factor, bias);
        }
        
        public static void glPolygonOffsetx(IntPtr factor, IntPtr units) {
            Pointers.glPolygonOffsetx(factor, units);
        }
        
        public static void glPolygonOffsetxOES(IntPtr factor, IntPtr units) {
            Pointers.glPolygonOffsetxOES(factor, units);
        }
        
        /// <summary>
        /// set the polygon stippling pattern
        /// <para>
        /// Polygon stippling, like line stippling (see glLineStipple), masks out certain fragments produced by
        /// rasterization, creating a pattern. Stippling is independent of polygon antialiasing
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a pointer to a 32 &times; 32 stipple pattern that will be unpacked from memory in the same
        /// way that glDrawPixels unpacks pixels.
        /// </param>
        public static void glPolygonStipple(byte* mask) {
            Pointers.glPolygonStipple(mask);
        }
        
        /// <summary>
        /// set the polygon stippling pattern
        /// <para>
        /// Polygon stippling, like line stippling (see glLineStipple), masks out certain fragments produced by
        /// rasterization, creating a pattern. Stippling is independent of polygon antialiasing
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a pointer to a 32 &times; 32 stipple pattern that will be unpacked from memory in the same
        /// way that glDrawPixels unpacks pixels.
        /// </param>
        public static void glPolygonStipple(byte[] mask) {
            fixed(byte* mask_ = &mask[0])
                Pointers.glPolygonStipple(mask_);
        }
        
        /// <summary>
        /// push and pop the server attribute stack
        /// <para>
        /// glPushAttrib takes one argument, a mask that indicates which groups of state variables to save on
        /// the attribute stack. Symbolic constants are used to set bits in the mask. mask is typically
        /// constructed by specifying the bitwise-or of several of these constants together. The special mask
        /// GL_ALL_ATTRIB_BITS can be used to save all stackable states
        /// </para>
        /// </summary>
        public static void glPopAttrib() {
            Pointers.glPopAttrib();
        }
        
        /// <summary>
        /// push and pop the client attribute stack
        /// <para>
        /// glPushClientAttrib takes one argument, a mask that indicates which groups of client-state variables
        /// to save on the client attribute stack. Symbolic constants are used to set bits in the mask. mask is
        /// typically constructed by specifying the bitwise-or of several 	 of these constants together. The
        /// special mask GL_CLIENT_ALL_ATTRIB_BITS can be used to save all stackable client state
        /// </para>
        /// </summary>
        public static void glPopClientAttrib() {
            Pointers.glPopClientAttrib();
        }
        
        /// <summary>
        /// pop the active debug group
        /// <para>
        /// glPopDebugGroup pops the active debug group. After popping a debug group, the GL will also generate
        /// a debug output message describing its cause based on the message string, the source source, and an
        /// ID id submitted to the corresponding glPushDebugGroup command. GL_DEBUG_TYPE_PUSH_GROUP and
        /// GL_DEBUG_TYPE_POP_GROUP share a single namespace for message id. severity has the value
        /// GL_DEBUG_SEVERITY_NOTIFICATION. The type has the value GL_DEBUG_TYPE_POP_GROUP. Popping a debug
        /// group restores the debug output volume control of the parent debug group
        /// </para>
        /// </summary>
        public static void glPopDebugGroup() {
            Pointers.glPopDebugGroup();
        }
        
        /// <summary>
        /// pop the active debug group
        /// <para>
        /// glPopDebugGroup pops the active debug group. After popping a debug group, the GL will also generate
        /// a debug output message describing its cause based on the message string, the source source, and an
        /// ID id submitted to the corresponding glPushDebugGroup command. GL_DEBUG_TYPE_PUSH_GROUP and
        /// GL_DEBUG_TYPE_POP_GROUP share a single namespace for message id. severity has the value
        /// GL_DEBUG_SEVERITY_NOTIFICATION. The type has the value GL_DEBUG_TYPE_POP_GROUP. Popping a debug
        /// group restores the debug output volume control of the parent debug group
        /// </para>
        /// </summary>
        public static void glPopDebugGroupKHR() {
            Pointers.glPopDebugGroupKHR();
        }
        
        public static void glPopGroupMarkerEXT() {
            Pointers.glPopGroupMarkerEXT();
        }
        
        /// <summary>
        /// push and pop the current matrix stack
        /// <para>
        /// There is a stack of matrices for each of the matrix modes. In GL_MODELVIEW mode, the stack depth is
        /// at least 32. In the other modes, GL_COLOR, GL_PROJECTION, and GL_TEXTURE, the depth is at least 2.
        /// The current matrix in any mode is the matrix on the top of the stack for that mode
        /// </para>
        /// </summary>
        public static void glPopMatrix() {
            Pointers.glPopMatrix();
        }
        
        /// <summary>
        /// push and pop the name stack
        /// <para>
        /// The name stack is used during selection mode to allow sets of rendering commands to be uniquely
        /// identified. It consists of an ordered set of unsigned integers and is initially empty
        /// </para>
        /// </summary>
        public static void glPopName() {
            Pointers.glPopName();
        }
        
        public static void glPresentFrameDualFillNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, int type, int target0, uint fill0, int target1, uint fill1, int target2, uint fill2, int target3, uint fill3) {
            Pointers.glPresentFrameDualFillNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3);
        }
        
        public static void glPresentFrameKeyedNV(uint video_slot, ulong minPresentTime, uint beginPresentTimeId, uint presentDurationId, int type, int target0, uint fill0, uint key0, int target1, uint fill1, uint key1) {
            Pointers.glPresentFrameKeyedNV(video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1);
        }
        
        public static void glPrimitiveBoundingBox(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) {
            Pointers.glPrimitiveBoundingBox(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
        }
        
        public static void glPrimitiveBoundingBoxARB(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) {
            Pointers.glPrimitiveBoundingBoxARB(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
        }
        
        public static void glPrimitiveBoundingBoxEXT(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) {
            Pointers.glPrimitiveBoundingBoxEXT(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
        }
        
        public static void glPrimitiveBoundingBoxOES(float minX, float minY, float minZ, float minW, float maxX, float maxY, float maxZ, float maxW) {
            Pointers.glPrimitiveBoundingBoxOES(minX, minY, minZ, minW, maxX, maxY, maxZ, maxW);
        }
        
        /// <summary>
        /// specify the primitive restart index
        /// <para>
        /// glPrimitiveRestartIndex specifies a vertex array element that is treated specially when primitive
        /// restarting is enabled. This is known as the primitive restart index
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the value to be interpreted as the primitive restart index.
        /// </param>
        public static void glPrimitiveRestartIndex(uint index) {
            Pointers.glPrimitiveRestartIndex(index);
        }
        
        public static void glPrimitiveRestartIndexNV(uint index) {
            Pointers.glPrimitiveRestartIndexNV(index);
        }
        
        public static void glPrimitiveRestartNV() {
            Pointers.glPrimitiveRestartNV();
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTextures(int n, uint* textures, float* priorities) {
            Pointers.glPrioritizeTextures(n, textures, priorities);
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTextures(int n, uint* textures, float[] priorities) {
            fixed(float* priorities_ = &priorities[0])
                Pointers.glPrioritizeTextures(n, textures, priorities_);
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTextures(int n, uint[] textures, float* priorities) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glPrioritizeTextures(n, textures_, priorities);
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTextures(int n, uint[] textures, float[] priorities) {
            fixed(uint* textures_ = &textures[0])
            fixed(float* priorities_ = &priorities[0])
                Pointers.glPrioritizeTextures(n, textures_, priorities_);
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTexturesEXT(int n, uint* textures, float* priorities) {
            Pointers.glPrioritizeTexturesEXT(n, textures, priorities);
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTexturesEXT(int n, uint* textures, float[] priorities) {
            fixed(float* priorities_ = &priorities[0])
                Pointers.glPrioritizeTexturesEXT(n, textures, priorities_);
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTexturesEXT(int n, uint[] textures, float* priorities) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glPrioritizeTexturesEXT(n, textures_, priorities);
        }
        
        /// <summary>
        /// set texture residence priority
        /// <para>
        /// glPrioritizeTextures assigns the n texture priorities given in priorities to the n textures named in
        /// textures
        /// </para>
        /// </summary>
        /// <param name="n">
        /// Specifies the number of textures to be prioritized.
        /// </param>
        /// <param name="textures">
        /// Specifies an array containing the names of the textures to be prioritized.
        /// </param>
        /// <param name="priorities">
        /// Specifies an array containing the texture priorities. A priority given in an element of priorities
        /// applies to the texture named by the corresponding element of textures.
        /// </param>
        public static void glPrioritizeTexturesEXT(int n, uint[] textures, float[] priorities) {
            fixed(uint* textures_ = &textures[0])
            fixed(float* priorities_ = &priorities[0])
                Pointers.glPrioritizeTexturesEXT(n, textures_, priorities_);
        }
        
        public static void glPrioritizeTexturesxOES(int n, uint* textures, IntPtr* priorities) {
            Pointers.glPrioritizeTexturesxOES(n, textures, priorities);
        }
        
        public static void glPrioritizeTexturesxOES(int n, uint* textures, IntPtr[] priorities) {
            fixed(IntPtr* priorities_ = &priorities[0])
                Pointers.glPrioritizeTexturesxOES(n, textures, priorities_);
        }
        
        public static void glPrioritizeTexturesxOES(int n, uint[] textures, IntPtr* priorities) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glPrioritizeTexturesxOES(n, textures_, priorities);
        }
        
        public static void glPrioritizeTexturesxOES(int n, uint[] textures, IntPtr[] priorities) {
            fixed(uint* textures_ = &textures[0])
            fixed(IntPtr* priorities_ = &priorities[0])
                Pointers.glPrioritizeTexturesxOES(n, textures_, priorities_);
        }
        
        /// <summary>
        /// load a program object with a program binary
        /// <para>
        /// glProgramBinary loads a program object with a program binary previously returned from
        /// glGetProgramBinary. binaryFormat and binary must be those returned by a previous call to
        /// glGetProgramBinary, and length must be the length returned by glGetProgramBinary, or by glGetProgram
        /// when called with pname set to GL_PROGRAM_BINARY_LENGTH. If these conditions are not met, loading the
        /// program binary will fail and program's GL_LINK_STATUS will be set to GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        public static void glProgramBinary(uint program, int binaryFormat, IntPtr binary, int length) {
            Pointers.glProgramBinary(program, binaryFormat, binary, length);
        }
        
        /// <summary>
        /// load a program object with a program binary
        /// <para>
        /// glProgramBinary loads a program object with a program binary previously returned from
        /// glGetProgramBinary. binaryFormat and binary must be those returned by a previous call to
        /// glGetProgramBinary, and length must be the length returned by glGetProgramBinary, or by glGetProgram
        /// when called with pname set to GL_PROGRAM_BINARY_LENGTH. If these conditions are not met, loading the
        /// program binary will fail and program's GL_LINK_STATUS will be set to GL_FALSE
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object into which to load a program binary.
        /// </param>
        /// <param name="binaryFormat">
        /// Specifies the format of the binary data in binary.
        /// </param>
        /// <param name="binary">
        /// Specifies the address an array containing the binary to be loaded into program.
        /// </param>
        /// <param name="length">
        /// Specifies the number of bytes contained in binary.
        /// </param>
        public static void glProgramBinaryOES(uint program, int binaryFormat, IntPtr binary, int length) {
            Pointers.glProgramBinaryOES(program, binaryFormat, binary, length);
        }
        
        public static void glProgramBufferParametersIivNV(int target, uint bindingIndex, uint wordIndex, int count, int* _params) {
            Pointers.glProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, _params);
        }
        
        public static void glProgramBufferParametersIivNV(int target, uint bindingIndex, uint wordIndex, int count, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glProgramBufferParametersIivNV(target, bindingIndex, wordIndex, count, _params_);
        }
        
        public static void glProgramBufferParametersIuivNV(int target, uint bindingIndex, uint wordIndex, int count, uint* _params) {
            Pointers.glProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, _params);
        }
        
        public static void glProgramBufferParametersIuivNV(int target, uint bindingIndex, uint wordIndex, int count, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glProgramBufferParametersIuivNV(target, bindingIndex, wordIndex, count, _params_);
        }
        
        public static void glProgramBufferParametersfvNV(int target, uint bindingIndex, uint wordIndex, int count, float* _params) {
            Pointers.glProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, _params);
        }
        
        public static void glProgramBufferParametersfvNV(int target, uint bindingIndex, uint wordIndex, int count, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glProgramBufferParametersfvNV(target, bindingIndex, wordIndex, count, _params_);
        }
        
        public static void glProgramEnvParameter4dARB(int target, uint index, double x, double y, double z, double w) {
            Pointers.glProgramEnvParameter4dARB(target, index, x, y, z, w);
        }
        
        public static void glProgramEnvParameter4dvARB(int target, uint index, double* _params) {
            Pointers.glProgramEnvParameter4dvARB(target, index, _params);
        }
        
        public static void glProgramEnvParameter4dvARB(int target, uint index, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glProgramEnvParameter4dvARB(target, index, _params_);
        }
        
        public static void glProgramEnvParameter4fARB(int target, uint index, float x, float y, float z, float w) {
            Pointers.glProgramEnvParameter4fARB(target, index, x, y, z, w);
        }
        
        public static void glProgramEnvParameter4fvARB(int target, uint index, float* _params) {
            Pointers.glProgramEnvParameter4fvARB(target, index, _params);
        }
        
        public static void glProgramEnvParameter4fvARB(int target, uint index, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glProgramEnvParameter4fvARB(target, index, _params_);
        }
        
        public static void glProgramEnvParameterI4iNV(int target, uint index, int x, int y, int z, int w) {
            Pointers.glProgramEnvParameterI4iNV(target, index, x, y, z, w);
        }
        
        public static void glProgramEnvParameterI4ivNV(int target, uint index, int* _params) {
            Pointers.glProgramEnvParameterI4ivNV(target, index, _params);
        }
        
        public static void glProgramEnvParameterI4ivNV(int target, uint index, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glProgramEnvParameterI4ivNV(target, index, _params_);
        }
        
        public static void glProgramEnvParameterI4uiNV(int target, uint index, uint x, uint y, uint z, uint w) {
            Pointers.glProgramEnvParameterI4uiNV(target, index, x, y, z, w);
        }
        
        public static void glProgramEnvParameterI4uivNV(int target, uint index, uint* _params) {
            Pointers.glProgramEnvParameterI4uivNV(target, index, _params);
        }
        
        public static void glProgramEnvParameterI4uivNV(int target, uint index, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glProgramEnvParameterI4uivNV(target, index, _params_);
        }
        
        public static void glProgramEnvParameters4fvEXT(int target, uint index, int count, float* _params) {
            Pointers.glProgramEnvParameters4fvEXT(target, index, count, _params);
        }
        
        public static void glProgramEnvParameters4fvEXT(int target, uint index, int count, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glProgramEnvParameters4fvEXT(target, index, count, _params_);
        }
        
        public static void glProgramEnvParametersI4ivNV(int target, uint index, int count, int* _params) {
            Pointers.glProgramEnvParametersI4ivNV(target, index, count, _params);
        }
        
        public static void glProgramEnvParametersI4ivNV(int target, uint index, int count, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glProgramEnvParametersI4ivNV(target, index, count, _params_);
        }
        
        public static void glProgramEnvParametersI4uivNV(int target, uint index, int count, uint* _params) {
            Pointers.glProgramEnvParametersI4uivNV(target, index, count, _params);
        }
        
        public static void glProgramEnvParametersI4uivNV(int target, uint index, int count, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glProgramEnvParametersI4uivNV(target, index, count, _params_);
        }
        
        public static void glProgramLocalParameter4dARB(int target, uint index, double x, double y, double z, double w) {
            Pointers.glProgramLocalParameter4dARB(target, index, x, y, z, w);
        }
        
        public static void glProgramLocalParameter4dvARB(int target, uint index, double* _params) {
            Pointers.glProgramLocalParameter4dvARB(target, index, _params);
        }
        
        public static void glProgramLocalParameter4dvARB(int target, uint index, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glProgramLocalParameter4dvARB(target, index, _params_);
        }
        
        public static void glProgramLocalParameter4fARB(int target, uint index, float x, float y, float z, float w) {
            Pointers.glProgramLocalParameter4fARB(target, index, x, y, z, w);
        }
        
        public static void glProgramLocalParameter4fvARB(int target, uint index, float* _params) {
            Pointers.glProgramLocalParameter4fvARB(target, index, _params);
        }
        
        public static void glProgramLocalParameter4fvARB(int target, uint index, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glProgramLocalParameter4fvARB(target, index, _params_);
        }
        
        public static void glProgramLocalParameterI4iNV(int target, uint index, int x, int y, int z, int w) {
            Pointers.glProgramLocalParameterI4iNV(target, index, x, y, z, w);
        }
        
        public static void glProgramLocalParameterI4ivNV(int target, uint index, int* _params) {
            Pointers.glProgramLocalParameterI4ivNV(target, index, _params);
        }
        
        public static void glProgramLocalParameterI4ivNV(int target, uint index, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glProgramLocalParameterI4ivNV(target, index, _params_);
        }
        
        public static void glProgramLocalParameterI4uiNV(int target, uint index, uint x, uint y, uint z, uint w) {
            Pointers.glProgramLocalParameterI4uiNV(target, index, x, y, z, w);
        }
        
        public static void glProgramLocalParameterI4uivNV(int target, uint index, uint* _params) {
            Pointers.glProgramLocalParameterI4uivNV(target, index, _params);
        }
        
        public static void glProgramLocalParameterI4uivNV(int target, uint index, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glProgramLocalParameterI4uivNV(target, index, _params_);
        }
        
        public static void glProgramLocalParameters4fvEXT(int target, uint index, int count, float* _params) {
            Pointers.glProgramLocalParameters4fvEXT(target, index, count, _params);
        }
        
        public static void glProgramLocalParameters4fvEXT(int target, uint index, int count, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glProgramLocalParameters4fvEXT(target, index, count, _params_);
        }
        
        public static void glProgramLocalParametersI4ivNV(int target, uint index, int count, int* _params) {
            Pointers.glProgramLocalParametersI4ivNV(target, index, count, _params);
        }
        
        public static void glProgramLocalParametersI4ivNV(int target, uint index, int count, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glProgramLocalParametersI4ivNV(target, index, count, _params_);
        }
        
        public static void glProgramLocalParametersI4uivNV(int target, uint index, int count, uint* _params) {
            Pointers.glProgramLocalParametersI4uivNV(target, index, count, _params);
        }
        
        public static void glProgramLocalParametersI4uivNV(int target, uint index, int count, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glProgramLocalParametersI4uivNV(target, index, count, _params_);
        }
        
        public static void glProgramNamedParameter4dNV(uint id, int len, byte* name, double x, double y, double z, double w) {
            Pointers.glProgramNamedParameter4dNV(id, len, name, x, y, z, w);
        }
        
        public static void glProgramNamedParameter4dNV(uint id, int len, out byte name, double x, double y, double z, double w) {
            fixed(byte* name_ = &name)
                Pointers.glProgramNamedParameter4dNV(id, len, name_, x, y, z, w);
        }
        
        public static void glProgramNamedParameter4dvNV(uint id, int len, byte* name, double* v) {
            Pointers.glProgramNamedParameter4dvNV(id, len, name, v);
        }
        
        public static void glProgramNamedParameter4dvNV(uint id, int len, byte* name, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glProgramNamedParameter4dvNV(id, len, name, v_);
        }
        
        public static void glProgramNamedParameter4dvNV(uint id, int len, out byte name, double* v) {
            fixed(byte* name_ = &name)
                Pointers.glProgramNamedParameter4dvNV(id, len, name_, v);
        }
        
        public static void glProgramNamedParameter4dvNV(uint id, int len, out byte name, double[] v) {
            fixed(byte* name_ = &name)
            fixed(double* v_ = &v[0])
                Pointers.glProgramNamedParameter4dvNV(id, len, name_, v_);
        }
        
        public static void glProgramNamedParameter4fNV(uint id, int len, byte* name, float x, float y, float z, float w) {
            Pointers.glProgramNamedParameter4fNV(id, len, name, x, y, z, w);
        }
        
        public static void glProgramNamedParameter4fNV(uint id, int len, out byte name, float x, float y, float z, float w) {
            fixed(byte* name_ = &name)
                Pointers.glProgramNamedParameter4fNV(id, len, name_, x, y, z, w);
        }
        
        public static void glProgramNamedParameter4fvNV(uint id, int len, byte* name, float* v) {
            Pointers.glProgramNamedParameter4fvNV(id, len, name, v);
        }
        
        public static void glProgramNamedParameter4fvNV(uint id, int len, byte* name, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glProgramNamedParameter4fvNV(id, len, name, v_);
        }
        
        public static void glProgramNamedParameter4fvNV(uint id, int len, out byte name, float* v) {
            fixed(byte* name_ = &name)
                Pointers.glProgramNamedParameter4fvNV(id, len, name_, v);
        }
        
        public static void glProgramNamedParameter4fvNV(uint id, int len, out byte name, float[] v) {
            fixed(byte* name_ = &name)
            fixed(float* v_ = &v[0])
                Pointers.glProgramNamedParameter4fvNV(id, len, name_, v_);
        }
        
        public static void glProgramParameter4dNV(int target, uint index, double x, double y, double z, double w) {
            Pointers.glProgramParameter4dNV(target, index, x, y, z, w);
        }
        
        public static void glProgramParameter4dvNV(int target, uint index, double* v) {
            Pointers.glProgramParameter4dvNV(target, index, v);
        }
        
        public static void glProgramParameter4dvNV(int target, uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glProgramParameter4dvNV(target, index, v_);
        }
        
        public static void glProgramParameter4fNV(int target, uint index, float x, float y, float z, float w) {
            Pointers.glProgramParameter4fNV(target, index, x, y, z, w);
        }
        
        public static void glProgramParameter4fvNV(int target, uint index, float* v) {
            Pointers.glProgramParameter4fvNV(target, index, v);
        }
        
        public static void glProgramParameter4fvNV(int target, uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glProgramParameter4fvNV(target, index, v_);
        }
        
        /// <summary>
        /// specify a parameter for a program object
        /// <para>
        /// glProgramParameter specifies a new value for the parameter nameed by pname for the program object
        /// program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to modify.
        /// </param>
        /// <param name="value">
        /// Specifies the new value of the parameter specified by pname for program.
        /// </param>
        public static void glProgramParameteri(uint program, int pname, int value) {
            Pointers.glProgramParameteri(program, pname, value);
        }
        
        /// <summary>
        /// specify a parameter for a program object
        /// <para>
        /// glProgramParameter specifies a new value for the parameter nameed by pname for the program object
        /// program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to modify.
        /// </param>
        /// <param name="value">
        /// Specifies the new value of the parameter specified by pname for program.
        /// </param>
        public static void glProgramParameteriARB(uint program, int pname, int value) {
            Pointers.glProgramParameteriARB(program, pname, value);
        }
        
        /// <summary>
        /// specify a parameter for a program object
        /// <para>
        /// glProgramParameter specifies a new value for the parameter nameed by pname for the program object
        /// program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the name of a program object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the name of the parameter to modify.
        /// </param>
        /// <param name="value">
        /// Specifies the new value of the parameter specified by pname for program.
        /// </param>
        public static void glProgramParameteriEXT(uint program, int pname, int value) {
            Pointers.glProgramParameteriEXT(program, pname, value);
        }
        
        public static void glProgramParameters4dvNV(int target, uint index, int count, double* v) {
            Pointers.glProgramParameters4dvNV(target, index, count, v);
        }
        
        public static void glProgramParameters4dvNV(int target, uint index, int count, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glProgramParameters4dvNV(target, index, count, v_);
        }
        
        public static void glProgramParameters4fvNV(int target, uint index, int count, float* v) {
            Pointers.glProgramParameters4fvNV(target, index, count, v);
        }
        
        public static void glProgramParameters4fvNV(int target, uint index, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glProgramParameters4fvNV(target, index, count, v_);
        }
        
        public static void glProgramPathFragmentInputGenNV(uint program, int location, int genMode, int components, float* coeffs) {
            Pointers.glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs);
        }
        
        public static void glProgramPathFragmentInputGenNV(uint program, int location, int genMode, int components, float[] coeffs) {
            fixed(float* coeffs_ = &coeffs[0])
                Pointers.glProgramPathFragmentInputGenNV(program, location, genMode, components, coeffs_);
        }
        
        public static void glProgramStringARB(int target, int format, int len, IntPtr _string) {
            Pointers.glProgramStringARB(target, format, len, _string);
        }
        
        public static void glProgramSubroutineParametersuivNV(int target, int count, uint* _params) {
            Pointers.glProgramSubroutineParametersuivNV(target, count, _params);
        }
        
        public static void glProgramSubroutineParametersuivNV(int target, int count, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glProgramSubroutineParametersuivNV(target, count, _params_);
        }
        
        public static void glProgramUniform1d(uint program, int location, double v0) {
            Pointers.glProgramUniform1d(program, location, v0);
        }
        
        public static void glProgramUniform1dEXT(uint program, int location, double x) {
            Pointers.glProgramUniform1dEXT(program, location, x);
        }
        
        public static void glProgramUniform1dv(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform1dv(program, location, count, value);
        }
        
        public static void glProgramUniform1dv(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform1dv(program, location, count, value_);
        }
        
        public static void glProgramUniform1dvEXT(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform1dvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform1dvEXT(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform1dvEXT(program, location, count, value_);
        }
        
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>
        /// glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location
        /// of the uniform variable to be modified is specified by location, which should be a value returned by
        /// glGetUniformLocation. glProgramUniform operates on the program object specified by program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        public static void glProgramUniform1f(uint program, int location, float v0) {
            Pointers.glProgramUniform1f(program, location, v0);
        }
        
        /// <summary>
        /// Specify the value of a uniform variable for a specified program object
        /// <para>
        /// glProgramUniform modifies the value of a uniform variable or a uniform variable array. The location
        /// of the uniform variable to be modified is specified by location, which should be a value returned by
        /// glGetUniformLocation. glProgramUniform operates on the program object specified by program
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program containing the uniform variable to be modified.
        /// </param>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        public static void glProgramUniform1fEXT(uint program, int location, float v0) {
            Pointers.glProgramUniform1fEXT(program, location, v0);
        }
        
        public static void glProgramUniform1fv(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform1fv(program, location, count, value);
        }
        
        public static void glProgramUniform1fv(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform1fv(program, location, count, value_);
        }
        
        public static void glProgramUniform1fvEXT(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform1fvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform1fvEXT(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform1fvEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform1i(uint program, int location, int v0) {
            Pointers.glProgramUniform1i(program, location, v0);
        }
        
        public static void glProgramUniform1i64ARB(uint program, int location, long x) {
            Pointers.glProgramUniform1i64ARB(program, location, x);
        }
        
        public static void glProgramUniform1i64NV(uint program, int location, long x) {
            Pointers.glProgramUniform1i64NV(program, location, x);
        }
        
        public static void glProgramUniform1i64vARB(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform1i64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform1i64vARB(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform1i64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform1i64vNV(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform1i64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform1i64vNV(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform1i64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform1iEXT(uint program, int location, int v0) {
            Pointers.glProgramUniform1iEXT(program, location, v0);
        }
        
        public static void glProgramUniform1iv(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform1iv(program, location, count, value);
        }
        
        public static void glProgramUniform1iv(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform1iv(program, location, count, value_);
        }
        
        public static void glProgramUniform1ivEXT(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform1ivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform1ivEXT(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform1ivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform1ui(uint program, int location, uint v0) {
            Pointers.glProgramUniform1ui(program, location, v0);
        }
        
        public static void glProgramUniform1ui64ARB(uint program, int location, ulong x) {
            Pointers.glProgramUniform1ui64ARB(program, location, x);
        }
        
        public static void glProgramUniform1ui64NV(uint program, int location, ulong x) {
            Pointers.glProgramUniform1ui64NV(program, location, x);
        }
        
        public static void glProgramUniform1ui64vARB(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform1ui64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform1ui64vARB(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform1ui64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform1ui64vNV(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform1ui64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform1ui64vNV(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform1ui64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform1uiEXT(uint program, int location, uint v0) {
            Pointers.glProgramUniform1uiEXT(program, location, v0);
        }
        
        public static void glProgramUniform1uiv(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform1uiv(program, location, count, value);
        }
        
        public static void glProgramUniform1uiv(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform1uiv(program, location, count, value_);
        }
        
        public static void glProgramUniform1uivEXT(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform1uivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform1uivEXT(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform1uivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform2d(uint program, int location, double v0, double v1) {
            Pointers.glProgramUniform2d(program, location, v0, v1);
        }
        
        public static void glProgramUniform2dEXT(uint program, int location, double x, double y) {
            Pointers.glProgramUniform2dEXT(program, location, x, y);
        }
        
        public static void glProgramUniform2dv(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform2dv(program, location, count, value);
        }
        
        public static void glProgramUniform2dv(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform2dv(program, location, count, value_);
        }
        
        public static void glProgramUniform2dvEXT(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform2dvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform2dvEXT(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform2dvEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform2f(uint program, int location, float v0, float v1) {
            Pointers.glProgramUniform2f(program, location, v0, v1);
        }
        
        public static void glProgramUniform2fEXT(uint program, int location, float v0, float v1) {
            Pointers.glProgramUniform2fEXT(program, location, v0, v1);
        }
        
        public static void glProgramUniform2fv(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform2fv(program, location, count, value);
        }
        
        public static void glProgramUniform2fv(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform2fv(program, location, count, value_);
        }
        
        public static void glProgramUniform2fvEXT(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform2fvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform2fvEXT(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform2fvEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform2i(uint program, int location, int v0, int v1) {
            Pointers.glProgramUniform2i(program, location, v0, v1);
        }
        
        public static void glProgramUniform2i64ARB(uint program, int location, long x, long y) {
            Pointers.glProgramUniform2i64ARB(program, location, x, y);
        }
        
        public static void glProgramUniform2i64NV(uint program, int location, long x, long y) {
            Pointers.glProgramUniform2i64NV(program, location, x, y);
        }
        
        public static void glProgramUniform2i64vARB(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform2i64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform2i64vARB(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform2i64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform2i64vNV(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform2i64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform2i64vNV(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform2i64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform2iEXT(uint program, int location, int v0, int v1) {
            Pointers.glProgramUniform2iEXT(program, location, v0, v1);
        }
        
        public static void glProgramUniform2iv(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform2iv(program, location, count, value);
        }
        
        public static void glProgramUniform2iv(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform2iv(program, location, count, value_);
        }
        
        public static void glProgramUniform2ivEXT(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform2ivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform2ivEXT(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform2ivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform2ui(uint program, int location, uint v0, uint v1) {
            Pointers.glProgramUniform2ui(program, location, v0, v1);
        }
        
        public static void glProgramUniform2ui64ARB(uint program, int location, ulong x, ulong y) {
            Pointers.glProgramUniform2ui64ARB(program, location, x, y);
        }
        
        public static void glProgramUniform2ui64NV(uint program, int location, ulong x, ulong y) {
            Pointers.glProgramUniform2ui64NV(program, location, x, y);
        }
        
        public static void glProgramUniform2ui64vARB(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform2ui64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform2ui64vARB(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform2ui64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform2ui64vNV(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform2ui64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform2ui64vNV(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform2ui64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform2uiEXT(uint program, int location, uint v0, uint v1) {
            Pointers.glProgramUniform2uiEXT(program, location, v0, v1);
        }
        
        public static void glProgramUniform2uiv(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform2uiv(program, location, count, value);
        }
        
        public static void glProgramUniform2uiv(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform2uiv(program, location, count, value_);
        }
        
        public static void glProgramUniform2uivEXT(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform2uivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform2uivEXT(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform2uivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform3d(uint program, int location, double v0, double v1, double v2) {
            Pointers.glProgramUniform3d(program, location, v0, v1, v2);
        }
        
        public static void glProgramUniform3dEXT(uint program, int location, double x, double y, double z) {
            Pointers.glProgramUniform3dEXT(program, location, x, y, z);
        }
        
        public static void glProgramUniform3dv(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform3dv(program, location, count, value);
        }
        
        public static void glProgramUniform3dv(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform3dv(program, location, count, value_);
        }
        
        public static void glProgramUniform3dvEXT(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform3dvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform3dvEXT(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform3dvEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform3f(uint program, int location, float v0, float v1, float v2) {
            Pointers.glProgramUniform3f(program, location, v0, v1, v2);
        }
        
        public static void glProgramUniform3fEXT(uint program, int location, float v0, float v1, float v2) {
            Pointers.glProgramUniform3fEXT(program, location, v0, v1, v2);
        }
        
        public static void glProgramUniform3fv(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform3fv(program, location, count, value);
        }
        
        public static void glProgramUniform3fv(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform3fv(program, location, count, value_);
        }
        
        public static void glProgramUniform3fvEXT(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform3fvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform3fvEXT(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform3fvEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform3i(uint program, int location, int v0, int v1, int v2) {
            Pointers.glProgramUniform3i(program, location, v0, v1, v2);
        }
        
        public static void glProgramUniform3i64ARB(uint program, int location, long x, long y, long z) {
            Pointers.glProgramUniform3i64ARB(program, location, x, y, z);
        }
        
        public static void glProgramUniform3i64NV(uint program, int location, long x, long y, long z) {
            Pointers.glProgramUniform3i64NV(program, location, x, y, z);
        }
        
        public static void glProgramUniform3i64vARB(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform3i64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform3i64vARB(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform3i64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform3i64vNV(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform3i64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform3i64vNV(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform3i64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform3iEXT(uint program, int location, int v0, int v1, int v2) {
            Pointers.glProgramUniform3iEXT(program, location, v0, v1, v2);
        }
        
        public static void glProgramUniform3iv(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform3iv(program, location, count, value);
        }
        
        public static void glProgramUniform3iv(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform3iv(program, location, count, value_);
        }
        
        public static void glProgramUniform3ivEXT(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform3ivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform3ivEXT(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform3ivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform3ui(uint program, int location, uint v0, uint v1, uint v2) {
            Pointers.glProgramUniform3ui(program, location, v0, v1, v2);
        }
        
        public static void glProgramUniform3ui64ARB(uint program, int location, ulong x, ulong y, ulong z) {
            Pointers.glProgramUniform3ui64ARB(program, location, x, y, z);
        }
        
        public static void glProgramUniform3ui64NV(uint program, int location, ulong x, ulong y, ulong z) {
            Pointers.glProgramUniform3ui64NV(program, location, x, y, z);
        }
        
        public static void glProgramUniform3ui64vARB(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform3ui64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform3ui64vARB(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform3ui64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform3ui64vNV(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform3ui64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform3ui64vNV(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform3ui64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform3uiEXT(uint program, int location, uint v0, uint v1, uint v2) {
            Pointers.glProgramUniform3uiEXT(program, location, v0, v1, v2);
        }
        
        public static void glProgramUniform3uiv(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform3uiv(program, location, count, value);
        }
        
        public static void glProgramUniform3uiv(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform3uiv(program, location, count, value_);
        }
        
        public static void glProgramUniform3uivEXT(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform3uivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform3uivEXT(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform3uivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform4d(uint program, int location, double v0, double v1, double v2, double v3) {
            Pointers.glProgramUniform4d(program, location, v0, v1, v2, v3);
        }
        
        public static void glProgramUniform4dEXT(uint program, int location, double x, double y, double z, double w) {
            Pointers.glProgramUniform4dEXT(program, location, x, y, z, w);
        }
        
        public static void glProgramUniform4dv(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform4dv(program, location, count, value);
        }
        
        public static void glProgramUniform4dv(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform4dv(program, location, count, value_);
        }
        
        public static void glProgramUniform4dvEXT(uint program, int location, int count, double* value) {
            Pointers.glProgramUniform4dvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform4dvEXT(uint program, int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniform4dvEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform4f(uint program, int location, float v0, float v1, float v2, float v3) {
            Pointers.glProgramUniform4f(program, location, v0, v1, v2, v3);
        }
        
        public static void glProgramUniform4fEXT(uint program, int location, float v0, float v1, float v2, float v3) {
            Pointers.glProgramUniform4fEXT(program, location, v0, v1, v2, v3);
        }
        
        public static void glProgramUniform4fv(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform4fv(program, location, count, value);
        }
        
        public static void glProgramUniform4fv(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform4fv(program, location, count, value_);
        }
        
        public static void glProgramUniform4fvEXT(uint program, int location, int count, float* value) {
            Pointers.glProgramUniform4fvEXT(program, location, count, value);
        }
        
        public static void glProgramUniform4fvEXT(uint program, int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniform4fvEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform4i(uint program, int location, int v0, int v1, int v2, int v3) {
            Pointers.glProgramUniform4i(program, location, v0, v1, v2, v3);
        }
        
        public static void glProgramUniform4i64ARB(uint program, int location, long x, long y, long z, long w) {
            Pointers.glProgramUniform4i64ARB(program, location, x, y, z, w);
        }
        
        public static void glProgramUniform4i64NV(uint program, int location, long x, long y, long z, long w) {
            Pointers.glProgramUniform4i64NV(program, location, x, y, z, w);
        }
        
        public static void glProgramUniform4i64vARB(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform4i64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform4i64vARB(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform4i64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform4i64vNV(uint program, int location, int count, long* value) {
            Pointers.glProgramUniform4i64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform4i64vNV(uint program, int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glProgramUniform4i64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform4iEXT(uint program, int location, int v0, int v1, int v2, int v3) {
            Pointers.glProgramUniform4iEXT(program, location, v0, v1, v2, v3);
        }
        
        public static void glProgramUniform4iv(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform4iv(program, location, count, value);
        }
        
        public static void glProgramUniform4iv(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform4iv(program, location, count, value_);
        }
        
        public static void glProgramUniform4ivEXT(uint program, int location, int count, int* value) {
            Pointers.glProgramUniform4ivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform4ivEXT(uint program, int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glProgramUniform4ivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniform4ui(uint program, int location, uint v0, uint v1, uint v2, uint v3) {
            Pointers.glProgramUniform4ui(program, location, v0, v1, v2, v3);
        }
        
        public static void glProgramUniform4ui64ARB(uint program, int location, ulong x, ulong y, ulong z, ulong w) {
            Pointers.glProgramUniform4ui64ARB(program, location, x, y, z, w);
        }
        
        public static void glProgramUniform4ui64NV(uint program, int location, ulong x, ulong y, ulong z, ulong w) {
            Pointers.glProgramUniform4ui64NV(program, location, x, y, z, w);
        }
        
        public static void glProgramUniform4ui64vARB(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform4ui64vARB(program, location, count, value);
        }
        
        public static void glProgramUniform4ui64vARB(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform4ui64vARB(program, location, count, value_);
        }
        
        public static void glProgramUniform4ui64vNV(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniform4ui64vNV(program, location, count, value);
        }
        
        public static void glProgramUniform4ui64vNV(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniform4ui64vNV(program, location, count, value_);
        }
        
        public static void glProgramUniform4uiEXT(uint program, int location, uint v0, uint v1, uint v2, uint v3) {
            Pointers.glProgramUniform4uiEXT(program, location, v0, v1, v2, v3);
        }
        
        public static void glProgramUniform4uiv(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform4uiv(program, location, count, value);
        }
        
        public static void glProgramUniform4uiv(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform4uiv(program, location, count, value_);
        }
        
        public static void glProgramUniform4uivEXT(uint program, int location, int count, uint* value) {
            Pointers.glProgramUniform4uivEXT(program, location, count, value);
        }
        
        public static void glProgramUniform4uivEXT(uint program, int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glProgramUniform4uivEXT(program, location, count, value_);
        }
        
        public static void glProgramUniformHandleui64ARB(uint program, int location, ulong value) {
            Pointers.glProgramUniformHandleui64ARB(program, location, value);
        }
        
        public static void glProgramUniformHandleui64IMG(uint program, int location, ulong value) {
            Pointers.glProgramUniformHandleui64IMG(program, location, value);
        }
        
        public static void glProgramUniformHandleui64NV(uint program, int location, ulong value) {
            Pointers.glProgramUniformHandleui64NV(program, location, value);
        }
        
        public static void glProgramUniformHandleui64vARB(uint program, int location, int count, ulong* values) {
            Pointers.glProgramUniformHandleui64vARB(program, location, count, values);
        }
        
        public static void glProgramUniformHandleui64vARB(uint program, int location, int count, ulong[] values) {
            fixed(ulong* values_ = &values[0])
                Pointers.glProgramUniformHandleui64vARB(program, location, count, values_);
        }
        
        public static void glProgramUniformHandleui64vIMG(uint program, int location, int count, ulong* values) {
            Pointers.glProgramUniformHandleui64vIMG(program, location, count, values);
        }
        
        public static void glProgramUniformHandleui64vIMG(uint program, int location, int count, ulong[] values) {
            fixed(ulong* values_ = &values[0])
                Pointers.glProgramUniformHandleui64vIMG(program, location, count, values_);
        }
        
        public static void glProgramUniformHandleui64vNV(uint program, int location, int count, ulong* values) {
            Pointers.glProgramUniformHandleui64vNV(program, location, count, values);
        }
        
        public static void glProgramUniformHandleui64vNV(uint program, int location, int count, ulong[] values) {
            fixed(ulong* values_ = &values[0])
                Pointers.glProgramUniformHandleui64vNV(program, location, count, values_);
        }
        
        public static void glProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix2dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix2dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix2dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix2dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix2fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix2fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix2fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x3dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x3dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x3dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x3dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x3fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x3fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x3fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x3fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x4dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x4dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x4dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x4dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x4fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x4fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix2x4fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix2x4fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix3dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix3dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix3dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix3dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix3fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix3fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix3fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x2dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x2dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x2dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x2dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x2fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x2fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x2fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x2fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x4dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x4dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x4dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x4dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x4fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x4fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix3x4fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix3x4fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix4dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix4dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix4dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix4dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix4fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix4fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix4fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x2dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x2dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x2dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x2dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x2fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x2fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x2fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x2fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x3dv(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x3dv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, double* value) {
            Pointers.glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x3dvEXT(uint program, int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x3dvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x3fv(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x3fv(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, float* value) {
            Pointers.glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value);
        }
        
        public static void glProgramUniformMatrix4x3fvEXT(uint program, int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glProgramUniformMatrix4x3fvEXT(program, location, count, transpose, value_);
        }
        
        public static void glProgramUniformui64NV(uint program, int location, ulong value) {
            Pointers.glProgramUniformui64NV(program, location, value);
        }
        
        public static void glProgramUniformui64vNV(uint program, int location, int count, ulong* value) {
            Pointers.glProgramUniformui64vNV(program, location, count, value);
        }
        
        public static void glProgramUniformui64vNV(uint program, int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glProgramUniformui64vNV(program, location, count, value_);
        }
        
        public static void glProgramVertexLimitNV(int target, int limit) {
            Pointers.glProgramVertexLimitNV(target, limit);
        }
        
        /// <summary>
        /// specifiy the vertex to be used as the source of data for flat shaded varyings
        /// <para>
        /// Flatshading a vertex shader varying output means to assign all vetices of the primitive the same
        /// value for that output. The vertex from which these values is derived is known as the provoking
        /// vertex and glProvokingVertex specifies which vertex is to be used as the source of data for flat
        /// shaded varyings
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies the vertex to be used as the source of data for flat shaded varyings.
        /// </param>
        public static void glProvokingVertex(int mode) {
            Pointers.glProvokingVertex(mode);
        }
        
        /// <summary>
        /// specifiy the vertex to be used as the source of data for flat shaded varyings
        /// <para>
        /// Flatshading a vertex shader varying output means to assign all vetices of the primitive the same
        /// value for that output. The vertex from which these values is derived is known as the provoking
        /// vertex and glProvokingVertex specifies which vertex is to be used as the source of data for flat
        /// shaded varyings
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies the vertex to be used as the source of data for flat shaded varyings.
        /// </param>
        public static void glProvokingVertexEXT(int mode) {
            Pointers.glProvokingVertexEXT(mode);
        }
        
        /// <summary>
        /// push and pop the server attribute stack
        /// <para>
        /// glPushAttrib takes one argument, a mask that indicates which groups of state variables to save on
        /// the attribute stack. Symbolic constants are used to set bits in the mask. mask is typically
        /// constructed by specifying the bitwise-or of several of these constants together. The special mask
        /// GL_ALL_ATTRIB_BITS can be used to save all stackable states
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a mask that indicates which attributes to save. Values for mask are listed below.
        /// </param>
        public static void glPushAttrib(uint mask) {
            Pointers.glPushAttrib(mask);
        }
        
        /// <summary>
        /// push and pop the server attribute stack
        /// <para>
        /// glPushAttrib takes one argument, a mask that indicates which groups of state variables to save on
        /// the attribute stack. Symbolic constants are used to set bits in the mask. mask is typically
        /// constructed by specifying the bitwise-or of several of these constants together. The special mask
        /// GL_ALL_ATTRIB_BITS can be used to save all stackable states
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a mask that indicates which attributes to save. Values for mask are listed below.
        /// </param>
        public static void glPushAttrib(Enums.AttribMask mask) {
            Pointers.glPushAttrib((uint)mask);
        }
        
        /// <summary>
        /// push and pop the client attribute stack
        /// <para>
        /// glPushClientAttrib takes one argument, a mask that indicates which groups of client-state variables
        /// to save on the client attribute stack. Symbolic constants are used to set bits in the mask. mask is
        /// typically constructed by specifying the bitwise-or of several 	 of these constants together. The
        /// special mask GL_CLIENT_ALL_ATTRIB_BITS can be used to save all stackable client state
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a mask that indicates which attributes to save. Values for mask are listed below.
        /// </param>
        public static void glPushClientAttrib(uint mask) {
            Pointers.glPushClientAttrib(mask);
        }
        
        /// <summary>
        /// push and pop the client attribute stack
        /// <para>
        /// glPushClientAttrib takes one argument, a mask that indicates which groups of client-state variables
        /// to save on the client attribute stack. Symbolic constants are used to set bits in the mask. mask is
        /// typically constructed by specifying the bitwise-or of several 	 of these constants together. The
        /// special mask GL_CLIENT_ALL_ATTRIB_BITS can be used to save all stackable client state
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a mask that indicates which attributes to save. Values for mask are listed below.
        /// </param>
        public static void glPushClientAttrib(Enums.ClientAttribMask mask) {
            Pointers.glPushClientAttrib((uint)mask);
        }
        
        public static void glPushClientAttribDefaultEXT(uint mask) {
            Pointers.glPushClientAttribDefaultEXT(mask);
        }
        
        public static void glPushClientAttribDefaultEXT(Enums.ClientAttribMask mask) {
            Pointers.glPushClientAttribDefaultEXT((uint)mask);
        }
        
        /// <summary>
        /// push a named debug group into the command stream
        /// <para>
        /// glPushDebugGroup pushes a debug group described by the string message into the command stream. The
        /// value of id specifies the ID of messages generated. The parameter length contains the number of
        /// characters in message. If length is negative, it is implied that message contains a null terminated
        /// string. The message has the specified source and id, the type GL_DEBUG_TYPE_PUSH_GROUP, and severity
        /// GL_DEBUG_SEVERITY_NOTIFICATION. The GL will put a new debug group on top of the debug group stack
        /// which inherits the control of the volume of debug output of the debug group previously residing on
        /// the top of the debug group stack. Because debug groups are strictly hierarchical, any additional
        /// control of the debug output volume will only apply within the active debug group and the debug
        /// groups pushed on top of the active debug group
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of the debug message.
        /// </param>
        /// <param name="id">
        /// The identifier of the message.
        /// </param>
        /// <param name="length">
        /// The length of the message to be sent to the debug output stream.
        /// </param>
        /// <param name="message">
        /// The a string containing the message to be sent to the debug output stream.
        /// </param>
        public static void glPushDebugGroup(int source, uint id, int length, string message) {
            Pointers.glPushDebugGroup(source, id, length, message);
        }
        
        /// <summary>
        /// push a named debug group into the command stream
        /// <para>
        /// glPushDebugGroup pushes a debug group described by the string message into the command stream. The
        /// value of id specifies the ID of messages generated. The parameter length contains the number of
        /// characters in message. If length is negative, it is implied that message contains a null terminated
        /// string. The message has the specified source and id, the type GL_DEBUG_TYPE_PUSH_GROUP, and severity
        /// GL_DEBUG_SEVERITY_NOTIFICATION. The GL will put a new debug group on top of the debug group stack
        /// which inherits the control of the volume of debug output of the debug group previously residing on
        /// the top of the debug group stack. Because debug groups are strictly hierarchical, any additional
        /// control of the debug output volume will only apply within the active debug group and the debug
        /// groups pushed on top of the active debug group
        /// </para>
        /// </summary>
        /// <param name="source">
        /// The source of the debug message.
        /// </param>
        /// <param name="id">
        /// The identifier of the message.
        /// </param>
        /// <param name="length">
        /// The length of the message to be sent to the debug output stream.
        /// </param>
        /// <param name="message">
        /// The a string containing the message to be sent to the debug output stream.
        /// </param>
        public static void glPushDebugGroupKHR(int source, uint id, int length, string message) {
            Pointers.glPushDebugGroupKHR(source, id, length, message);
        }
        
        public static void glPushGroupMarkerEXT(int length, string marker) {
            Pointers.glPushGroupMarkerEXT(length, marker);
        }
        
        /// <summary>
        /// push and pop the current matrix stack
        /// <para>
        /// There is a stack of matrices for each of the matrix modes. In GL_MODELVIEW mode, the stack depth is
        /// at least 32. In the other modes, GL_COLOR, GL_PROJECTION, and GL_TEXTURE, the depth is at least 2.
        /// The current matrix in any mode is the matrix on the top of the stack for that mode
        /// </para>
        /// </summary>
        public static void glPushMatrix() {
            Pointers.glPushMatrix();
        }
        
        /// <summary>
        /// push and pop the name stack
        /// <para>
        /// The name stack is used during selection mode to allow sets of rendering commands to be uniquely
        /// identified. It consists of an ordered set of unsigned integers and is initially empty
        /// </para>
        /// </summary>
        /// <param name="name">
        /// Specifies a name that will be pushed onto the name stack.
        /// </param>
        public static void glPushName(uint name) {
            Pointers.glPushName(name);
        }
        
        /// <summary>
        /// record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
        /// <para>
        /// glQueryCounter causes the GL to record the current time into the query object named id. target must
        /// be GL_TIMESTAMP. The time is recorded after all previous commands on the GL client and server state
        /// and the framebuffer have been fully realized. When the time is recorded, the query result for that
        /// object is marked available. glQueryCounter timer queries can be used within a glBeginQuery /
        /// glEndQuery block where the target is GL_TIME_ELAPSED and it does not affect the result of that query
        /// object
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specify the name of a query object into which to record the GL time.
        /// </param>
        /// <param name="target">
        /// Specify the counter to query. target must be GL_TIMESTAMP.
        /// </param>
        public static void glQueryCounter(uint id, int target) {
            Pointers.glQueryCounter(id, target);
        }
        
        /// <summary>
        /// record the GL time into a query object after all previous commands have reached the GL server but have not yet necessarily executed.
        /// <para>
        /// glQueryCounter causes the GL to record the current time into the query object named id. target must
        /// be GL_TIMESTAMP. The time is recorded after all previous commands on the GL client and server state
        /// and the framebuffer have been fully realized. When the time is recorded, the query result for that
        /// object is marked available. glQueryCounter timer queries can be used within a glBeginQuery /
        /// glEndQuery block where the target is GL_TIME_ELAPSED and it does not affect the result of that query
        /// object
        /// </para>
        /// </summary>
        /// <param name="id">
        /// Specify the name of a query object into which to record the GL time.
        /// </param>
        /// <param name="target">
        /// Specify the counter to query. target must be GL_TIMESTAMP.
        /// </param>
        public static void glQueryCounterEXT(uint id, int target) {
            Pointers.glQueryCounterEXT(id, target);
        }
        
        public static uint glQueryMatrixxOES(IntPtr* mantissa, int* exponent) {
            return Pointers.glQueryMatrixxOES(mantissa, exponent);
        }
        
        public static uint glQueryMatrixxOES(IntPtr* mantissa, int[] exponent) {
            fixed(int* exponent_ = &exponent[0])
                return Pointers.glQueryMatrixxOES(mantissa, exponent_);
        }
        
        public static uint glQueryMatrixxOES(IntPtr[] mantissa, int* exponent) {
            fixed(IntPtr* mantissa_ = &mantissa[0])
                return Pointers.glQueryMatrixxOES(mantissa_, exponent);
        }
        
        public static uint glQueryMatrixxOES(IntPtr[] mantissa, int[] exponent) {
            fixed(IntPtr* mantissa_ = &mantissa[0])
            fixed(int* exponent_ = &exponent[0])
                return Pointers.glQueryMatrixxOES(mantissa_, exponent_);
        }
        
        public static void glQueryObjectParameteruiAMD(int target, uint id, int pname, uint param) {
            Pointers.glQueryObjectParameteruiAMD(target, id, pname, param);
        }
        
        public static void glQueryObjectParameteruiAMD(int target, uint id, int pname, Enums.OcclusionQueryEventMaskAMD param) {
            Pointers.glQueryObjectParameteruiAMD(target, id, pname, (uint)param);
        }
        
        public static int glQueryResourceNV(int queryType, int tagId, uint bufSize, int* buffer) {
            return Pointers.glQueryResourceNV(queryType, tagId, bufSize, buffer);
        }
        
        public static int glQueryResourceNV(int queryType, int tagId, uint bufSize, int[] buffer) {
            fixed(int* buffer_ = &buffer[0])
                return Pointers.glQueryResourceNV(queryType, tagId, bufSize, buffer_);
        }
        
        public static void glQueryResourceTagNV(int tagId, string tagString) {
            Pointers.glQueryResourceTagNV(tagId, tagString);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos2d(double x, double y) {
            Pointers.glRasterPos2d(x, y);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2dv(double* v) {
            Pointers.glRasterPos2dv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glRasterPos2dv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos2f(float x, float y) {
            Pointers.glRasterPos2f(x, y);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2fv(float* v) {
            Pointers.glRasterPos2fv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glRasterPos2fv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos2i(int x, int y) {
            Pointers.glRasterPos2i(x, y);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2iv(int* v) {
            Pointers.glRasterPos2iv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glRasterPos2iv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos2s(short x, short y) {
            Pointers.glRasterPos2s(x, y);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2sv(short* v) {
            Pointers.glRasterPos2sv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos2sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glRasterPos2sv(v_);
        }
        
        public static void glRasterPos2xOES(IntPtr x, IntPtr y) {
            Pointers.glRasterPos2xOES(x, y);
        }
        
        public static void glRasterPos2xvOES(IntPtr* coords) {
            Pointers.glRasterPos2xvOES(coords);
        }
        
        public static void glRasterPos2xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glRasterPos2xvOES(coords_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos3d(double x, double y, double z) {
            Pointers.glRasterPos3d(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3dv(double* v) {
            Pointers.glRasterPos3dv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glRasterPos3dv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos3f(float x, float y, float z) {
            Pointers.glRasterPos3f(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3fv(float* v) {
            Pointers.glRasterPos3fv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glRasterPos3fv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos3i(int x, int y, int z) {
            Pointers.glRasterPos3i(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3iv(int* v) {
            Pointers.glRasterPos3iv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glRasterPos3iv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos3s(short x, short y, short z) {
            Pointers.glRasterPos3s(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3sv(short* v) {
            Pointers.glRasterPos3sv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos3sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glRasterPos3sv(v_);
        }
        
        public static void glRasterPos3xOES(IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glRasterPos3xOES(x, y, z);
        }
        
        public static void glRasterPos3xvOES(IntPtr* coords) {
            Pointers.glRasterPos3xvOES(coords);
        }
        
        public static void glRasterPos3xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glRasterPos3xvOES(coords_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="w">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos4d(double x, double y, double z, double w) {
            Pointers.glRasterPos4d(x, y, z, w);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4dv(double* v) {
            Pointers.glRasterPos4dv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glRasterPos4dv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="w">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos4f(float x, float y, float z, float w) {
            Pointers.glRasterPos4f(x, y, z, w);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4fv(float* v) {
            Pointers.glRasterPos4fv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glRasterPos4fv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="w">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos4i(int x, int y, int z, int w) {
            Pointers.glRasterPos4i(x, y, z, w);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4iv(int* v) {
            Pointers.glRasterPos4iv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glRasterPos4iv(v_);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        /// <param name="w">
        /// Specify the x, y, z, and w object coordinates (if present) for the raster position.
        /// </param>
        public static void glRasterPos4s(short x, short y, short z, short w) {
            Pointers.glRasterPos4s(x, y, z, w);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4sv(short* v) {
            Pointers.glRasterPos4sv(v);
        }
        
        /// <summary>
        /// specify the raster position for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements, specifying x, y, z, and w
        /// coordinates, respectively.
        /// </param>
        public static void glRasterPos4sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glRasterPos4sv(v_);
        }
        
        public static void glRasterPos4xOES(IntPtr x, IntPtr y, IntPtr z, IntPtr w) {
            Pointers.glRasterPos4xOES(x, y, z, w);
        }
        
        public static void glRasterPos4xvOES(IntPtr* coords) {
            Pointers.glRasterPos4xvOES(coords);
        }
        
        public static void glRasterPos4xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glRasterPos4xvOES(coords_);
        }
        
        public static void glRasterSamplesEXT(uint samples, bool fixedsamplelocations) {
            Pointers.glRasterSamplesEXT(samples, fixedsamplelocations);
        }
        
        /// <summary>
        /// select a color buffer source for pixels
        /// </summary>
        /// <param name="src">
        /// Specifies a color buffer. Accepted values are GL_FRONT_LEFT, GL_FRONT_RIGHT, GL_BACK_LEFT,
        /// GL_BACK_RIGHT, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, and the constants GL_COLOR_ATTACHMENTi.
        /// </param>
        public static void glReadBuffer(int src) {
            Pointers.glReadBuffer(src);
        }
        
        public static void glReadBufferIndexedEXT(int src, int index) {
            Pointers.glReadBufferIndexedEXT(src, index);
        }
        
        public static void glReadBufferNV(int mode) {
            Pointers.glReadBufferNV(mode);
        }
        
        public static void glReadInstrumentsSGIX(int marker) {
            Pointers.glReadInstrumentsSGIX(marker);
        }
        
        /// <summary>
        /// read a block of pixels from the frame buffer
        /// </summary>
        /// <param name="x">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location
        /// is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="y">
        /// Specify the window coordinates of the first pixel that is read from the frame buffer. This location
        /// is the lower left corner of a rectangular block of pixels.
        /// </param>
        /// <param name="width">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="height">
        /// Specify the dimensions of the pixel rectangle. width and height of one correspond to a single pixel.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted:
        /// GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL, GL_RED, GL_GREEN, GL_BLUE, GL_RGB, GL_BGR,
        /// GL_RGBA, and GL_BGRA.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. Must be one of GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_HALF_FLOAT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV,
        /// GL_UNSIGNED_INT_24_8, GL_UNSIGNED_INT_10F_11F_11F_REV, GL_UNSIGNED_INT_5_9_9_9_REV, or
        /// GL_FLOAT_32_UNSIGNED_INT_24_8_REV.
        /// </param>
        /// <param name="pixels">
        /// Returns the pixel data.
        /// </param>
        public static void glReadPixels(int x, int y, int width, int height, int format, int type, IntPtr pixels) {
            Pointers.glReadPixels(x, y, width, height, format, type, pixels);
        }
        
        public static void glReadnPixels(int x, int y, int width, int height, int format, int type, int bufSize, IntPtr data) {
            Pointers.glReadnPixels(x, y, width, height, format, type, bufSize, data);
        }
        
        public static void glReadnPixelsARB(int x, int y, int width, int height, int format, int type, int bufSize, IntPtr data) {
            Pointers.glReadnPixelsARB(x, y, width, height, format, type, bufSize, data);
        }
        
        public static void glReadnPixelsEXT(int x, int y, int width, int height, int format, int type, int bufSize, IntPtr data) {
            Pointers.glReadnPixelsEXT(x, y, width, height, format, type, bufSize, data);
        }
        
        public static void glReadnPixelsKHR(int x, int y, int width, int height, int format, int type, int bufSize, IntPtr data) {
            Pointers.glReadnPixelsKHR(x, y, width, height, format, type, bufSize, data);
        }
        
        public static bool glReleaseKeyedMutexWin32EXT(uint memory, ulong key) {
            return Pointers.glReleaseKeyedMutexWin32EXT(memory, key);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        public static void glRectd(double x1, double y1, double x2, double y2) {
            Pointers.glRectd(x1, y1, x2, y2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectdv(double* v1, double* v2) {
            Pointers.glRectdv(v1, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectdv(double* v1, double[] v2) {
            fixed(double* v2_ = &v2[0])
                Pointers.glRectdv(v1, v2_);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectdv(double[] v1, double* v2) {
            fixed(double* v1_ = &v1[0])
                Pointers.glRectdv(v1_, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectdv(double[] v1, double[] v2) {
            fixed(double* v1_ = &v1[0])
            fixed(double* v2_ = &v2[0])
                Pointers.glRectdv(v1_, v2_);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        public static void glRectf(float x1, float y1, float x2, float y2) {
            Pointers.glRectf(x1, y1, x2, y2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectfv(float* v1, float* v2) {
            Pointers.glRectfv(v1, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectfv(float* v1, float[] v2) {
            fixed(float* v2_ = &v2[0])
                Pointers.glRectfv(v1, v2_);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectfv(float[] v1, float* v2) {
            fixed(float* v1_ = &v1[0])
                Pointers.glRectfv(v1_, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectfv(float[] v1, float[] v2) {
            fixed(float* v1_ = &v1[0])
            fixed(float* v2_ = &v2[0])
                Pointers.glRectfv(v1_, v2_);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        public static void glRecti(int x1, int y1, int x2, int y2) {
            Pointers.glRecti(x1, y1, x2, y2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectiv(int* v1, int* v2) {
            Pointers.glRectiv(v1, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectiv(int* v1, int[] v2) {
            fixed(int* v2_ = &v2[0])
                Pointers.glRectiv(v1, v2_);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectiv(int[] v1, int* v2) {
            fixed(int* v1_ = &v1[0])
                Pointers.glRectiv(v1_, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectiv(int[] v1, int[] v2) {
            fixed(int* v1_ = &v1[0])
            fixed(int* v2_ = &v2[0])
                Pointers.glRectiv(v1_, v2_);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="x1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="y1">
        /// Specify one vertex of a rectangle.
        /// </param>
        /// <param name="x2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        /// <param name="y2">
        /// Specify the opposite vertex of the rectangle.
        /// </param>
        public static void glRects(short x1, short y1, short x2, short y2) {
            Pointers.glRects(x1, y1, x2, y2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectsv(short* v1, short* v2) {
            Pointers.glRectsv(v1, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectsv(short* v1, short[] v2) {
            fixed(short* v2_ = &v2[0])
                Pointers.glRectsv(v1, v2_);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectsv(short[] v1, short* v2) {
            fixed(short* v1_ = &v1[0])
                Pointers.glRectsv(v1_, v2);
        }
        
        /// <summary>
        /// draw a rectangle
        /// <para>
        /// glRect supports efficient specification of rectangles as two corner points. Each rectangle command
        /// takes four arguments, organized either as two consecutive pairs of x y coordinates or as two
        /// pointers to arrays, each containing an x y pair. The resulting rectangle is defined in the z = 0
        /// plane
        /// </para>
        /// </summary>
        /// <param name="v1">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        /// <param name="v2">
        /// Specifies a pointer to one vertex of a rectangle.
        /// </param>
        public static void glRectsv(short[] v1, short[] v2) {
            fixed(short* v1_ = &v1[0])
            fixed(short* v2_ = &v2[0])
                Pointers.glRectsv(v1_, v2_);
        }
        
        public static void glRectxOES(IntPtr x1, IntPtr y1, IntPtr x2, IntPtr y2) {
            Pointers.glRectxOES(x1, y1, x2, y2);
        }
        
        public static void glRectxvOES(IntPtr* v1, IntPtr* v2) {
            Pointers.glRectxvOES(v1, v2);
        }
        
        public static void glRectxvOES(IntPtr* v1, IntPtr[] v2) {
            fixed(IntPtr* v2_ = &v2[0])
                Pointers.glRectxvOES(v1, v2_);
        }
        
        public static void glRectxvOES(IntPtr[] v1, IntPtr* v2) {
            fixed(IntPtr* v1_ = &v1[0])
                Pointers.glRectxvOES(v1_, v2);
        }
        
        public static void glRectxvOES(IntPtr[] v1, IntPtr[] v2) {
            fixed(IntPtr* v1_ = &v1[0])
            fixed(IntPtr* v2_ = &v2[0])
                Pointers.glRectxvOES(v1_, v2_);
        }
        
        public static void glReferencePlaneSGIX(double* equation) {
            Pointers.glReferencePlaneSGIX(equation);
        }
        
        public static void glReferencePlaneSGIX(double[] equation) {
            fixed(double* equation_ = &equation[0])
                Pointers.glReferencePlaneSGIX(equation_);
        }
        
        /// <summary>
        /// release resources consumed by the implementation's shader compiler
        /// <para>
        /// glReleaseShaderCompiler provides a hint to the implementation that it may free internal resources
        /// associated with its shader compiler. glCompileShader may subsequently be called and the
        /// implementation may at that time reallocate resources previously freed by the call to
        /// glReleaseShaderCompiler
        /// </para>
        /// </summary>
        public static void glReleaseShaderCompiler() {
            Pointers.glReleaseShaderCompiler();
        }
        
        public static void glRenderGpuMaskNV(uint mask) {
            Pointers.glRenderGpuMaskNV(mask);
        }
        
        /// <summary>
        /// set rasterization mode
        /// <para>
        /// glRenderMode sets the rasterization mode. It takes one argument, mode, which can assume one of three
        /// predefined values:
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies the rasterization mode. Three values are accepted: GL_RENDER, GL_SELECT, and GL_FEEDBACK.
        /// The initial value is GL_RENDER.
        /// </param>
        public static int glRenderMode(int mode) {
            return Pointers.glRenderMode(mode);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies a binding target of the allocation for glRenderbufferStorage function. Must be
        /// GL_RENDERBUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        public static void glRenderbufferStorage(int target, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorage(target, internalformat, width, height);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies a binding target of the allocation for glRenderbufferStorage function. Must be
        /// GL_RENDERBUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        public static void glRenderbufferStorageEXT(int target, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageEXT(target, internalformat, width, height);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be
        /// GL_RENDERBUFFER.
        /// </param>
        /// <param name="samples">
        /// Specifies the number of samples to be used for the renderbuffer object's storage.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        public static void glRenderbufferStorageMultisample(int target, int samples, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
        }
        
        public static void glRenderbufferStorageMultisampleANGLE(int target, int samples, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
        }
        
        public static void glRenderbufferStorageMultisampleAPPLE(int target, int samples, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);
        }
        
        public static void glRenderbufferStorageMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageMultisampleCoverageNV(target, coverageSamples, colorSamples, internalformat, width, height);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be
        /// GL_RENDERBUFFER.
        /// </param>
        /// <param name="samples">
        /// Specifies the number of samples to be used for the renderbuffer object's storage.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        public static void glRenderbufferStorageMultisampleEXT(int target, int samples, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
        }
        
        public static void glRenderbufferStorageMultisampleIMG(int target, int samples, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="target">
        /// Specifies a binding target of the allocation for glRenderbufferStorageMultisample function. Must be
        /// GL_RENDERBUFFER.
        /// </param>
        /// <param name="samples">
        /// Specifies the number of samples to be used for the renderbuffer object's storage.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format to use for the renderbuffer object's image.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the renderbuffer, in pixels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the renderbuffer, in pixels.
        /// </param>
        public static void glRenderbufferStorageMultisampleNV(int target, int samples, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageMultisampleNV(target, samples, internalformat, width, height);
        }
        
        public static void glRenderbufferStorageOES(int target, int internalformat, int width, int height) {
            Pointers.glRenderbufferStorageOES(target, internalformat, width, height);
        }
        
        public static void glReplacementCodePointerSUN(int type, int stride, IntPtr* pointer) {
            Pointers.glReplacementCodePointerSUN(type, stride, pointer);
        }
        
        public static void glReplacementCodePointerSUN(int type, int stride, IntPtr[] pointer) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glReplacementCodePointerSUN(type, stride, pointer_);
        }
        
        public static void glReplacementCodeubSUN(byte code) {
            Pointers.glReplacementCodeubSUN(code);
        }
        
        public static void glReplacementCodeubvSUN(byte* code) {
            Pointers.glReplacementCodeubvSUN(code);
        }
        
        public static void glReplacementCodeubvSUN(byte[] code) {
            fixed(byte* code_ = &code[0])
                Pointers.glReplacementCodeubvSUN(code_);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fSUN(uint rc, float r, float g, float b, float x, float y, float z) {
            Pointers.glReplacementCodeuiColor3fVertex3fSUN(rc, r, g, b, x, y, z);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(uint* rc, float* c, float* v) {
            Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(uint* rc, float* c, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc, c, v_);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(uint* rc, float[] c, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc, c_, v);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(uint* rc, float[] c, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc, c_, v_);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(out uint rc, float* c, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc_, c, v);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(out uint rc, float* c, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc_, c, v_);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(out uint rc, float[] c, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc_, c_, v);
        }
        
        public static void glReplacementCodeuiColor3fVertex3fvSUN(out uint rc, float[] c, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor3fVertex3fvSUN(rc_, c_, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fSUN(uint rc, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glReplacementCodeuiColor4fNormal3fVertex3fSUN(rc, r, g, b, a, nx, ny, nz, x, y, z);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float* c, float* n, float* v) {
            Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float* c, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float* c, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n_, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float* c, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c, n_, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float[] c, float* n, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c_, n, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float[] c, float* n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c_, n, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float[] c, float[] n, float* v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c_, n_, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(uint* rc, float[] c, float[] n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc, c_, n_, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float* c, float* n, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c, n, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float* c, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c, n, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float* c, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c, n_, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float* c, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c, n_, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float[] c, float* n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c_, n, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float[] c, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c_, n, v_);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float[] c, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c_, n_, v);
        }
        
        public static void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(out uint rc, float[] c, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4fNormal3fVertex3fvSUN(rc_, c_, n_, v_);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fSUN(uint rc, byte r, byte g, byte b, byte a, float x, float y, float z) {
            Pointers.glReplacementCodeuiColor4ubVertex3fSUN(rc, r, g, b, a, x, y, z);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(uint* rc, byte* c, float* v) {
            Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(uint* rc, byte* c, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc, c, v_);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(uint* rc, byte[] c, float* v) {
            fixed(byte* c_ = &c[0])
                Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc, c_, v);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(uint* rc, byte[] c, float[] v) {
            fixed(byte* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc, c_, v_);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(out uint rc, byte* c, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc_, c, v);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(out uint rc, byte* c, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc_, c, v_);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(out uint rc, byte[] c, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(byte* c_ = &c[0])
                Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc_, c_, v);
        }
        
        public static void glReplacementCodeuiColor4ubVertex3fvSUN(out uint rc, byte[] c, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(byte* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiColor4ubVertex3fvSUN(rc_, c_, v_);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fSUN(uint rc, float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glReplacementCodeuiNormal3fVertex3fSUN(rc, nx, ny, nz, x, y, z);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(uint* rc, float* n, float* v) {
            Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(uint* rc, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc, n, v_);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(uint* rc, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc, n_, v);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(uint* rc, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc, n_, v_);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(out uint rc, float* n, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc_, n, v);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(out uint rc, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc_, n, v_);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(out uint rc, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc_, n_, v);
        }
        
        public static void glReplacementCodeuiNormal3fVertex3fvSUN(out uint rc, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiNormal3fVertex3fvSUN(rc_, n_, v_);
        }
        
        public static void glReplacementCodeuiSUN(uint code) {
            Pointers.glReplacementCodeuiSUN(code);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(uint rc, float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(rc, s, t, r, g, b, a, nx, ny, nz, x, y, z);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float* c, float* n, float* v) {
            Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float* c, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float* c, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float* c, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float[] c, float* n, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c_, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float[] c, float* n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c_, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float[] c, float[] n, float* v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c_, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float* tc, float[] c, float[] n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc, c_, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float* c, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float* c, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float* c, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float* c, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float[] c, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c_, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float[] c, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c_, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float[] c, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c_, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(uint* rc, float[] tc, float[] c, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc, tc_, c_, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float* c, float* n, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float* c, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float* c, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float* c, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float[] c, float* n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c_, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float[] c, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c_, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float[] c, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c_, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float* tc, float[] c, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc, c_, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float* c, float* n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float* c, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float* c, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float* c, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float[] c, float* n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c_, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float[] c, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c_, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float[] c, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c_, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(out uint rc, float[] tc, float[] c, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(rc_, tc_, c_, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(uint rc, float s, float t, float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(rc, s, t, nx, ny, nz, x, y, z);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float* tc, float* n, float* v) {
            Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float* tc, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float* tc, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float* tc, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float[] tc, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc_, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float[] tc, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc_, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float[] tc, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc_, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(uint* rc, float[] tc, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc, tc_, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float* tc, float* n, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float* tc, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float* tc, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float* tc, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float[] tc, float* n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc_, n, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float[] tc, float* n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc_, n, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float[] tc, float[] n, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc_, n_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(out uint rc, float[] tc, float[] n, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(rc_, tc_, n_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fSUN(uint rc, float s, float t, float x, float y, float z) {
            Pointers.glReplacementCodeuiTexCoord2fVertex3fSUN(rc, s, t, x, y, z);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(uint* rc, float* tc, float* v) {
            Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(uint* rc, float* tc, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(uint* rc, float[] tc, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(uint* rc, float[] tc, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc, tc_, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(out uint rc, float* tc, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc_, tc, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(out uint rc, float* tc, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc_, tc, v_);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(out uint rc, float[] tc, float* v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
                Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc_, tc_, v);
        }
        
        public static void glReplacementCodeuiTexCoord2fVertex3fvSUN(out uint rc, float[] tc, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiTexCoord2fVertex3fvSUN(rc_, tc_, v_);
        }
        
        public static void glReplacementCodeuiVertex3fSUN(uint rc, float x, float y, float z) {
            Pointers.glReplacementCodeuiVertex3fSUN(rc, x, y, z);
        }
        
        public static void glReplacementCodeuiVertex3fvSUN(uint* rc, float* v) {
            Pointers.glReplacementCodeuiVertex3fvSUN(rc, v);
        }
        
        public static void glReplacementCodeuiVertex3fvSUN(uint* rc, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiVertex3fvSUN(rc, v_);
        }
        
        public static void glReplacementCodeuiVertex3fvSUN(out uint rc, float* v) {
            fixed(uint* rc_ = &rc)
                Pointers.glReplacementCodeuiVertex3fvSUN(rc_, v);
        }
        
        public static void glReplacementCodeuiVertex3fvSUN(out uint rc, float[] v) {
            fixed(uint* rc_ = &rc)
            fixed(float* v_ = &v[0])
                Pointers.glReplacementCodeuiVertex3fvSUN(rc_, v_);
        }
        
        public static void glReplacementCodeuivSUN(uint* code) {
            Pointers.glReplacementCodeuivSUN(code);
        }
        
        public static void glReplacementCodeuivSUN(uint[] code) {
            fixed(uint* code_ = &code[0])
                Pointers.glReplacementCodeuivSUN(code_);
        }
        
        public static void glReplacementCodeusSUN(ushort code) {
            Pointers.glReplacementCodeusSUN(code);
        }
        
        public static void glReplacementCodeusvSUN(ushort* code) {
            Pointers.glReplacementCodeusvSUN(code);
        }
        
        public static void glReplacementCodeusvSUN(ushort[] code) {
            fixed(ushort* code_ = &code[0])
                Pointers.glReplacementCodeusvSUN(code_);
        }
        
        public static void glRequestResidentProgramsNV(int n, uint* programs) {
            Pointers.glRequestResidentProgramsNV(n, programs);
        }
        
        public static void glRequestResidentProgramsNV(int n, uint[] programs) {
            fixed(uint* programs_ = &programs[0])
                Pointers.glRequestResidentProgramsNV(n, programs_);
        }
        
        /// <summary>
        /// reset histogram table entries to zero
        /// <para>
        /// glResetHistogram resets all the elements of the current histogram table to zero
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_HISTOGRAM.
        /// </param>
        public static void glResetHistogram(int target) {
            Pointers.glResetHistogram(target);
        }
        
        /// <summary>
        /// reset histogram table entries to zero
        /// <para>
        /// glResetHistogram resets all the elements of the current histogram table to zero
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_HISTOGRAM.
        /// </param>
        public static void glResetHistogramEXT(int target) {
            Pointers.glResetHistogramEXT(target);
        }
        
        /// <summary>
        /// reset minmax table entries to initial values
        /// <para>
        /// glResetMinmax resets the elements of the current minmax table to their initial values: the
        /// ``maximum'' element receives the minimum possible component values, and the ``minimum'' element
        /// receives the maximum possible component values
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_MINMAX.
        /// </param>
        public static void glResetMinmax(int target) {
            Pointers.glResetMinmax(target);
        }
        
        /// <summary>
        /// reset minmax table entries to initial values
        /// <para>
        /// glResetMinmax resets the elements of the current minmax table to their initial values: the
        /// ``maximum'' element receives the minimum possible component values, and the ``minimum'' element
        /// receives the maximum possible component values
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_MINMAX.
        /// </param>
        public static void glResetMinmaxEXT(int target) {
            Pointers.glResetMinmaxEXT(target);
        }
        
        public static void glResizeBuffersMESA() {
            Pointers.glResizeBuffersMESA();
        }
        
        public static void glResolveDepthValuesNV() {
            Pointers.glResolveDepthValuesNV();
        }
        
        public static void glResolveMultisampleFramebufferAPPLE() {
            Pointers.glResolveMultisampleFramebufferAPPLE();
        }
        
        /// <summary>
        /// resume transform feedback operations
        /// <para>
        /// glResumeTransformFeedback resumes transform feedback operations on the currently active transform
        /// feedback object. When transform feedback operations are paused, transform feedback is still
        /// considered active and changing most transform feedback state related to the object results in an
        /// error. However, a new transform feedback object may be bound while transform feedback is paused
        /// </para>
        /// </summary>
        public static void glResumeTransformFeedback() {
            Pointers.glResumeTransformFeedback();
        }
        
        /// <summary>
        /// resume transform feedback operations
        /// <para>
        /// glResumeTransformFeedback resumes transform feedback operations on the currently active transform
        /// feedback object. When transform feedback operations are paused, transform feedback is still
        /// considered active and changing most transform feedback state related to the object results in an
        /// error. However, a new transform feedback object may be bound while transform feedback is paused
        /// </para>
        /// </summary>
        public static void glResumeTransformFeedbackNV() {
            Pointers.glResumeTransformFeedbackNV();
        }
        
        /// <summary>
        /// multiply the current matrix by a rotation matrix
        /// <para>
        /// glRotate produces a rotation of angle degrees around the vector x y z . The current matrix (see
        /// glMatrixMode) is multiplied by a rotation matrix with the product replacing the current matrix, as
        /// if glMultMatrix were called with the following matrix as its argument:
        /// </para>
        /// </summary>
        /// <param name="angle">
        /// Specifies the angle of rotation, in degrees.
        /// </param>
        /// <param name="x">
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </param>
        public static void glRotated(double angle, double x, double y, double z) {
            Pointers.glRotated(angle, x, y, z);
        }
        
        /// <summary>
        /// multiply the current matrix by a rotation matrix
        /// <para>
        /// glRotate produces a rotation of angle degrees around the vector x y z . The current matrix (see
        /// glMatrixMode) is multiplied by a rotation matrix with the product replacing the current matrix, as
        /// if glMultMatrix were called with the following matrix as its argument:
        /// </para>
        /// </summary>
        /// <param name="angle">
        /// Specifies the angle of rotation, in degrees.
        /// </param>
        /// <param name="x">
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, and z coordinates of a vector, respectively.
        /// </param>
        public static void glRotatef(float angle, float x, float y, float z) {
            Pointers.glRotatef(angle, x, y, z);
        }
        
        public static void glRotatex(IntPtr angle, IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glRotatex(angle, x, y, z);
        }
        
        public static void glRotatexOES(IntPtr angle, IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glRotatexOES(angle, x, y, z);
        }
        
        /// <summary>
        /// specify multisample coverage parameters
        /// <para>
        /// Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations
        /// to generate antialiasing effects. Multisampling transparently antialiases points, lines, polygons,
        /// and images if it is enabled
        /// </para>
        /// </summary>
        /// <param name="value">
        /// Specify a single floating-point sample coverage value. The value is clamped to the range 0 1 . The
        /// initial value is 1.0.
        /// </param>
        /// <param name="invert">
        /// Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and
        /// GL_FALSE are accepted. The initial value is GL_FALSE.
        /// </param>
        public static void glSampleCoverage(float value, bool invert) {
            Pointers.glSampleCoverage(value, invert);
        }
        
        /// <summary>
        /// specify multisample coverage parameters
        /// <para>
        /// Multisampling samples a pixel multiple times at various implementation-dependent subpixel locations
        /// to generate antialiasing effects. Multisampling transparently antialiases points, lines, polygons,
        /// and images if it is enabled
        /// </para>
        /// </summary>
        /// <param name="value">
        /// Specify a single floating-point sample coverage value. The value is clamped to the range 0 1 . The
        /// initial value is 1.0.
        /// </param>
        /// <param name="invert">
        /// Specify a single boolean value representing if the coverage masks should be inverted. GL_TRUE and
        /// GL_FALSE are accepted. The initial value is GL_FALSE.
        /// </param>
        public static void glSampleCoverageARB(float value, bool invert) {
            Pointers.glSampleCoverageARB(value, invert);
        }
        
        public static void glSampleCoveragex(int value, bool invert) {
            Pointers.glSampleCoveragex(value, invert);
        }
        
        public static void glSampleCoveragexOES(int value, bool invert) {
            Pointers.glSampleCoveragexOES(value, invert);
        }
        
        public static void glSampleMapATI(uint dst, uint interp, int swizzle) {
            Pointers.glSampleMapATI(dst, interp, swizzle);
        }
        
        public static void glSampleMaskEXT(float value, bool invert) {
            Pointers.glSampleMaskEXT(value, invert);
        }
        
        public static void glSampleMaskIndexedNV(uint index, uint mask) {
            Pointers.glSampleMaskIndexedNV(index, mask);
        }
        
        public static void glSampleMaskSGIS(float value, bool invert) {
            Pointers.glSampleMaskSGIS(value, invert);
        }
        
        /// <summary>
        /// set the value of a sub-word of the sample mask
        /// <para>
        /// glSampleMaski sets one 32-bit sub-word of the multi-word sample mask, GL_SAMPLE_MASK_VALUE
        /// </para>
        /// </summary>
        /// <param name="maskNumber">
        /// Specifies which 32-bit sub-word of the sample mask to update.
        /// </param>
        /// <param name="mask">
        /// Specifies the new value of the mask sub-word.
        /// </param>
        public static void glSampleMaski(uint maskNumber, uint mask) {
            Pointers.glSampleMaski(maskNumber, mask);
        }
        
        public static void glSamplePatternEXT(int pattern) {
            Pointers.glSamplePatternEXT(pattern);
        }
        
        public static void glSamplePatternSGIS(int pattern) {
            Pointers.glSamplePatternSGIS(pattern);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIiv(uint sampler, int pname, int* param) {
            Pointers.glSamplerParameterIiv(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIiv(uint sampler, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glSamplerParameterIiv(sampler, pname, param_);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIivEXT(uint sampler, int pname, int* param) {
            Pointers.glSamplerParameterIivEXT(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIivEXT(uint sampler, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glSamplerParameterIivEXT(sampler, pname, param_);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIivOES(uint sampler, int pname, int* param) {
            Pointers.glSamplerParameterIivOES(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIivOES(uint sampler, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glSamplerParameterIivOES(sampler, pname, param_);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIuiv(uint sampler, int pname, uint* param) {
            Pointers.glSamplerParameterIuiv(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIuiv(uint sampler, int pname, uint[] param) {
            fixed(uint* param_ = &param[0])
                Pointers.glSamplerParameterIuiv(sampler, pname, param_);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIuivEXT(uint sampler, int pname, uint* param) {
            Pointers.glSamplerParameterIuivEXT(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIuivEXT(uint sampler, int pname, uint[] param) {
            fixed(uint* param_ = &param[0])
                Pointers.glSamplerParameterIuivEXT(sampler, pname, param_);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIuivOES(uint sampler, int pname, uint* param) {
            Pointers.glSamplerParameterIuivOES(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterIuivOES(uint sampler, int pname, uint[] param) {
            fixed(uint* param_ = &param[0])
                Pointers.glSamplerParameterIuivOES(sampler, pname, param_);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        public static void glSamplerParameterf(uint sampler, int pname, float param) {
            Pointers.glSamplerParameterf(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterfv(uint sampler, int pname, float* param) {
            Pointers.glSamplerParameterfv(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameterfv(uint sampler, int pname, float[] param) {
            fixed(float* param_ = &param[0])
                Pointers.glSamplerParameterfv(sampler, pname, param_);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        public static void glSamplerParameteri(uint sampler, int pname, int param) {
            Pointers.glSamplerParameteri(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameteriv(uint sampler, int pname, int* param) {
            Pointers.glSamplerParameteriv(sampler, pname, param);
        }
        
        /// <summary>
        /// set sampler parameters
        /// <para>
        /// glSamplerParameter assigns the value or values in params to the sampler parameter specified as
        /// pname. sampler specifies the sampler object to be modified, and must be the name of a sampler object
        /// previously returned from a call to glGenSamplers. The following symbols are accepted in pname:
        /// </para>
        /// </summary>
        /// <param name="sampler">
        /// Specifies the sampler object whose parameter to modify.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a sampler parameter. pname can be one of the following:
        /// GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, GL_TEXTURE_WRAP_R, GL_TEXTURE_MIN_FILTER,
        /// GL_TEXTURE_MAG_FILTER, GL_TEXTURE_BORDER_COLOR, GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD,
        /// GL_TEXTURE_LOD_BIAS GL_TEXTURE_COMPARE_MODE, or GL_TEXTURE_COMPARE_FUNC.
        /// </param>
        /// <param name="param">
        /// For the vector commands (glSamplerParameter*v), specifies a pointer to an array where the value or
        /// values of pname are stored.
        /// </param>
        public static void glSamplerParameteriv(uint sampler, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glSamplerParameteriv(sampler, pname, param_);
        }
        
        /// <summary>
        /// multiply the current matrix by a general scaling matrix
        /// <para>
        /// glScale produces a nonuniform scaling along the x, y, and z axes. The three parameters indicate the
        /// desired scale factor along each of the three axes
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify scale factors along the x, y, and z axes, respectively.
        /// </param>
        /// <param name="y">
        /// Specify scale factors along the x, y, and z axes, respectively.
        /// </param>
        /// <param name="z">
        /// Specify scale factors along the x, y, and z axes, respectively.
        /// </param>
        public static void glScaled(double x, double y, double z) {
            Pointers.glScaled(x, y, z);
        }
        
        /// <summary>
        /// multiply the current matrix by a general scaling matrix
        /// <para>
        /// glScale produces a nonuniform scaling along the x, y, and z axes. The three parameters indicate the
        /// desired scale factor along each of the three axes
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify scale factors along the x, y, and z axes, respectively.
        /// </param>
        /// <param name="y">
        /// Specify scale factors along the x, y, and z axes, respectively.
        /// </param>
        /// <param name="z">
        /// Specify scale factors along the x, y, and z axes, respectively.
        /// </param>
        public static void glScalef(float x, float y, float z) {
            Pointers.glScalef(x, y, z);
        }
        
        public static void glScalex(IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glScalex(x, y, z);
        }
        
        public static void glScalexOES(IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glScalexOES(x, y, z);
        }
        
        /// <summary>
        /// define the scissor box
        /// <para>
        /// glScissor defines a rectangle, called the scissor box, in window coordinates. The first two
        /// arguments, x and y, specify the lower left corner of the box. width and height specify the width and
        /// height of the box
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the lower left corner of the scissor box. Initially (0, 0).
        /// </param>
        /// <param name="y">
        /// Specify the lower left corner of the scissor box. Initially (0, 0).
        /// </param>
        /// <param name="width">
        /// Specify the width and height of the scissor box. When a GL context is first attached to a window,
        /// width and height are set to the dimensions of that window.
        /// </param>
        /// <param name="height">
        /// Specify the width and height of the scissor box. When a GL context is first attached to a window,
        /// width and height are set to the dimensions of that window.
        /// </param>
        public static void glScissor(int x, int y, int width, int height) {
            Pointers.glScissor(x, y, width, height);
        }
        
        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>
        /// glScissorArrayv defines rectangles, called scissor boxes, in window coordinates for each viewport.
        /// first specifies the index of the first scissor box to modify and count specifies the number of
        /// scissor boxes to modify. first must be less than the value of GL_MAX_VIEWPORTS, and first + count
        /// must be less than or equal to the value of GL_MAX_VIEWPORTS. v specifies the address of an array
        /// containing integers specifying the lower left corner of the scissor boxes, and the width and height
        /// of the scissor boxes, in that order
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose scissor box to modify.
        /// </param>
        /// <param name="count">
        /// Specifies the number of scissor boxes to modify.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the left, bottom, width and height of each scissor box,
        /// in that order.
        /// </param>
        public static void glScissorArrayv(uint first, int count, int* v) {
            Pointers.glScissorArrayv(first, count, v);
        }
        
        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>
        /// glScissorArrayv defines rectangles, called scissor boxes, in window coordinates for each viewport.
        /// first specifies the index of the first scissor box to modify and count specifies the number of
        /// scissor boxes to modify. first must be less than the value of GL_MAX_VIEWPORTS, and first + count
        /// must be less than or equal to the value of GL_MAX_VIEWPORTS. v specifies the address of an array
        /// containing integers specifying the lower left corner of the scissor boxes, and the width and height
        /// of the scissor boxes, in that order
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose scissor box to modify.
        /// </param>
        /// <param name="count">
        /// Specifies the number of scissor boxes to modify.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the left, bottom, width and height of each scissor box,
        /// in that order.
        /// </param>
        public static void glScissorArrayv(uint first, int count, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glScissorArrayv(first, count, v_);
        }
        
        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>
        /// glScissorArrayv defines rectangles, called scissor boxes, in window coordinates for each viewport.
        /// first specifies the index of the first scissor box to modify and count specifies the number of
        /// scissor boxes to modify. first must be less than the value of GL_MAX_VIEWPORTS, and first + count
        /// must be less than or equal to the value of GL_MAX_VIEWPORTS. v specifies the address of an array
        /// containing integers specifying the lower left corner of the scissor boxes, and the width and height
        /// of the scissor boxes, in that order
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose scissor box to modify.
        /// </param>
        /// <param name="count">
        /// Specifies the number of scissor boxes to modify.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the left, bottom, width and height of each scissor box,
        /// in that order.
        /// </param>
        public static void glScissorArrayvNV(uint first, int count, int* v) {
            Pointers.glScissorArrayvNV(first, count, v);
        }
        
        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>
        /// glScissorArrayv defines rectangles, called scissor boxes, in window coordinates for each viewport.
        /// first specifies the index of the first scissor box to modify and count specifies the number of
        /// scissor boxes to modify. first must be less than the value of GL_MAX_VIEWPORTS, and first + count
        /// must be less than or equal to the value of GL_MAX_VIEWPORTS. v specifies the address of an array
        /// containing integers specifying the lower left corner of the scissor boxes, and the width and height
        /// of the scissor boxes, in that order
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose scissor box to modify.
        /// </param>
        /// <param name="count">
        /// Specifies the number of scissor boxes to modify.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the left, bottom, width and height of each scissor box,
        /// in that order.
        /// </param>
        public static void glScissorArrayvNV(uint first, int count, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glScissorArrayvNV(first, count, v_);
        }
        
        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>
        /// glScissorArrayv defines rectangles, called scissor boxes, in window coordinates for each viewport.
        /// first specifies the index of the first scissor box to modify and count specifies the number of
        /// scissor boxes to modify. first must be less than the value of GL_MAX_VIEWPORTS, and first + count
        /// must be less than or equal to the value of GL_MAX_VIEWPORTS. v specifies the address of an array
        /// containing integers specifying the lower left corner of the scissor boxes, and the width and height
        /// of the scissor boxes, in that order
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose scissor box to modify.
        /// </param>
        /// <param name="count">
        /// Specifies the number of scissor boxes to modify.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the left, bottom, width and height of each scissor box,
        /// in that order.
        /// </param>
        public static void glScissorArrayvOES(uint first, int count, int* v) {
            Pointers.glScissorArrayvOES(first, count, v);
        }
        
        /// <summary>
        /// define the scissor box for multiple viewports
        /// <para>
        /// glScissorArrayv defines rectangles, called scissor boxes, in window coordinates for each viewport.
        /// first specifies the index of the first scissor box to modify and count specifies the number of
        /// scissor boxes to modify. first must be less than the value of GL_MAX_VIEWPORTS, and first + count
        /// must be less than or equal to the value of GL_MAX_VIEWPORTS. v specifies the address of an array
        /// containing integers specifying the lower left corner of the scissor boxes, and the width and height
        /// of the scissor boxes, in that order
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specifies the index of the first viewport whose scissor box to modify.
        /// </param>
        /// <param name="count">
        /// Specifies the number of scissor boxes to modify.
        /// </param>
        /// <param name="v">
        /// Specifies the address of an array containing the left, bottom, width and height of each scissor box,
        /// in that order.
        /// </param>
        public static void glScissorArrayvOES(uint first, int count, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glScissorArrayvOES(first, count, v_);
        }
        
        /// <summary>
        /// define the scissor box for a specific viewport
        /// <para>
        /// glScissorIndexed defines the scissor box for a specified viewport. index specifies the index of
        /// scissor box to modify. index must be less than the value of GL_MAX_VIEWPORTS. For glScissorIndexed,
        /// left, bottom, width and height specify the left, bottom, width and height of the scissor box, in
        /// pixels, respectively. For glScissorIndexedv, v specifies the address of an array containing integers
        /// specifying the lower left corner of the scissor box, and the width and height of the scissor box, in
        /// that order
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the viewport whose scissor box to modify.
        /// </param>
        /// <param name="left">
        /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
        /// </param>
        /// <param name="width">
        /// Specify ths dimensions of the scissor box, in pixels.
        /// </param>
        /// <param name="height">
        /// Specify ths dimensions of the scissor box, in pixels.
        /// </param>
        public static void glScissorIndexed(uint index, int left, int bottom, int width, int height) {
            Pointers.glScissorIndexed(index, left, bottom, width, height);
        }
        
        /// <summary>
        /// define the scissor box for a specific viewport
        /// <para>
        /// glScissorIndexed defines the scissor box for a specified viewport. index specifies the index of
        /// scissor box to modify. index must be less than the value of GL_MAX_VIEWPORTS. For glScissorIndexed,
        /// left, bottom, width and height specify the left, bottom, width and height of the scissor box, in
        /// pixels, respectively. For glScissorIndexedv, v specifies the address of an array containing integers
        /// specifying the lower left corner of the scissor box, and the width and height of the scissor box, in
        /// that order
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the viewport whose scissor box to modify.
        /// </param>
        /// <param name="left">
        /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
        /// </param>
        /// <param name="width">
        /// Specify ths dimensions of the scissor box, in pixels.
        /// </param>
        /// <param name="height">
        /// Specify ths dimensions of the scissor box, in pixels.
        /// </param>
        public static void glScissorIndexedNV(uint index, int left, int bottom, int width, int height) {
            Pointers.glScissorIndexedNV(index, left, bottom, width, height);
        }
        
        /// <summary>
        /// define the scissor box for a specific viewport
        /// <para>
        /// glScissorIndexed defines the scissor box for a specified viewport. index specifies the index of
        /// scissor box to modify. index must be less than the value of GL_MAX_VIEWPORTS. For glScissorIndexed,
        /// left, bottom, width and height specify the left, bottom, width and height of the scissor box, in
        /// pixels, respectively. For glScissorIndexedv, v specifies the address of an array containing integers
        /// specifying the lower left corner of the scissor box, and the width and height of the scissor box, in
        /// that order
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the viewport whose scissor box to modify.
        /// </param>
        /// <param name="left">
        /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
        /// </param>
        /// <param name="bottom">
        /// Specify the coordinate of the bottom left corner of the scissor box, in pixels.
        /// </param>
        /// <param name="width">
        /// Specify ths dimensions of the scissor box, in pixels.
        /// </param>
        /// <param name="height">
        /// Specify ths dimensions of the scissor box, in pixels.
        /// </param>
        public static void glScissorIndexedOES(uint index, int left, int bottom, int width, int height) {
            Pointers.glScissorIndexedOES(index, left, bottom, width, height);
        }
        
        public static void glScissorIndexedv(uint index, int* v) {
            Pointers.glScissorIndexedv(index, v);
        }
        
        public static void glScissorIndexedv(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glScissorIndexedv(index, v_);
        }
        
        public static void glScissorIndexedvNV(uint index, int* v) {
            Pointers.glScissorIndexedvNV(index, v);
        }
        
        public static void glScissorIndexedvNV(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glScissorIndexedvNV(index, v_);
        }
        
        public static void glScissorIndexedvOES(uint index, int* v) {
            Pointers.glScissorIndexedvOES(index, v);
        }
        
        public static void glScissorIndexedvOES(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glScissorIndexedvOES(index, v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3b(sbyte red, sbyte green, sbyte blue) {
            Pointers.glSecondaryColor3b(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3bEXT(sbyte red, sbyte green, sbyte blue) {
            Pointers.glSecondaryColor3bEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3bv(sbyte* v) {
            Pointers.glSecondaryColor3bv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3bv(sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glSecondaryColor3bv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3bvEXT(sbyte* v) {
            Pointers.glSecondaryColor3bvEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3bvEXT(sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glSecondaryColor3bvEXT(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3d(double red, double green, double blue) {
            Pointers.glSecondaryColor3d(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3dEXT(double red, double green, double blue) {
            Pointers.glSecondaryColor3dEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3dv(double* v) {
            Pointers.glSecondaryColor3dv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glSecondaryColor3dv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3dvEXT(double* v) {
            Pointers.glSecondaryColor3dvEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3dvEXT(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glSecondaryColor3dvEXT(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3f(float red, float green, float blue) {
            Pointers.glSecondaryColor3f(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3fEXT(float red, float green, float blue) {
            Pointers.glSecondaryColor3fEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3fv(float* v) {
            Pointers.glSecondaryColor3fv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glSecondaryColor3fv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3fvEXT(float* v) {
            Pointers.glSecondaryColor3fvEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3fvEXT(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glSecondaryColor3fvEXT(v_);
        }
        
        public static void glSecondaryColor3hNV(short red, short green, short blue) {
            Pointers.glSecondaryColor3hNV(red, green, blue);
        }
        
        public static void glSecondaryColor3hvNV(short* v) {
            Pointers.glSecondaryColor3hvNV(v);
        }
        
        public static void glSecondaryColor3hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glSecondaryColor3hvNV(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3i(int red, int green, int blue) {
            Pointers.glSecondaryColor3i(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3iEXT(int red, int green, int blue) {
            Pointers.glSecondaryColor3iEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3iv(int* v) {
            Pointers.glSecondaryColor3iv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glSecondaryColor3iv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3ivEXT(int* v) {
            Pointers.glSecondaryColor3ivEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3ivEXT(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glSecondaryColor3ivEXT(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3s(short red, short green, short blue) {
            Pointers.glSecondaryColor3s(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3sEXT(short red, short green, short blue) {
            Pointers.glSecondaryColor3sEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3sv(short* v) {
            Pointers.glSecondaryColor3sv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glSecondaryColor3sv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3svEXT(short* v) {
            Pointers.glSecondaryColor3svEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3svEXT(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glSecondaryColor3svEXT(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3ub(byte red, byte green, byte blue) {
            Pointers.glSecondaryColor3ub(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3ubEXT(byte red, byte green, byte blue) {
            Pointers.glSecondaryColor3ubEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3ubv(byte* v) {
            Pointers.glSecondaryColor3ubv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3ubv(byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glSecondaryColor3ubv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3ubvEXT(byte* v) {
            Pointers.glSecondaryColor3ubvEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3ubvEXT(byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glSecondaryColor3ubvEXT(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3ui(uint red, uint green, uint blue) {
            Pointers.glSecondaryColor3ui(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3uiEXT(uint red, uint green, uint blue) {
            Pointers.glSecondaryColor3uiEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3uiv(uint* v) {
            Pointers.glSecondaryColor3uiv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3uiv(uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glSecondaryColor3uiv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3uivEXT(uint* v) {
            Pointers.glSecondaryColor3uivEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3uivEXT(uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glSecondaryColor3uivEXT(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3us(ushort red, ushort green, ushort blue) {
            Pointers.glSecondaryColor3us(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="red">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="green">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        /// <param name="blue">
        /// Specify new red, green, and blue values for the current secondary color.
        /// </param>
        public static void glSecondaryColor3usEXT(ushort red, ushort green, ushort blue) {
            Pointers.glSecondaryColor3usEXT(red, green, blue);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3usv(ushort* v) {
            Pointers.glSecondaryColor3usv(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3usv(ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glSecondaryColor3usv(v_);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3usvEXT(ushort* v) {
            Pointers.glSecondaryColor3usvEXT(v);
        }
        
        /// <summary>
        /// set the current secondary color
        /// <para>
        /// The GL stores both a primary four-valued RGBA color and a secondary four-valued RGBA color (where
        /// alpha is always set to 0.0) that is associated with every vertex
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array that contains red, green, blue.
        /// </param>
        public static void glSecondaryColor3usvEXT(ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glSecondaryColor3usvEXT(v_);
        }
        
        public static void glSecondaryColorFormatNV(int size, int type, int stride) {
            Pointers.glSecondaryColorFormatNV(size, type, stride);
        }
        
        public static void glSecondaryColorP3ui(int type, uint color) {
            Pointers.glSecondaryColorP3ui(type, color);
        }
        
        public static void glSecondaryColorP3uiv(int type, uint* color) {
            Pointers.glSecondaryColorP3uiv(type, color);
        }
        
        public static void glSecondaryColorP3uiv(int type, out uint color) {
            fixed(uint* color_ = &color)
                Pointers.glSecondaryColorP3uiv(type, color_);
        }
        
        /// <summary>
        /// define an array of secondary colors
        /// <para>
        /// glSecondaryColorPointer specifies the location and data format of an array of color components to
        /// use when rendering. size specifies the number of components per color, and must be 3. type specifies
        /// the data type of each color component, and stride specifies the byte stride from one color to the
        /// next, allowing vertices and attributes to be packed into a single array or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the number of components per color. Must be 3.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE,
        /// GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are
        /// accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to
        /// be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first component of the first color element in the array. The initial
        /// value is 0.
        /// </param>
        public static void glSecondaryColorPointer(int size, int type, int stride, IntPtr pointer) {
            Pointers.glSecondaryColorPointer(size, type, stride, pointer);
        }
        
        /// <summary>
        /// define an array of secondary colors
        /// <para>
        /// glSecondaryColorPointer specifies the location and data format of an array of color components to
        /// use when rendering. size specifies the number of components per color, and must be 3. type specifies
        /// the data type of each color component, and stride specifies the byte stride from one color to the
        /// next, allowing vertices and attributes to be packed into a single array or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the number of components per color. Must be 3.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each color component in the array. Symbolic constants GL_BYTE,
        /// GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_FLOAT, or GL_DOUBLE are
        /// accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive colors. If stride is 0, the colors are understood to
        /// be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first component of the first color element in the array. The initial
        /// value is 0.
        /// </param>
        public static void glSecondaryColorPointerEXT(int size, int type, int stride, IntPtr pointer) {
            Pointers.glSecondaryColorPointerEXT(size, type, stride, pointer);
        }
        
        public static void glSecondaryColorPointerListIBM(int size, int type, int stride, IntPtr* pointer, int ptrstride) {
            Pointers.glSecondaryColorPointerListIBM(size, type, stride, pointer, ptrstride);
        }
        
        public static void glSecondaryColorPointerListIBM(int size, int type, int stride, IntPtr[] pointer, int ptrstride) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glSecondaryColorPointerListIBM(size, type, stride, pointer_, ptrstride);
        }
        
        /// <summary>
        /// establish a buffer for selection mode values
        /// <para>
        /// glSelectBuffer has two arguments: buffer is a pointer to an array of unsigned integers, and size
        /// indicates the size of the array. buffer returns values from the name stack (see glInitNames,
        /// glLoadName, glPushName) when the rendering mode is GL_SELECT (see glRenderMode). glSelectBuffer must
        /// be issued before selection mode is enabled, and it must not be issued while the rendering mode is
        /// GL_SELECT
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the size of buffer.
        /// </param>
        /// <param name="buffer">
        /// Returns the selection data.
        /// </param>
        public static void glSelectBuffer(int size, uint* buffer) {
            Pointers.glSelectBuffer(size, buffer);
        }
        
        /// <summary>
        /// establish a buffer for selection mode values
        /// <para>
        /// glSelectBuffer has two arguments: buffer is a pointer to an array of unsigned integers, and size
        /// indicates the size of the array. buffer returns values from the name stack (see glInitNames,
        /// glLoadName, glPushName) when the rendering mode is GL_SELECT (see glRenderMode). glSelectBuffer must
        /// be issued before selection mode is enabled, and it must not be issued while the rendering mode is
        /// GL_SELECT
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the size of buffer.
        /// </param>
        /// <param name="buffer">
        /// Returns the selection data.
        /// </param>
        public static void glSelectBuffer(int size, uint[] buffer) {
            fixed(uint* buffer_ = &buffer[0])
                Pointers.glSelectBuffer(size, buffer_);
        }
        
        public static void glSelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, uint* counterList) {
            Pointers.glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList);
        }
        
        public static void glSelectPerfMonitorCountersAMD(uint monitor, bool enable, uint group, int numCounters, uint[] counterList) {
            fixed(uint* counterList_ = &counterList[0])
                Pointers.glSelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, counterList_);
        }
        
        public static void glSemaphoreParameterui64vEXT(uint semaphore, int pname, ulong* _params) {
            Pointers.glSemaphoreParameterui64vEXT(semaphore, pname, _params);
        }
        
        public static void glSemaphoreParameterui64vEXT(uint semaphore, int pname, ulong[] _params) {
            fixed(ulong* _params_ = &_params[0])
                Pointers.glSemaphoreParameterui64vEXT(semaphore, pname, _params_);
        }
        
        /// <summary>
        /// define a separable two-dimensional convolution filter
        /// <para>
        /// glSeparableFilter2D builds a two-dimensional separable convolution filter kernel from two arrays of
        /// pixels
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_SEPARABLE_2D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable
        /// filter kernel.)
        /// </param>
        /// <param name="height">
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable
        /// filter kernel.)
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE,
        /// GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="row">
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable
        /// filter kernel.)
        /// </param>
        /// <param name="column">
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE,
        /// GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </param>
        public static void glSeparableFilter2D(int target, int internalformat, int width, int height, int format, int type, IntPtr row, IntPtr column) {
            Pointers.glSeparableFilter2D(target, internalformat, width, height, format, type, row, column);
        }
        
        /// <summary>
        /// define a separable two-dimensional convolution filter
        /// <para>
        /// glSeparableFilter2D builds a two-dimensional separable convolution filter kernel from two arrays of
        /// pixels
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Must be GL_SEPARABLE_2D.
        /// </param>
        /// <param name="internalformat">
        /// The internal format of the convolution filter kernel. The allowable values are GL_ALPHA, GL_ALPHA4,
        /// GL_ALPHA8, GL_ALPHA12, GL_ALPHA16, GL_LUMINANCE, GL_LUMINANCE4, GL_LUMINANCE8, GL_LUMINANCE12,
        /// GL_LUMINANCE16, GL_LUMINANCE_ALPHA, GL_LUMINANCE4_ALPHA4, GL_LUMINANCE6_ALPHA2,
        /// GL_LUMINANCE8_ALPHA8, GL_LUMINANCE12_ALPHA4, GL_LUMINANCE12_ALPHA12, GL_LUMINANCE16_ALPHA16,
        /// GL_INTENSITY, GL_INTENSITY4, GL_INTENSITY8, GL_INTENSITY12, GL_INTENSITY16, GL_R3_G3_B2, GL_RGB,
        /// GL_RGB4, GL_RGB5, GL_RGB8, GL_RGB10, GL_RGB12, GL_RGB16, GL_RGBA, GL_RGBA2, GL_RGBA4, GL_RGB5_A1,
        /// GL_RGBA8, GL_RGB10_A2, GL_RGBA12, or GL_RGBA16.
        /// </param>
        /// <param name="width">
        /// The number of elements in the pixel array referenced by row. (This is the width of the separable
        /// filter kernel.)
        /// </param>
        /// <param name="height">
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable
        /// filter kernel.)
        /// </param>
        /// <param name="format">
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE,
        /// GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </param>
        /// <param name="type">
        /// The type of the pixel data in row and column. Symbolic constants GL_UNSIGNED_BYTE, GL_BYTE,
        /// GL_BITMAP, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT, GL_UNSIGNED_BYTE_3_3_2,
        /// GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV,
        /// GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1,
        /// GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV,
        /// GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV are accepted.
        /// </param>
        /// <param name="row">
        /// The number of elements in the pixel array referenced by column. (This is the height of the separable
        /// filter kernel.)
        /// </param>
        /// <param name="column">
        /// The format of the pixel data in row and column. The allowable values are GL_RED, GL_GREEN, GL_BLUE,
        /// GL_ALPHA, GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_INTENSITY, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.
        /// </param>
        public static void glSeparableFilter2DEXT(int target, int internalformat, int width, int height, int format, int type, IntPtr row, IntPtr column) {
            Pointers.glSeparableFilter2DEXT(target, internalformat, width, height, format, type, row, column);
        }
        
        public static void glSetFenceAPPLE(uint fence) {
            Pointers.glSetFenceAPPLE(fence);
        }
        
        public static void glSetFenceNV(uint fence, int condition) {
            Pointers.glSetFenceNV(fence, condition);
        }
        
        public static void glSetFragmentShaderConstantATI(uint dst, float* value) {
            Pointers.glSetFragmentShaderConstantATI(dst, value);
        }
        
        public static void glSetFragmentShaderConstantATI(uint dst, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glSetFragmentShaderConstantATI(dst, value_);
        }
        
        public static void glSetInvariantEXT(uint id, int type, IntPtr addr) {
            Pointers.glSetInvariantEXT(id, type, addr);
        }
        
        public static void glSetLocalConstantEXT(uint id, int type, IntPtr addr) {
            Pointers.glSetLocalConstantEXT(id, type, addr);
        }
        
        public static void glSetMultisamplefvAMD(int pname, uint index, float* val) {
            Pointers.glSetMultisamplefvAMD(pname, index, val);
        }
        
        public static void glSetMultisamplefvAMD(int pname, uint index, float[] val) {
            fixed(float* val_ = &val[0])
                Pointers.glSetMultisamplefvAMD(pname, index, val_);
        }
        
        /// <summary>
        /// select flat or smooth shading
        /// <para>
        /// GL primitives can have either flat or smooth shading. Smooth shading, the default, causes the
        /// computed colors of vertices to be interpolated as the primitive is rasterized, typically assigning
        /// different colors to each resulting pixel fragment. Flat shading selects the computed color of just
        /// one vertex and assigns it to all the pixel fragments generated by rasterizing a single primitive. In
        /// either case, the computed color of a vertex is the result of lighting if lighting is enabled, or it
        /// is the current color at the time the vertex was specified if lighting is disabled
        /// </para>
        /// </summary>
        /// <param name="mode">
        /// Specifies a symbolic value representing a shading technique. Accepted values are GL_FLAT and
        /// GL_SMOOTH. The initial value is GL_SMOOTH.
        /// </param>
        public static void glShadeModel(int mode) {
            Pointers.glShadeModel(mode);
        }
        
        /// <summary>
        /// load pre-compiled shader binaries
        /// <para>
        /// glShaderBinary loads pre-compiled shader binary code into the count shader objects whose handles are
        /// given in shaders. binary points to length bytes of binary shader code stored in client memory.
        /// binaryFormat specifies the format of the pre-compiled code
        /// </para>
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        public static void glShaderBinary(int count, uint* shaders, int binaryformat, IntPtr binary, int length) {
            Pointers.glShaderBinary(count, shaders, binaryformat, binary, length);
        }
        
        /// <summary>
        /// load pre-compiled shader binaries
        /// <para>
        /// glShaderBinary loads pre-compiled shader binary code into the count shader objects whose handles are
        /// given in shaders. binary points to length bytes of binary shader code stored in client memory.
        /// binaryFormat specifies the format of the pre-compiled code
        /// </para>
        /// </summary>
        /// <param name="count">
        /// Specifies the number of shader object handles contained in shaders.
        /// </param>
        /// <param name="shaders">
        /// Specifies the address of an array of shader handles into which to load pre-compiled shader binaries.
        /// </param>
        /// <param name="binaryformat">
        /// Specifies the format of the shader binaries contained in binary.
        /// </param>
        /// <param name="binary">
        /// Specifies the address of an array of bytes containing pre-compiled binary shader code.
        /// </param>
        /// <param name="length">
        /// Specifies the length of the array whose address is given in binary.
        /// </param>
        public static void glShaderBinary(int count, uint[] shaders, int binaryformat, IntPtr binary, int length) {
            fixed(uint* shaders_ = &shaders[0])
                Pointers.glShaderBinary(count, shaders_, binaryformat, binary, length);
        }
        
        public static void glShaderOp1EXT(int op, uint res, uint arg1) {
            Pointers.glShaderOp1EXT(op, res, arg1);
        }
        
        public static void glShaderOp2EXT(int op, uint res, uint arg1, uint arg2) {
            Pointers.glShaderOp2EXT(op, res, arg1, arg2);
        }
        
        public static void glShaderOp3EXT(int op, uint res, uint arg1, uint arg2, uint arg3) {
            Pointers.glShaderOp3EXT(op, res, arg1, arg2, arg3);
        }
        
        /// <summary>
        /// Replaces the source code in a shader object
        /// <para>
        /// glShaderSource sets the source code in shader to the source code in the array of strings specified
        /// by string. Any source code previously stored in the shader object is completely replaced. The number
        /// of strings in the array is specified by count. If length is NULL, each string is assumed to be null
        /// terminated. If length is a value other than NULL, it points to an array containing a string length
        /// for each of the corresponding elements of string. Each element in the length array may contain the
        /// length of the corresponding string (the null character is not counted as part of the string length)
        /// or a value less than 0 to indicate that the string is null terminated. The source code strings are
        /// not scanned or parsed at this time; they are simply copied into the specified shader object
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="_string">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        public static void glShaderSource(uint shader, int count, string[] _string, int* length) {
            Pointers.glShaderSource(shader, count, _string, length);
        }
        
        /// <summary>
        /// Replaces the source code in a shader object
        /// <para>
        /// glShaderSource sets the source code in shader to the source code in the array of strings specified
        /// by string. Any source code previously stored in the shader object is completely replaced. The number
        /// of strings in the array is specified by count. If length is NULL, each string is assumed to be null
        /// terminated. If length is a value other than NULL, it points to an array containing a string length
        /// for each of the corresponding elements of string. Each element in the length array may contain the
        /// length of the corresponding string (the null character is not counted as part of the string length)
        /// or a value less than 0 to indicate that the string is null terminated. The source code strings are
        /// not scanned or parsed at this time; they are simply copied into the specified shader object
        /// </para>
        /// </summary>
        /// <param name="shader">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="_string">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        public static void glShaderSource(uint shader, int count, string[] _string, int[] length) {
            fixed(int* length_ = &length[0])
                Pointers.glShaderSource(shader, count, _string, length_);
        }
        
        /// <summary>
        /// Replaces the source code in a shader object
        /// <para>
        /// glShaderSource sets the source code in shader to the source code in the array of strings specified
        /// by string. Any source code previously stored in the shader object is completely replaced. The number
        /// of strings in the array is specified by count. If length is NULL, each string is assumed to be null
        /// terminated. If length is a value other than NULL, it points to an array containing a string length
        /// for each of the corresponding elements of string. Each element in the length array may contain the
        /// length of the corresponding string (the null character is not counted as part of the string length)
        /// or a value less than 0 to indicate that the string is null terminated. The source code strings are
        /// not scanned or parsed at this time; they are simply copied into the specified shader object
        /// </para>
        /// </summary>
        /// <param name="shaderObj">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="_string">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        public static void glShaderSourceARB(uint shaderObj, int count, string[] _string, int* length) {
            Pointers.glShaderSourceARB(shaderObj, count, _string, length);
        }
        
        /// <summary>
        /// Replaces the source code in a shader object
        /// <para>
        /// glShaderSource sets the source code in shader to the source code in the array of strings specified
        /// by string. Any source code previously stored in the shader object is completely replaced. The number
        /// of strings in the array is specified by count. If length is NULL, each string is assumed to be null
        /// terminated. If length is a value other than NULL, it points to an array containing a string length
        /// for each of the corresponding elements of string. Each element in the length array may contain the
        /// length of the corresponding string (the null character is not counted as part of the string length)
        /// or a value less than 0 to indicate that the string is null terminated. The source code strings are
        /// not scanned or parsed at this time; they are simply copied into the specified shader object
        /// </para>
        /// </summary>
        /// <param name="shaderObj">
        /// Specifies the handle of the shader object whose source code is to be replaced.
        /// </param>
        /// <param name="count">
        /// Specifies the number of elements in the string and length arrays.
        /// </param>
        /// <param name="_string">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        /// <param name="length">
        /// Specifies an array of pointers to strings containing the source code to be loaded into the shader.
        /// </param>
        public static void glShaderSourceARB(uint shaderObj, int count, string[] _string, int[] length) {
            fixed(int* length_ = &length[0])
                Pointers.glShaderSourceARB(shaderObj, count, _string, length_);
        }
        
        /// <summary>
        /// change an active shader storage block binding
        /// <para>
        /// glShaderStorageBlockBinding, changes the active shader storage block with an assigned index of
        /// storageBlockIndex in program object program. storageBlockIndex must be an active shader storage
        /// block index in program. storageBlockBinding must be less than the value of
        /// GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS. If successful, glShaderStorageBlockBinding specifies that
        /// program will use the data store of the buffer object bound to the binding point storageBlockBinding
        /// to read and write the values of the buffer variables in the shader storage block identified by
        /// storageBlockIndex
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the program containing the block whose binding to change.
        /// </param>
        /// <param name="storageBlockIndex">
        /// The index storage block within the program.
        /// </param>
        /// <param name="storageBlockBinding">
        /// The index storage block binding to associate with the specified storage block.
        /// </param>
        public static void glShaderStorageBlockBinding(uint program, uint storageBlockIndex, uint storageBlockBinding) {
            Pointers.glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
        }
        
        public static void glSharpenTexFuncSGIS(int target, int n, float* points) {
            Pointers.glSharpenTexFuncSGIS(target, n, points);
        }
        
        public static void glSharpenTexFuncSGIS(int target, int n, float[] points) {
            fixed(float* points_ = &points[0])
                Pointers.glSharpenTexFuncSGIS(target, n, points_);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, uint* dstLayouts) {
            Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, uint[] dstLayouts) {
            fixed(uint* dstLayouts_ = &dstLayouts[0])
                Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, dstLayouts_);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint[] textures, uint* dstLayouts) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures_, dstLayouts);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint[] textures, uint[] dstLayouts) {
            fixed(uint* textures_ = &textures[0])
            fixed(uint* dstLayouts_ = &dstLayouts[0])
                Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures_, dstLayouts_);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint* textures, uint* dstLayouts) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures, dstLayouts);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint* textures, uint[] dstLayouts) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* dstLayouts_ = &dstLayouts[0])
                Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures, dstLayouts_);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint[] textures, uint* dstLayouts) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* textures_ = &textures[0])
                Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures_, dstLayouts);
        }
        
        public static void glSignalSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint[] textures, uint[] dstLayouts) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* textures_ = &textures[0])
            fixed(uint* dstLayouts_ = &dstLayouts[0])
                Pointers.glSignalSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures_, dstLayouts_);
        }
        
        public static void glSpecializeShader(uint shader, string pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) {
            Pointers.glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        }
        
        public static void glSpecializeShader(uint shader, string pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint[] pConstantValue) {
            fixed(uint* pConstantValue_ = &pConstantValue[0])
                Pointers.glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue_);
        }
        
        public static void glSpecializeShader(uint shader, string pEntryPoint, uint numSpecializationConstants, uint[] pConstantIndex, uint* pConstantValue) {
            fixed(uint* pConstantIndex_ = &pConstantIndex[0])
                Pointers.glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex_, pConstantValue);
        }
        
        public static void glSpecializeShader(uint shader, string pEntryPoint, uint numSpecializationConstants, uint[] pConstantIndex, uint[] pConstantValue) {
            fixed(uint* pConstantIndex_ = &pConstantIndex[0])
            fixed(uint* pConstantValue_ = &pConstantValue[0])
                Pointers.glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex_, pConstantValue_);
        }
        
        public static void glSpecializeShaderARB(uint shader, string pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint* pConstantValue) {
            Pointers.glSpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
        }
        
        public static void glSpecializeShaderARB(uint shader, string pEntryPoint, uint numSpecializationConstants, uint* pConstantIndex, uint[] pConstantValue) {
            fixed(uint* pConstantValue_ = &pConstantValue[0])
                Pointers.glSpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue_);
        }
        
        public static void glSpecializeShaderARB(uint shader, string pEntryPoint, uint numSpecializationConstants, uint[] pConstantIndex, uint* pConstantValue) {
            fixed(uint* pConstantIndex_ = &pConstantIndex[0])
                Pointers.glSpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex_, pConstantValue);
        }
        
        public static void glSpecializeShaderARB(uint shader, string pEntryPoint, uint numSpecializationConstants, uint[] pConstantIndex, uint[] pConstantValue) {
            fixed(uint* pConstantIndex_ = &pConstantIndex[0])
            fixed(uint* pConstantValue_ = &pConstantValue[0])
                Pointers.glSpecializeShaderARB(shader, pEntryPoint, numSpecializationConstants, pConstantIndex_, pConstantValue_);
        }
        
        public static void glSpriteParameterfSGIX(int pname, float param) {
            Pointers.glSpriteParameterfSGIX(pname, param);
        }
        
        public static void glSpriteParameterfvSGIX(int pname, float* _params) {
            Pointers.glSpriteParameterfvSGIX(pname, _params);
        }
        
        public static void glSpriteParameterfvSGIX(int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glSpriteParameterfvSGIX(pname, _params_);
        }
        
        public static void glSpriteParameteriSGIX(int pname, int param) {
            Pointers.glSpriteParameteriSGIX(pname, param);
        }
        
        public static void glSpriteParameterivSGIX(int pname, int* _params) {
            Pointers.glSpriteParameterivSGIX(pname, _params);
        }
        
        public static void glSpriteParameterivSGIX(int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glSpriteParameterivSGIX(pname, _params_);
        }
        
        public static void glStartInstrumentsSGIX() {
            Pointers.glStartInstrumentsSGIX();
        }
        
        public static void glStartTilingQCOM(uint x, uint y, uint width, uint height, uint preserveMask) {
            Pointers.glStartTilingQCOM(x, y, width, height, preserveMask);
        }
        
        public static void glStartTilingQCOM(uint x, uint y, uint width, uint height, Enums.BufferBitQCOM preserveMask) {
            Pointers.glStartTilingQCOM(x, y, width, height, (uint)preserveMask);
        }
        
        public static void glStateCaptureNV(uint state, int mode) {
            Pointers.glStateCaptureNV(state, mode);
        }
        
        public static void glStencilClearTagEXT(int stencilTagBits, uint stencilClearTag) {
            Pointers.glStencilClearTagEXT(stencilTagBits, stencilClearTag);
        }
        
        public static void glStencilFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int transformType, float* transformValues) {
            Pointers.glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues);
        }
        
        public static void glStencilFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int transformType, float[] transformValues) {
            fixed(float* transformValues_ = &transformValues[0])
                Pointers.glStencilFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues_);
        }
        
        public static void glStencilFillPathNV(uint path, int fillMode, uint mask) {
            Pointers.glStencilFillPathNV(path, fillMode, mask);
        }
        
        /// <summary>
        /// set front and back function and reference value for stencil testing
        /// <para>
        /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. Stencil planes
        /// are first drawn into using GL drawing primitives, then geometry and images are rendered using the
        /// stencil planes to mask out portions of the screen. Stenciling is typically used in multipass
        /// rendering algorithms to achieve special effects, such as decals, outlining, and constructive solid
        /// geometry rendering
        /// </para>
        /// </summary>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL,
        /// GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </param>
        /// <param name="_ref">
        /// Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n
        /// is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the
        /// test is done. The initial value is all 1's.
        /// </param>
        public static void glStencilFunc(int func, int _ref, uint mask) {
            Pointers.glStencilFunc(func, _ref, mask);
        }
        
        /// <summary>
        /// set front and/or back function and reference value for stencil testing
        /// <para>
        /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
        /// the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
        /// planes to mask out portions of the screen. Stenciling is typically used in multipass rendering
        /// algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry
        /// rendering
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid:
        /// GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="func">
        /// Specifies the test function. Eight symbolic constants are valid: GL_NEVER, GL_LESS, GL_LEQUAL,
        /// GL_GREATER, GL_GEQUAL, GL_EQUAL, GL_NOTEQUAL, and GL_ALWAYS. The initial value is GL_ALWAYS.
        /// </param>
        /// <param name="_ref">
        /// Specifies the reference value for the stencil test. ref is clamped to the range 0 2 n - 1 , where n
        /// is the number of bitplanes in the stencil buffer. The initial value is 0.
        /// </param>
        /// <param name="mask">
        /// Specifies a mask that is ANDed with both the reference value and the stored stencil value when the
        /// test is done. The initial value is all 1's.
        /// </param>
        public static void glStencilFuncSeparate(int face, int func, int _ref, uint mask) {
            Pointers.glStencilFuncSeparate(face, func, _ref, mask);
        }
        
        public static void glStencilFuncSeparateATI(int frontfunc, int backfunc, int _ref, uint mask) {
            Pointers.glStencilFuncSeparateATI(frontfunc, backfunc, _ref, mask);
        }
        
        /// <summary>
        /// control the front and back writing of individual bits in the stencil planes
        /// <para>
        /// glStencilMask controls the writing of individual bits in the stencil planes. The least significant n
        /// bits of mask, where n is the number of bits in the stencil buffer, specify a mask. Where a 1 appears
        /// in the mask, it's possible to write to the corresponding bit in the stencil buffer. Where a 0
        /// appears, the corresponding bit is write-protected. Initially, all bits are enabled for writing
        /// </para>
        /// </summary>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes.
        /// Initially, the mask is all 1's.
        /// </param>
        public static void glStencilMask(uint mask) {
            Pointers.glStencilMask(mask);
        }
        
        /// <summary>
        /// control the front and/or back writing of individual bits in the stencil planes
        /// <para>
        /// glStencilMaskSeparate controls the writing of individual bits in the stencil planes. The least
        /// significant n bits of mask, where n is the number of bits in the stencil buffer, specify a mask.
        /// Where a 1 appears in the mask, it's possible to write to the corresponding bit in the stencil
        /// buffer. Where a 0 appears, the corresponding bit is write-protected. Initially, all bits are enabled
        /// for writing
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies whether the front and/or back stencil writemask is updated. Three symbolic constants are
        /// valid: GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="mask">
        /// Specifies a bit mask to enable and disable writing of individual bits in the stencil planes.
        /// Initially, the mask is all 1's.
        /// </param>
        public static void glStencilMaskSeparate(int face, uint mask) {
            Pointers.glStencilMaskSeparate(face, mask);
        }
        
        /// <summary>
        /// set front and back stencil test actions
        /// <para>
        /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
        /// the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
        /// planes to mask out portions of the screen. Stenciling is typically used in multipass rendering
        /// algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry
        /// rendering
        /// </para>
        /// </summary>
        /// <param name="fail">
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted:
        /// GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The
        /// initial value is GL_KEEP.
        /// </param>
        /// <param name="zfail">
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts
        /// the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </param>
        /// <param name="zpass">
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil
        /// test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the
        /// same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </param>
        public static void glStencilOp(int fail, int zfail, int zpass) {
            Pointers.glStencilOp(fail, zfail, zpass);
        }
        
        /// <summary>
        /// set front and/or back stencil test actions
        /// <para>
        /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
        /// the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
        /// planes to mask out portions of the screen. Stenciling is typically used in multipass rendering
        /// algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry
        /// rendering
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid:
        /// GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="sfail">
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted:
        /// GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The
        /// initial value is GL_KEEP.
        /// </param>
        /// <param name="dpfail">
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts
        /// the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </param>
        /// <param name="dppass">
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil
        /// test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the
        /// same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </param>
        public static void glStencilOpSeparate(int face, int sfail, int dpfail, int dppass) {
            Pointers.glStencilOpSeparate(face, sfail, dpfail, dppass);
        }
        
        /// <summary>
        /// set front and/or back stencil test actions
        /// <para>
        /// Stenciling, like depth-buffering, enables and disables drawing on a per-pixel basis. You draw into
        /// the stencil planes using GL drawing primitives, then render geometry and images, using the stencil
        /// planes to mask out portions of the screen. Stenciling is typically used in multipass rendering
        /// algorithms to achieve special effects, such as decals, outlining, and constructive solid geometry
        /// rendering
        /// </para>
        /// </summary>
        /// <param name="face">
        /// Specifies whether front and/or back stencil state is updated. Three symbolic constants are valid:
        /// GL_FRONT, GL_BACK, and GL_FRONT_AND_BACK.
        /// </param>
        /// <param name="sfail">
        /// Specifies the action to take when the stencil test fails. Eight symbolic constants are accepted:
        /// GL_KEEP, GL_ZERO, GL_REPLACE, GL_INCR, GL_INCR_WRAP, GL_DECR, GL_DECR_WRAP, and GL_INVERT. The
        /// initial value is GL_KEEP.
        /// </param>
        /// <param name="dpfail">
        /// Specifies the stencil action when the stencil test passes, but the depth test fails. dpfail accepts
        /// the same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </param>
        /// <param name="dppass">
        /// Specifies the stencil action when both the stencil test and the depth test pass, or when the stencil
        /// test passes and either there is no depth buffer or depth testing is not enabled. dppass accepts the
        /// same symbolic constants as sfail. The initial value is GL_KEEP.
        /// </param>
        public static void glStencilOpSeparateATI(int face, int sfail, int dpfail, int dppass) {
            Pointers.glStencilOpSeparateATI(face, sfail, dpfail, dppass);
        }
        
        public static void glStencilOpValueAMD(int face, uint value) {
            Pointers.glStencilOpValueAMD(face, value);
        }
        
        public static void glStencilStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int transformType, float* transformValues) {
            Pointers.glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues);
        }
        
        public static void glStencilStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int transformType, float[] transformValues) {
            fixed(float* transformValues_ = &transformValues[0])
                Pointers.glStencilStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues_);
        }
        
        public static void glStencilStrokePathNV(uint path, int reference, uint mask) {
            Pointers.glStencilStrokePathNV(path, reference, mask);
        }
        
        public static void glStencilThenCoverFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int coverMode, int transformType, float* transformValues) {
            Pointers.glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues);
        }
        
        public static void glStencilThenCoverFillPathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int fillMode, uint mask, int coverMode, int transformType, float[] transformValues) {
            fixed(float* transformValues_ = &transformValues[0])
                Pointers.glStencilThenCoverFillPathInstancedNV(numPaths, pathNameType, paths, pathBase, fillMode, mask, coverMode, transformType, transformValues_);
        }
        
        public static void glStencilThenCoverFillPathNV(uint path, int fillMode, uint mask, int coverMode) {
            Pointers.glStencilThenCoverFillPathNV(path, fillMode, mask, coverMode);
        }
        
        public static void glStencilThenCoverStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int coverMode, int transformType, float* transformValues) {
            Pointers.glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues);
        }
        
        public static void glStencilThenCoverStrokePathInstancedNV(int numPaths, int pathNameType, IntPtr paths, uint pathBase, int reference, uint mask, int coverMode, int transformType, float[] transformValues) {
            fixed(float* transformValues_ = &transformValues[0])
                Pointers.glStencilThenCoverStrokePathInstancedNV(numPaths, pathNameType, paths, pathBase, reference, mask, coverMode, transformType, transformValues_);
        }
        
        public static void glStencilThenCoverStrokePathNV(uint path, int reference, uint mask, int coverMode) {
            Pointers.glStencilThenCoverStrokePathNV(path, reference, mask, coverMode);
        }
        
        public static void glStopInstrumentsSGIX(int marker) {
            Pointers.glStopInstrumentsSGIX(marker);
        }
        
        public static void glStringMarkerGREMEDY(int len, IntPtr _string) {
            Pointers.glStringMarkerGREMEDY(len, _string);
        }
        
        public static void glSubpixelPrecisionBiasNV(uint xbits, uint ybits) {
            Pointers.glSubpixelPrecisionBiasNV(xbits, ybits);
        }
        
        public static void glSwizzleEXT(uint res, uint _in, int outX, int outY, int outZ, int outW) {
            Pointers.glSwizzleEXT(res, _in, outX, outY, outZ, outW);
        }
        
        public static void glSyncTextureINTEL(uint texture) {
            Pointers.glSyncTextureINTEL(texture);
        }
        
        public static void glTagSampleBufferSGIX() {
            Pointers.glTagSampleBufferSGIX();
        }
        
        public static void glTangent3bEXT(sbyte tx, sbyte ty, sbyte tz) {
            Pointers.glTangent3bEXT(tx, ty, tz);
        }
        
        public static void glTangent3bvEXT(sbyte* v) {
            Pointers.glTangent3bvEXT(v);
        }
        
        public static void glTangent3bvEXT(sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glTangent3bvEXT(v_);
        }
        
        public static void glTangent3dEXT(double tx, double ty, double tz) {
            Pointers.glTangent3dEXT(tx, ty, tz);
        }
        
        public static void glTangent3dvEXT(double* v) {
            Pointers.glTangent3dvEXT(v);
        }
        
        public static void glTangent3dvEXT(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glTangent3dvEXT(v_);
        }
        
        public static void glTangent3fEXT(float tx, float ty, float tz) {
            Pointers.glTangent3fEXT(tx, ty, tz);
        }
        
        public static void glTangent3fvEXT(float* v) {
            Pointers.glTangent3fvEXT(v);
        }
        
        public static void glTangent3fvEXT(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTangent3fvEXT(v_);
        }
        
        public static void glTangent3iEXT(int tx, int ty, int tz) {
            Pointers.glTangent3iEXT(tx, ty, tz);
        }
        
        public static void glTangent3ivEXT(int* v) {
            Pointers.glTangent3ivEXT(v);
        }
        
        public static void glTangent3ivEXT(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glTangent3ivEXT(v_);
        }
        
        public static void glTangent3sEXT(short tx, short ty, short tz) {
            Pointers.glTangent3sEXT(tx, ty, tz);
        }
        
        public static void glTangent3svEXT(short* v) {
            Pointers.glTangent3svEXT(v);
        }
        
        public static void glTangent3svEXT(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glTangent3svEXT(v_);
        }
        
        public static void glTangentPointerEXT(int type, int stride, IntPtr pointer) {
            Pointers.glTangentPointerEXT(type, stride, pointer);
        }
        
        public static void glTbufferMask3DFX(uint mask) {
            Pointers.glTbufferMask3DFX(mask);
        }
        
        public static void glTessellationFactorAMD(float factor) {
            Pointers.glTessellationFactorAMD(factor);
        }
        
        public static void glTessellationModeAMD(int mode) {
            Pointers.glTessellationModeAMD(mode);
        }
        
        public static bool glTestFenceAPPLE(uint fence) {
            return Pointers.glTestFenceAPPLE(fence);
        }
        
        public static bool glTestFenceNV(uint fence) {
            return Pointers.glTestFenceNV(fence);
        }
        
        public static bool glTestObjectAPPLE(int _object, uint name) {
            return Pointers.glTestObjectAPPLE(_object, name);
        }
        
        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>
        /// glTexBuffer and glTextureBuffer attaches the data store of a specified buffer object to a specified
        /// texture object, and specify the storage format for the texture image found found in the buffer
        /// object. The texture object must be a buffer texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the data in the store belonging to buffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
        /// </param>
        public static void glTexBuffer(int target, int internalformat, uint buffer) {
            Pointers.glTexBuffer(target, internalformat, buffer);
        }
        
        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>
        /// glTexBuffer and glTextureBuffer attaches the data store of a specified buffer object to a specified
        /// texture object, and specify the storage format for the texture image found found in the buffer
        /// object. The texture object must be a buffer texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the data in the store belonging to buffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
        /// </param>
        public static void glTexBufferARB(int target, int internalformat, uint buffer) {
            Pointers.glTexBufferARB(target, internalformat, buffer);
        }
        
        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>
        /// glTexBuffer and glTextureBuffer attaches the data store of a specified buffer object to a specified
        /// texture object, and specify the storage format for the texture image found found in the buffer
        /// object. The texture object must be a buffer texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the data in the store belonging to buffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
        /// </param>
        public static void glTexBufferEXT(int target, int internalformat, uint buffer) {
            Pointers.glTexBufferEXT(target, internalformat, buffer);
        }
        
        /// <summary>
        /// attach a buffer object's data store to a buffer texture object
        /// <para>
        /// glTexBuffer and glTextureBuffer attaches the data store of a specified buffer object to a specified
        /// texture object, and specify the storage format for the texture image found found in the buffer
        /// object. The texture object must be a buffer texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexBuffer. Must be GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the data in the store belonging to buffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
        /// </param>
        public static void glTexBufferOES(int target, int internalformat, uint buffer) {
            Pointers.glTexBufferOES(target, internalformat, buffer);
        }
        
        /// <summary>
        /// attach a range of a buffer object's data store to a buffer texture object
        /// <para>
        /// glTexBufferRange and glTextureBufferRange attach a range of the data store of a specified buffer
        /// object to a specified texture object, and specify the storage format for the texture image found
        /// found in the buffer object. The texture object must be a buffer texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexBufferRange. Must be
        /// GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the data in the store belonging to buffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset of the start of the range of the buffer's data store to attach.
        /// </param>
        /// <param name="size">
        /// Specifies the size of the range of the buffer's data store to attach.
        /// </param>
        public static void glTexBufferRange(int target, int internalformat, uint buffer, uint offset, uint size) {
            Pointers.glTexBufferRange(target, internalformat, buffer, offset, size);
        }
        
        /// <summary>
        /// attach a range of a buffer object's data store to a buffer texture object
        /// <para>
        /// glTexBufferRange and glTextureBufferRange attach a range of the data store of a specified buffer
        /// object to a specified texture object, and specify the storage format for the texture image found
        /// found in the buffer object. The texture object must be a buffer texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexBufferRange. Must be
        /// GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the data in the store belonging to buffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset of the start of the range of the buffer's data store to attach.
        /// </param>
        /// <param name="size">
        /// Specifies the size of the range of the buffer's data store to attach.
        /// </param>
        public static void glTexBufferRangeEXT(int target, int internalformat, uint buffer, uint offset, uint size) {
            Pointers.glTexBufferRangeEXT(target, internalformat, buffer, offset, size);
        }
        
        /// <summary>
        /// attach a range of a buffer object's data store to a buffer texture object
        /// <para>
        /// glTexBufferRange and glTextureBufferRange attach a range of the data store of a specified buffer
        /// object to a specified texture object, and specify the storage format for the texture image found
        /// found in the buffer object. The texture object must be a buffer texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexBufferRange. Must be
        /// GL_TEXTURE_BUFFER.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the internal format of the data in the store belonging to buffer.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object whose storage to attach to the active buffer texture.
        /// </param>
        /// <param name="offset">
        /// Specifies the offset of the start of the range of the buffer's data store to attach.
        /// </param>
        /// <param name="size">
        /// Specifies the size of the range of the buffer's data store to attach.
        /// </param>
        public static void glTexBufferRangeOES(int target, int internalformat, uint buffer, uint offset, uint size) {
            Pointers.glTexBufferRangeOES(target, internalformat, buffer, offset, size);
        }
        
        public static void glTexBumpParameterfvATI(int pname, float* param) {
            Pointers.glTexBumpParameterfvATI(pname, param);
        }
        
        public static void glTexBumpParameterfvATI(int pname, float[] param) {
            fixed(float* param_ = &param[0])
                Pointers.glTexBumpParameterfvATI(pname, param_);
        }
        
        public static void glTexBumpParameterivATI(int pname, int* param) {
            Pointers.glTexBumpParameterivATI(pname, param);
        }
        
        public static void glTexBumpParameterivATI(int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glTexBumpParameterivATI(pname, param_);
        }
        
        public static void glTexCoord1bOES(sbyte s) {
            Pointers.glTexCoord1bOES(s);
        }
        
        public static void glTexCoord1bvOES(sbyte* coords) {
            Pointers.glTexCoord1bvOES(coords);
        }
        
        public static void glTexCoord1bvOES(out sbyte coords) {
            fixed(sbyte* coords_ = &coords)
                Pointers.glTexCoord1bvOES(coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord1d(double s) {
            Pointers.glTexCoord1d(s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1dv(double* v) {
            Pointers.glTexCoord1dv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1dv(out double v) {
            fixed(double* v_ = &v)
                Pointers.glTexCoord1dv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord1f(float s) {
            Pointers.glTexCoord1f(s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1fv(float* v) {
            Pointers.glTexCoord1fv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1fv(out float v) {
            fixed(float* v_ = &v)
                Pointers.glTexCoord1fv(v_);
        }
        
        public static void glTexCoord1hNV(short s) {
            Pointers.glTexCoord1hNV(s);
        }
        
        public static void glTexCoord1hvNV(short* v) {
            Pointers.glTexCoord1hvNV(v);
        }
        
        public static void glTexCoord1hvNV(out short v) {
            fixed(short* v_ = &v)
                Pointers.glTexCoord1hvNV(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord1i(int s) {
            Pointers.glTexCoord1i(s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1iv(int* v) {
            Pointers.glTexCoord1iv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1iv(out int v) {
            fixed(int* v_ = &v)
                Pointers.glTexCoord1iv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord1s(short s) {
            Pointers.glTexCoord1s(s);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1sv(short* v) {
            Pointers.glTexCoord1sv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord1sv(out short v) {
            fixed(short* v_ = &v)
                Pointers.glTexCoord1sv(v_);
        }
        
        public static void glTexCoord1xOES(IntPtr s) {
            Pointers.glTexCoord1xOES(s);
        }
        
        public static void glTexCoord1xvOES(IntPtr* coords) {
            Pointers.glTexCoord1xvOES(coords);
        }
        
        public static void glTexCoord1xvOES(out IntPtr coords) {
            fixed(IntPtr* coords_ = &coords)
                Pointers.glTexCoord1xvOES(coords_);
        }
        
        public static void glTexCoord2bOES(sbyte s, sbyte t) {
            Pointers.glTexCoord2bOES(s, t);
        }
        
        public static void glTexCoord2bvOES(sbyte* coords) {
            Pointers.glTexCoord2bvOES(coords);
        }
        
        public static void glTexCoord2bvOES(sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glTexCoord2bvOES(coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord2d(double s, double t) {
            Pointers.glTexCoord2d(s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2dv(double* v) {
            Pointers.glTexCoord2dv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glTexCoord2dv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord2f(float s, float t) {
            Pointers.glTexCoord2f(s, t);
        }
        
        public static void glTexCoord2fColor3fVertex3fSUN(float s, float t, float r, float g, float b, float x, float y, float z) {
            Pointers.glTexCoord2fColor3fVertex3fSUN(s, t, r, g, b, x, y, z);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float* tc, float* c, float* v) {
            Pointers.glTexCoord2fColor3fVertex3fvSUN(tc, c, v);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float* tc, float* c, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor3fVertex3fvSUN(tc, c, v_);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float* tc, float[] c, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glTexCoord2fColor3fVertex3fvSUN(tc, c_, v);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float* tc, float[] c, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor3fVertex3fvSUN(tc, c_, v_);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float[] tc, float* c, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glTexCoord2fColor3fVertex3fvSUN(tc_, c, v);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float[] tc, float* c, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor3fVertex3fvSUN(tc_, c, v_);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float[] tc, float[] c, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
                Pointers.glTexCoord2fColor3fVertex3fvSUN(tc_, c_, v);
        }
        
        public static void glTexCoord2fColor3fVertex3fvSUN(float[] tc, float[] c, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor3fVertex3fvSUN(tc_, c_, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fSUN(float s, float t, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glTexCoord2fColor4fNormal3fVertex3fSUN(s, t, r, g, b, a, nx, ny, nz, x, y, z);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float* n, float* v) {
            Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n_, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float* c, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c, n_, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float[] c, float* n, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c_, n, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float[] c, float* n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c_, n, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float[] c, float[] n, float* v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c_, n_, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float* tc, float[] c, float[] n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc, c_, n_, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float* c, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c, n, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float* c, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c, n, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float* c, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c, n_, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float* c, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c, n_, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float[] c, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c_, n, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float[] c, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c_, n, v_);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float[] c, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c_, n_, v);
        }
        
        public static void glTexCoord2fColor4fNormal3fVertex3fvSUN(float[] tc, float[] c, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4fNormal3fVertex3fvSUN(tc_, c_, n_, v_);
        }
        
        public static void glTexCoord2fColor4ubVertex3fSUN(float s, float t, byte r, byte g, byte b, byte a, float x, float y, float z) {
            Pointers.glTexCoord2fColor4ubVertex3fSUN(s, t, r, g, b, a, x, y, z);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float* tc, byte* c, float* v) {
            Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc, c, v);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float* tc, byte* c, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc, c, v_);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float* tc, byte[] c, float* v) {
            fixed(byte* c_ = &c[0])
                Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc, c_, v);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float* tc, byte[] c, float[] v) {
            fixed(byte* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc, c_, v_);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float[] tc, byte* c, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc_, c, v);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float[] tc, byte* c, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc_, c, v_);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float[] tc, byte[] c, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(byte* c_ = &c[0])
                Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc_, c_, v);
        }
        
        public static void glTexCoord2fColor4ubVertex3fvSUN(float[] tc, byte[] c, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(byte* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fColor4ubVertex3fvSUN(tc_, c_, v_);
        }
        
        public static void glTexCoord2fNormal3fVertex3fSUN(float s, float t, float nx, float ny, float nz, float x, float y, float z) {
            Pointers.glTexCoord2fNormal3fVertex3fSUN(s, t, nx, ny, nz, x, y, z);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float* tc, float* n, float* v) {
            Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc, n, v);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float* tc, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc, n, v_);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float* tc, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc, n_, v);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float* tc, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc, n_, v_);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float[] tc, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc_, n, v);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float[] tc, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc_, n, v_);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float[] tc, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc_, n_, v);
        }
        
        public static void glTexCoord2fNormal3fVertex3fvSUN(float[] tc, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fNormal3fVertex3fvSUN(tc_, n_, v_);
        }
        
        public static void glTexCoord2fVertex3fSUN(float s, float t, float x, float y, float z) {
            Pointers.glTexCoord2fVertex3fSUN(s, t, x, y, z);
        }
        
        public static void glTexCoord2fVertex3fvSUN(float* tc, float* v) {
            Pointers.glTexCoord2fVertex3fvSUN(tc, v);
        }
        
        public static void glTexCoord2fVertex3fvSUN(float* tc, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fVertex3fvSUN(tc, v_);
        }
        
        public static void glTexCoord2fVertex3fvSUN(float[] tc, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glTexCoord2fVertex3fvSUN(tc_, v);
        }
        
        public static void glTexCoord2fVertex3fvSUN(float[] tc, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fVertex3fvSUN(tc_, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2fv(float* v) {
            Pointers.glTexCoord2fv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord2fv(v_);
        }
        
        public static void glTexCoord2hNV(short s, short t) {
            Pointers.glTexCoord2hNV(s, t);
        }
        
        public static void glTexCoord2hvNV(short* v) {
            Pointers.glTexCoord2hvNV(v);
        }
        
        public static void glTexCoord2hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glTexCoord2hvNV(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord2i(int s, int t) {
            Pointers.glTexCoord2i(s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2iv(int* v) {
            Pointers.glTexCoord2iv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glTexCoord2iv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord2s(short s, short t) {
            Pointers.glTexCoord2s(s, t);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2sv(short* v) {
            Pointers.glTexCoord2sv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord2sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glTexCoord2sv(v_);
        }
        
        public static void glTexCoord2xOES(IntPtr s, IntPtr t) {
            Pointers.glTexCoord2xOES(s, t);
        }
        
        public static void glTexCoord2xvOES(IntPtr* coords) {
            Pointers.glTexCoord2xvOES(coords);
        }
        
        public static void glTexCoord2xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glTexCoord2xvOES(coords_);
        }
        
        public static void glTexCoord3bOES(sbyte s, sbyte t, sbyte r) {
            Pointers.glTexCoord3bOES(s, t, r);
        }
        
        public static void glTexCoord3bvOES(sbyte* coords) {
            Pointers.glTexCoord3bvOES(coords);
        }
        
        public static void glTexCoord3bvOES(sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glTexCoord3bvOES(coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord3d(double s, double t, double r) {
            Pointers.glTexCoord3d(s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3dv(double* v) {
            Pointers.glTexCoord3dv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glTexCoord3dv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord3f(float s, float t, float r) {
            Pointers.glTexCoord3f(s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3fv(float* v) {
            Pointers.glTexCoord3fv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord3fv(v_);
        }
        
        public static void glTexCoord3hNV(short s, short t, short r) {
            Pointers.glTexCoord3hNV(s, t, r);
        }
        
        public static void glTexCoord3hvNV(short* v) {
            Pointers.glTexCoord3hvNV(v);
        }
        
        public static void glTexCoord3hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glTexCoord3hvNV(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord3i(int s, int t, int r) {
            Pointers.glTexCoord3i(s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3iv(int* v) {
            Pointers.glTexCoord3iv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glTexCoord3iv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord3s(short s, short t, short r) {
            Pointers.glTexCoord3s(s, t, r);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3sv(short* v) {
            Pointers.glTexCoord3sv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord3sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glTexCoord3sv(v_);
        }
        
        public static void glTexCoord3xOES(IntPtr s, IntPtr t, IntPtr r) {
            Pointers.glTexCoord3xOES(s, t, r);
        }
        
        public static void glTexCoord3xvOES(IntPtr* coords) {
            Pointers.glTexCoord3xvOES(coords);
        }
        
        public static void glTexCoord3xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glTexCoord3xvOES(coords_);
        }
        
        public static void glTexCoord4bOES(sbyte s, sbyte t, sbyte r, sbyte q) {
            Pointers.glTexCoord4bOES(s, t, r, q);
        }
        
        public static void glTexCoord4bvOES(sbyte* coords) {
            Pointers.glTexCoord4bvOES(coords);
        }
        
        public static void glTexCoord4bvOES(sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glTexCoord4bvOES(coords_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord4d(double s, double t, double r, double q) {
            Pointers.glTexCoord4d(s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4dv(double* v) {
            Pointers.glTexCoord4dv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glTexCoord4dv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord4f(float s, float t, float r, float q) {
            Pointers.glTexCoord4f(s, t, r, q);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fSUN(float s, float t, float p, float q, float r, float g, float b, float a, float nx, float ny, float nz, float x, float y, float z, float w) {
            Pointers.glTexCoord4fColor4fNormal3fVertex4fSUN(s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float* n, float* v) {
            Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float* n, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n, v_);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float[] n, float* v) {
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n_, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float* c, float[] n, float[] v) {
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c, n_, v_);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float[] c, float* n, float* v) {
            fixed(float* c_ = &c[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c_, n, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float[] c, float* n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c_, n, v_);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float[] c, float[] n, float* v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c_, n_, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float* tc, float[] c, float[] n, float[] v) {
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc, c_, n_, v_);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float* c, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c, n, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float* c, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c, n, v_);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float* c, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c, n_, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float* c, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c, n_, v_);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float[] c, float* n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c_, n, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float[] c, float* n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c_, n, v_);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float[] c, float[] n, float* v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c_, n_, v);
        }
        
        public static void glTexCoord4fColor4fNormal3fVertex4fvSUN(float[] tc, float[] c, float[] n, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* c_ = &c[0])
            fixed(float* n_ = &n[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fColor4fNormal3fVertex4fvSUN(tc_, c_, n_, v_);
        }
        
        public static void glTexCoord4fVertex4fSUN(float s, float t, float p, float q, float x, float y, float z, float w) {
            Pointers.glTexCoord4fVertex4fSUN(s, t, p, q, x, y, z, w);
        }
        
        public static void glTexCoord4fVertex4fvSUN(float* tc, float* v) {
            Pointers.glTexCoord4fVertex4fvSUN(tc, v);
        }
        
        public static void glTexCoord4fVertex4fvSUN(float* tc, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fVertex4fvSUN(tc, v_);
        }
        
        public static void glTexCoord4fVertex4fvSUN(float[] tc, float* v) {
            fixed(float* tc_ = &tc[0])
                Pointers.glTexCoord4fVertex4fvSUN(tc_, v);
        }
        
        public static void glTexCoord4fVertex4fvSUN(float[] tc, float[] v) {
            fixed(float* tc_ = &tc[0])
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fVertex4fvSUN(tc_, v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4fv(float* v) {
            Pointers.glTexCoord4fv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glTexCoord4fv(v_);
        }
        
        public static void glTexCoord4hNV(short s, short t, short r, short q) {
            Pointers.glTexCoord4hNV(s, t, r, q);
        }
        
        public static void glTexCoord4hvNV(short* v) {
            Pointers.glTexCoord4hvNV(v);
        }
        
        public static void glTexCoord4hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glTexCoord4hvNV(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord4i(int s, int t, int r, int q) {
            Pointers.glTexCoord4i(s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4iv(int* v) {
            Pointers.glTexCoord4iv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glTexCoord4iv(v_);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="s">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="t">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="r">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="q">
        /// Specify s, t, r, and q texture coordinates. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glTexCoord4s(short s, short t, short r, short q) {
            Pointers.glTexCoord4s(s, t, r, q);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4sv(short* v) {
            Pointers.glTexCoord4sv(v);
        }
        
        /// <summary>
        /// set the current texture coordinates
        /// <para>
        /// glTexCoord specifies texture coordinates in one, two, three, or four dimensions. glTexCoord1 sets
        /// the current texture coordinates to s 0 0 1 ; a call to glTexCoord2 sets them to s t 0 1 . Similarly,
        /// glTexCoord3 specifies the texture coordinates as s t r 1 , and glTexCoord4 defines all four
        /// components explicitly as s t r q
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of one, two, three, or four elements, which in turn specify the s,
        /// t, r, and q texture coordinates.
        /// </param>
        public static void glTexCoord4sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glTexCoord4sv(v_);
        }
        
        public static void glTexCoord4xOES(IntPtr s, IntPtr t, IntPtr r, IntPtr q) {
            Pointers.glTexCoord4xOES(s, t, r, q);
        }
        
        public static void glTexCoord4xvOES(IntPtr* coords) {
            Pointers.glTexCoord4xvOES(coords);
        }
        
        public static void glTexCoord4xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glTexCoord4xvOES(coords_);
        }
        
        public static void glTexCoordFormatNV(int size, int type, int stride) {
            Pointers.glTexCoordFormatNV(size, type, stride);
        }
        
        public static void glTexCoordP1ui(int type, uint coords) {
            Pointers.glTexCoordP1ui(type, coords);
        }
        
        public static void glTexCoordP1uiv(int type, uint* coords) {
            Pointers.glTexCoordP1uiv(type, coords);
        }
        
        public static void glTexCoordP1uiv(int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glTexCoordP1uiv(type, coords_);
        }
        
        public static void glTexCoordP2ui(int type, uint coords) {
            Pointers.glTexCoordP2ui(type, coords);
        }
        
        public static void glTexCoordP2uiv(int type, uint* coords) {
            Pointers.glTexCoordP2uiv(type, coords);
        }
        
        public static void glTexCoordP2uiv(int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glTexCoordP2uiv(type, coords_);
        }
        
        public static void glTexCoordP3ui(int type, uint coords) {
            Pointers.glTexCoordP3ui(type, coords);
        }
        
        public static void glTexCoordP3uiv(int type, uint* coords) {
            Pointers.glTexCoordP3uiv(type, coords);
        }
        
        public static void glTexCoordP3uiv(int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glTexCoordP3uiv(type, coords_);
        }
        
        public static void glTexCoordP4ui(int type, uint coords) {
            Pointers.glTexCoordP4ui(type, coords);
        }
        
        public static void glTexCoordP4uiv(int type, uint* coords) {
            Pointers.glTexCoordP4uiv(type, coords);
        }
        
        public static void glTexCoordP4uiv(int type, out uint coords) {
            fixed(uint* coords_ = &coords)
                Pointers.glTexCoordP4uiv(type, coords_);
        }
        
        /// <summary>
        /// define an array of texture coordinates
        /// <para>
        /// glTexCoordPointer specifies the location and data format of an array of texture coordinates to use
        /// when rendering. size specifies the number of coordinates per texture coordinate set, and must be 1,
        /// 2, 3, or 4. type specifies the data type of each texture coordinate, and stride specifies the byte
        /// stride from one texture coordinate set to the next, allowing vertices and attributes to be packed
        /// into a single array or stored in separate arrays. (Single-array storage may be more efficient on
        /// some implementations; see glInterleavedArrays.)
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the number of coordinates per array element. Must be 1, 2, 3, or 4. The initial value is
        /// 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each texture coordinate. Symbolic constants GL_SHORT, GL_INT, GL_FLOAT,
        /// or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive texture coordinate sets. If stride is 0, the array
        /// elements are understood to be tightly packed. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first coordinate of the first texture coordinate set in the array. The
        /// initial value is 0.
        /// </param>
        public static void glTexCoordPointer(int size, int type, int stride, IntPtr pointer) {
            Pointers.glTexCoordPointer(size, type, stride, pointer);
        }
        
        public static void glTexCoordPointerEXT(int size, int type, int stride, int count, IntPtr pointer) {
            Pointers.glTexCoordPointerEXT(size, type, stride, count, pointer);
        }
        
        public static void glTexCoordPointerListIBM(int size, int type, int stride, IntPtr* pointer, int ptrstride) {
            Pointers.glTexCoordPointerListIBM(size, type, stride, pointer, ptrstride);
        }
        
        public static void glTexCoordPointerListIBM(int size, int type, int stride, IntPtr[] pointer, int ptrstride) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glTexCoordPointerListIBM(size, type, stride, pointer_, ptrstride);
        }
        
        public static void glTexCoordPointervINTEL(int size, int type, IntPtr* pointer) {
            Pointers.glTexCoordPointervINTEL(size, type, pointer);
        }
        
        public static void glTexCoordPointervINTEL(int size, int type, IntPtr[] pointer) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glTexCoordPointervINTEL(size, type, pointer_);
        }
        
        /// <summary>
        /// set texture environment parameters
        /// <para>
        /// A texture environment specifies how texture values are interpreted when a fragment is textured. When
        /// target is GL_TEXTURE_FILTER_CONTROL, pname must be GL_TEXTURE_LOD_BIAS. When target is
        /// GL_TEXTURE_ENV, pname can be GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_COMBINE_RGB,
        /// GL_COMBINE_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB,
        /// GL_SRC0_ALPHA, GL_SRC1_ALPHA, or GL_SRC2_ALPHA
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB,
        /// GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="param">
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE,
        /// GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR,
        /// GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single
        /// boolean value for the point sprite texture coordinate replacement, a single floating-point value for
        /// the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or
        /// GL_ALPHA_SCALE.
        /// </param>
        public static void glTexEnvf(int target, int pname, float param) {
            Pointers.glTexEnvf(target, pname, param);
        }
        
        /// <summary>
        /// set texture environment parameters
        /// <para>
        /// A texture environment specifies how texture values are interpreted when a fragment is textured. When
        /// target is GL_TEXTURE_FILTER_CONTROL, pname must be GL_TEXTURE_LOD_BIAS. When target is
        /// GL_TEXTURE_ENV, pname can be GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_COMBINE_RGB,
        /// GL_COMBINE_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB,
        /// GL_SRC0_ALPHA, GL_SRC1_ALPHA, or GL_SRC2_ALPHA
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB,
        /// GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture environment. May be either GL_TEXTURE_ENV, or GL_TEXTURE_FILTER_CONTROL.
        /// </param>
        public static void glTexEnvfv(int target, int pname, float* _params) {
            Pointers.glTexEnvfv(target, pname, _params);
        }
        
        /// <summary>
        /// set texture environment parameters
        /// <para>
        /// A texture environment specifies how texture values are interpreted when a fragment is textured. When
        /// target is GL_TEXTURE_FILTER_CONTROL, pname must be GL_TEXTURE_LOD_BIAS. When target is
        /// GL_TEXTURE_ENV, pname can be GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_COMBINE_RGB,
        /// GL_COMBINE_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB,
        /// GL_SRC0_ALPHA, GL_SRC1_ALPHA, or GL_SRC2_ALPHA
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB,
        /// GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture environment. May be either GL_TEXTURE_ENV, or GL_TEXTURE_FILTER_CONTROL.
        /// </param>
        public static void glTexEnvfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glTexEnvfv(target, pname, _params_);
        }
        
        /// <summary>
        /// set texture environment parameters
        /// <para>
        /// A texture environment specifies how texture values are interpreted when a fragment is textured. When
        /// target is GL_TEXTURE_FILTER_CONTROL, pname must be GL_TEXTURE_LOD_BIAS. When target is
        /// GL_TEXTURE_ENV, pname can be GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_COMBINE_RGB,
        /// GL_COMBINE_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB,
        /// GL_SRC0_ALPHA, GL_SRC1_ALPHA, or GL_SRC2_ALPHA
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB,
        /// GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="param">
        /// Specifies a single symbolic constant, one of GL_ADD, GL_ADD_SIGNED, GL_INTERPOLATE, GL_MODULATE,
        /// GL_DECAL, GL_BLEND, GL_REPLACE, GL_SUBTRACT, GL_COMBINE, GL_TEXTURE, GL_CONSTANT, GL_PRIMARY_COLOR,
        /// GL_PREVIOUS, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, a single
        /// boolean value for the point sprite texture coordinate replacement, a single floating-point value for
        /// the texture level-of-detail bias, or 1.0, 2.0, or 4.0 when specifying the GL_RGB_SCALE or
        /// GL_ALPHA_SCALE.
        /// </param>
        public static void glTexEnvi(int target, int pname, int param) {
            Pointers.glTexEnvi(target, pname, param);
        }
        
        /// <summary>
        /// set texture environment parameters
        /// <para>
        /// A texture environment specifies how texture values are interpreted when a fragment is textured. When
        /// target is GL_TEXTURE_FILTER_CONTROL, pname must be GL_TEXTURE_LOD_BIAS. When target is
        /// GL_TEXTURE_ENV, pname can be GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_COMBINE_RGB,
        /// GL_COMBINE_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB,
        /// GL_SRC0_ALPHA, GL_SRC1_ALPHA, or GL_SRC2_ALPHA
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB,
        /// GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture environment. May be either GL_TEXTURE_ENV, or GL_TEXTURE_FILTER_CONTROL.
        /// </param>
        public static void glTexEnviv(int target, int pname, int* _params) {
            Pointers.glTexEnviv(target, pname, _params);
        }
        
        /// <summary>
        /// set texture environment parameters
        /// <para>
        /// A texture environment specifies how texture values are interpreted when a fragment is textured. When
        /// target is GL_TEXTURE_FILTER_CONTROL, pname must be GL_TEXTURE_LOD_BIAS. When target is
        /// GL_TEXTURE_ENV, pname can be GL_TEXTURE_ENV_MODE, GL_TEXTURE_ENV_COLOR, GL_COMBINE_RGB,
        /// GL_COMBINE_ALPHA, GL_RGB_SCALE, GL_ALPHA_SCALE, GL_SRC0_RGB, GL_SRC1_RGB, GL_SRC2_RGB,
        /// GL_SRC0_ALPHA, GL_SRC1_ALPHA, or GL_SRC2_ALPHA
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies a texture environment. May be GL_TEXTURE_ENV, GL_TEXTURE_FILTER_CONTROL or
        /// GL_POINT_SPRITE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture environment parameter. May be either
        /// GL_TEXTURE_ENV_MODE, GL_TEXTURE_LOD_BIAS, GL_COMBINE_RGB, GL_COMBINE_ALPHA, GL_SRC0_RGB,
        /// GL_SRC1_RGB, GL_SRC2_RGB, GL_SRC0_ALPHA, GL_SRC1_ALPHA, GL_SRC2_ALPHA, GL_OPERAND0_RGB,
        /// GL_OPERAND1_RGB, GL_OPERAND2_RGB, GL_OPERAND0_ALPHA, GL_OPERAND1_ALPHA, GL_OPERAND2_ALPHA,
        /// GL_RGB_SCALE, GL_ALPHA_SCALE, or GL_COORD_REPLACE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture environment. May be either GL_TEXTURE_ENV, or GL_TEXTURE_FILTER_CONTROL.
        /// </param>
        public static void glTexEnviv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTexEnviv(target, pname, _params_);
        }
        
        public static void glTexEnvx(int target, int pname, IntPtr param) {
            Pointers.glTexEnvx(target, pname, param);
        }
        
        public static void glTexEnvxOES(int target, int pname, IntPtr param) {
            Pointers.glTexEnvxOES(target, pname, param);
        }
        
        public static void glTexEnvxv(int target, int pname, IntPtr* _params) {
            Pointers.glTexEnvxv(target, pname, _params);
        }
        
        public static void glTexEnvxv(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glTexEnvxv(target, pname, _params_);
        }
        
        public static void glTexEnvxvOES(int target, int pname, IntPtr* _params) {
            Pointers.glTexEnvxvOES(target, pname, _params);
        }
        
        public static void glTexEnvxvOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glTexEnvxvOES(target, pname, _params_);
        }
        
        public static void glTexFilterFuncSGIS(int target, int filter, int n, float* weights) {
            Pointers.glTexFilterFuncSGIS(target, filter, n, weights);
        }
        
        public static void glTexFilterFuncSGIS(int target, int filter, int n, float[] weights) {
            fixed(float* weights_ = &weights[0])
                Pointers.glTexFilterFuncSGIS(target, filter, n, weights_);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="param">
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR,
        /// GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </param>
        public static void glTexGend(int coord, int pname, double param) {
            Pointers.glTexGend(coord, pname, param);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        public static void glTexGendv(int coord, int pname, double* _params) {
            Pointers.glTexGendv(coord, pname, _params);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        public static void glTexGendv(int coord, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glTexGendv(coord, pname, _params_);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="param">
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR,
        /// GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </param>
        public static void glTexGenf(int coord, int pname, float param) {
            Pointers.glTexGenf(coord, pname, param);
        }
        
        public static void glTexGenfOES(int coord, int pname, float param) {
            Pointers.glTexGenfOES(coord, pname, param);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        public static void glTexGenfv(int coord, int pname, float* _params) {
            Pointers.glTexGenfv(coord, pname, _params);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        public static void glTexGenfv(int coord, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glTexGenfv(coord, pname, _params_);
        }
        
        public static void glTexGenfvOES(int coord, int pname, float* _params) {
            Pointers.glTexGenfvOES(coord, pname, _params);
        }
        
        public static void glTexGenfvOES(int coord, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glTexGenfvOES(coord, pname, _params_);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="param">
        /// Specifies a single-valued texture generation parameter, one of GL_OBJECT_LINEAR, GL_EYE_LINEAR,
        /// GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP.
        /// </param>
        public static void glTexGeni(int coord, int pname, int param) {
            Pointers.glTexGeni(coord, pname, param);
        }
        
        public static void glTexGeniOES(int coord, int pname, int param) {
            Pointers.glTexGeniOES(coord, pname, param);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        public static void glTexGeniv(int coord, int pname, int* _params) {
            Pointers.glTexGeniv(coord, pname, _params);
        }
        
        /// <summary>
        /// control the generation of texture coordinates
        /// <para>
        /// glTexGen selects a texture-coordinate generation function or supplies coefficients for one of the
        /// functions. coord names one of the (s, t, r, q) texture coordinates; it must be one of the symbols
        /// GL_S, GL_T, GL_R, or GL_Q. pname must be one of three symbolic constants: GL_TEXTURE_GEN_MODE,
        /// GL_OBJECT_PLANE, or GL_EYE_PLANE. If pname is GL_TEXTURE_GEN_MODE, then params chooses a mode, one
        /// of GL_OBJECT_LINEAR, GL_EYE_LINEAR, GL_SPHERE_MAP, GL_NORMAL_MAP, or GL_REFLECTION_MAP. If pname is
        /// either GL_OBJECT_PLANE or GL_EYE_PLANE, params contains coefficients for the corresponding texture
        /// generation function
        /// </para>
        /// </summary>
        /// <param name="coord">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of the texture-coordinate generation function. Must be
        /// GL_TEXTURE_GEN_MODE.
        /// </param>
        /// <param name="_params">
        /// Specifies a texture coordinate. Must be one of GL_S, GL_T, GL_R, or GL_Q.
        /// </param>
        public static void glTexGeniv(int coord, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTexGeniv(coord, pname, _params_);
        }
        
        public static void glTexGenivOES(int coord, int pname, int* _params) {
            Pointers.glTexGenivOES(coord, pname, _params);
        }
        
        public static void glTexGenivOES(int coord, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTexGenivOES(coord, pname, _params_);
        }
        
        public static void glTexGenxOES(int coord, int pname, IntPtr param) {
            Pointers.glTexGenxOES(coord, pname, param);
        }
        
        public static void glTexGenxvOES(int coord, int pname, IntPtr* _params) {
            Pointers.glTexGenxvOES(coord, pname, _params);
        }
        
        public static void glTexGenxvOES(int coord, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glTexGenxvOES(coord, pname, _params_);
        }
        
        /// <summary>
        /// specify a one-dimensional texture image
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled. To enable and disable one-dimensional texturing, call glEnable and glDisable
        /// with argument GL_TEXTURE_1D
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given
        /// in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal
        /// formats given in Table 3, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at
        /// least 1024 texels wide. The height of the 1D texture image is 1.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER,
        /// GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexImage1D(int target, int level, int internalformat, int width, int border, int format, int type, IntPtr pixels) {
            Pointers.glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
        }
        
        /// <summary>
        /// specify a two-dimensional texture image
        /// <para>
        /// Texturing allows elements of an image array to be read by shaders
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_1D_ARRAY,
        /// GL_PROXY_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_RECTANGLE,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
        /// GL_PROXY_TEXTURE_CUBE_MAP.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image. If target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE, level must be 0.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given
        /// in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal
        /// formats given in Table 3, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support texture images that are at
        /// least 1024 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image, or the number of layers in a texture array, in the case
        /// of the GL_TEXTURE_1D_ARRAY and GL_PROXY_TEXTURE_1D_ARRAY targets. All implementations support 2D
        /// texture images that are at least 1024 texels high, and texture arrays that are at least 256 layers
        /// deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER,
        /// GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexImage2D(int target, int level, int internalformat, int width, int height, int border, int format, int type, IntPtr pixels) {
            Pointers.glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
        }
        
        /// <summary>
        /// establish the data storage, format, dimensions, and number of samples of a multisample texture's image
        /// <para>
        /// glTexImage2DMultisample establishes the data storage, format, dimensions and number of samples of a
        /// multisample texture's image
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE or
        /// GL_PROXY_TEXTURE_2D_MULTISAMPLE.
        /// </param>
        /// <param name="samples">
        /// The number of samples in the multisample texture's image.
        /// </param>
        /// <param name="internalformat">
        /// The internal format to be used to store the multisample texture's image. internalformat must specify
        /// a color-renderable, depth-renderable, or stencil-renderable format.
        /// </param>
        /// <param name="width">
        /// The width of the multisample texture's image, in texels.
        /// </param>
        /// <param name="height">
        /// The height of the multisample texture's image, in texels.
        /// </param>
        /// <param name="fixedsamplelocations">
        /// Specifies whether the image will use identical sample locations and the same number of samples for
        /// all texels in the image, and the sample locations will not depend on the internal format or size of
        /// the image.
        /// </param>
        public static void glTexImage2DMultisample(int target, int samples, int internalformat, int width, int height, bool fixedsamplelocations) {
            Pointers.glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
        }
        
        public static void glTexImage2DMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            Pointers.glTexImage2DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
        }
        
        /// <summary>
        /// specify a three-dimensional texture image
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled. To enable and disable three-dimensional texturing, call glEnable and glDisable
        /// with argument GL_TEXTURE_3D
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY
        /// or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given
        /// in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal
        /// formats given in Table 3, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at
        /// least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All
        /// implementations support 3D texture images that are at least 256 texels deep, and texture arrays that
        /// are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER,
        /// GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexImage3D(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels) {
            Pointers.glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
        }
        
        /// <summary>
        /// specify a three-dimensional texture image
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled. To enable and disable three-dimensional texturing, call glEnable and glDisable
        /// with argument GL_TEXTURE_3D
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target texture. Must be one of GL_TEXTURE_3D, GL_PROXY_TEXTURE_3D, GL_TEXTURE_2D_ARRAY
        /// or GL_PROXY_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the n th mipmap
        /// reduction image.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the number of color components in the texture. Must be one of base internal formats given
        /// in Table 1, one of the sized internal formats given in Table 2, or one of the compressed internal
        /// formats given in Table 3, below.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture image. All implementations support 3D texture images that are at
        /// least 16 texels wide.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture image. All implementations support 3D texture images that are at
        /// least 256 texels high.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture image, or the number of layers in a texture array. All
        /// implementations support 3D texture images that are at least 256 texels deep, and texture arrays that
        /// are at least 256 layers deep.
        /// </param>
        /// <param name="border">
        /// This value must be 0.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_RED_INTEGER, GL_RG_INTEGER, GL_RGB_INTEGER, GL_BGR_INTEGER,
        /// GL_RGBA_INTEGER, GL_BGRA_INTEGER, GL_STENCIL_INDEX, GL_DEPTH_COMPONENT, GL_DEPTH_STENCIL.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexImage3DEXT(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels) {
            Pointers.glTexImage3DEXT(target, level, internalformat, width, height, depth, border, format, type, pixels);
        }
        
        /// <summary>
        /// establish the data storage, format, dimensions, and number of samples of a multisample texture's image
        /// <para>
        /// glTexImage3DMultisample establishes the data storage, format, dimensions and number of samples of a
        /// multisample texture's image
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target of the operation. target must be GL_TEXTURE_2D_MULTISAMPLE_ARRAY or
        /// GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </param>
        /// <param name="samples">
        /// The number of samples in the multisample texture's image.
        /// </param>
        /// <param name="internalformat">
        /// The internal format to be used to store the multisample texture's image. internalformat must specify
        /// a color-renderable, depth-renderable, or stencil-renderable format.
        /// </param>
        /// <param name="width">
        /// The width of the multisample texture's image, in texels.
        /// </param>
        /// <param name="height">
        /// The height of the multisample texture's image, in texels.
        /// </param>
        /// <param name="depth"> </param>
        /// <param name="fixedsamplelocations">
        /// Specifies whether the image will use identical sample locations and the same number of samples for
        /// all texels in the image, and the sample locations will not depend on the internal format or size of
        /// the image.
        /// </param>
        public static void glTexImage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            Pointers.glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        public static void glTexImage3DMultisampleCoverageNV(int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            Pointers.glTexImage3DMultisampleCoverageNV(target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
        }
        
        public static void glTexImage3DOES(int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels) {
            Pointers.glTexImage3DOES(target, level, internalformat, width, height, depth, border, format, type, pixels);
        }
        
        public static void glTexImage4DSGIS(int target, int level, int internalformat, int width, int height, int depth, int size4d, int border, int format, int type, IntPtr pixels) {
            Pointers.glTexImage4DSGIS(target, level, internalformat, width, height, depth, size4d, border, format, type, pixels);
        }
        
        public static void glTexPageCommitmentARB(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) {
            Pointers.glTexPageCommitmentARB(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
        }
        
        public static void glTexPageCommitmentEXT(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) {
            Pointers.glTexPageCommitmentEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, commit);
        }
        
        public static void glTexParameterIiv(int target, int pname, int* _params) {
            Pointers.glTexParameterIiv(target, pname, _params);
        }
        
        public static void glTexParameterIiv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTexParameterIiv(target, pname, _params_);
        }
        
        public static void glTexParameterIivEXT(int target, int pname, int* _params) {
            Pointers.glTexParameterIivEXT(target, pname, _params);
        }
        
        public static void glTexParameterIivEXT(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTexParameterIivEXT(target, pname, _params_);
        }
        
        public static void glTexParameterIivOES(int target, int pname, int* _params) {
            Pointers.glTexParameterIivOES(target, pname, _params);
        }
        
        public static void glTexParameterIivOES(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTexParameterIivOES(target, pname, _params_);
        }
        
        public static void glTexParameterIuiv(int target, int pname, uint* _params) {
            Pointers.glTexParameterIuiv(target, pname, _params);
        }
        
        public static void glTexParameterIuiv(int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glTexParameterIuiv(target, pname, _params_);
        }
        
        public static void glTexParameterIuivEXT(int target, int pname, uint* _params) {
            Pointers.glTexParameterIuivEXT(target, pname, _params);
        }
        
        public static void glTexParameterIuivEXT(int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glTexParameterIuivEXT(target, pname, _params_);
        }
        
        public static void glTexParameterIuivOES(int target, int pname, uint* _params) {
            Pointers.glTexParameterIuivOES(target, pname, _params);
        }
        
        public static void glTexParameterIuivOES(int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glTexParameterIuivOES(target, pname, _params_);
        }
        
        /// <summary>
        /// set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
        /// GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or
        /// GL_TEXTURE_RECTANGLE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following:
        /// GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S,
        /// GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        public static void glTexParameterf(int target, int pname, float param) {
            Pointers.glTexParameterf(target, pname, param);
        }
        
        /// <summary>
        /// set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
        /// GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or
        /// GL_TEXTURE_RECTANGLE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following:
        /// GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S,
        /// GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </param>
        /// <param name="_params">
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are
        /// stored.
        /// </param>
        public static void glTexParameterfv(int target, int pname, float* _params) {
            Pointers.glTexParameterfv(target, pname, _params);
        }
        
        /// <summary>
        /// set texture parameters
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexParameter functions. Must be one of
        /// GL_TEXTURE_1D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_2D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_2D_MULTISAMPLE,
        /// GL_TEXTURE_2D_MULTISAMPLE_ARRAY, GL_TEXTURE_3D, GL_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_ARRAY, or
        /// GL_TEXTURE_RECTANGLE.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following:
        /// GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S,
        /// GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </param>
        /// <param name="_params">
        /// For the vector commands, specifies a pointer to an array where the value or values of pname are
        /// stored.
        /// </param>
        public static void glTexParameterfv(int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glTexParameterfv(target, pname, _params_);
        }
        
        public static void glTexParameteri(int target, int pname, int param) {
            Pointers.glTexParameteri(target, pname, param);
        }
        
        public static void glTexParameteriv(int target, int pname, int* _params) {
            Pointers.glTexParameteriv(target, pname, _params);
        }
        
        public static void glTexParameteriv(int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTexParameteriv(target, pname, _params_);
        }
        
        public static void glTexParameterx(int target, int pname, IntPtr param) {
            Pointers.glTexParameterx(target, pname, param);
        }
        
        public static void glTexParameterxOES(int target, int pname, IntPtr param) {
            Pointers.glTexParameterxOES(target, pname, param);
        }
        
        public static void glTexParameterxv(int target, int pname, IntPtr* _params) {
            Pointers.glTexParameterxv(target, pname, _params);
        }
        
        public static void glTexParameterxv(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glTexParameterxv(target, pname, _params_);
        }
        
        public static void glTexParameterxvOES(int target, int pname, IntPtr* _params) {
            Pointers.glTexParameterxvOES(target, pname, _params);
        }
        
        public static void glTexParameterxvOES(int target, int pname, IntPtr[] _params) {
            fixed(IntPtr* _params_ = &_params[0])
                Pointers.glTexParameterxvOES(target, pname, _params_);
        }
        
        public static void glTexRenderbufferNV(int target, uint renderbuffer) {
            Pointers.glTexRenderbufferNV(target, renderbuffer);
        }
        
        /// <summary>
        /// simultaneously specify storage for all levels of a one-dimensional texture
        /// <para>
        /// glTexStorage1D and glTextureStorage1D specify the storage requirements for all levels of a
        /// one-dimensional texture simultaneously. Once a texture is specified with this command, the format
        /// and dimensions of all levels become immutable unless it is a proxy texture. The contents of the
        /// image may still be modified, however, its storage requirements may not change. Such a texture is
        /// referred to as an immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of
        /// GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        public static void glTexStorage1D(int target, int levels, int internalformat, int width) {
            Pointers.glTexStorage1D(target, levels, internalformat, width);
        }
        
        /// <summary>
        /// simultaneously specify storage for all levels of a one-dimensional texture
        /// <para>
        /// glTexStorage1D and glTextureStorage1D specify the storage requirements for all levels of a
        /// one-dimensional texture simultaneously. Once a texture is specified with this command, the format
        /// and dimensions of all levels become immutable unless it is a proxy texture. The contents of the
        /// image may still be modified, however, its storage requirements may not change. Such a texture is
        /// referred to as an immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage1D. Must be one of
        /// GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        public static void glTexStorage1DEXT(int target, int levels, int internalformat, int width) {
            Pointers.glTexStorage1DEXT(target, levels, internalformat, width);
        }
        
        /// <summary>
        /// simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// <para>
        /// glTexStorage2D and glTextureStorage2D specify the storage requirements for all levels of a
        /// two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified
        /// with this command, the format and dimensions of all levels become immutable unless it is a proxy
        /// texture. The contents of the image may still be modified, however, its storage requirements may not
        /// change. Such a texture is referred to as an immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of
        /// GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D,
        /// GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        public static void glTexStorage2D(int target, int levels, int internalformat, int width, int height) {
            Pointers.glTexStorage2D(target, levels, internalformat, width, height);
        }
        
        /// <summary>
        /// simultaneously specify storage for all levels of a two-dimensional or one-dimensional array texture
        /// <para>
        /// glTexStorage2D and glTextureStorage2D specify the storage requirements for all levels of a
        /// two-dimensional texture or one-dimensional texture array simultaneously. Once a texture is specified
        /// with this command, the format and dimensions of all levels become immutable unless it is a proxy
        /// texture. The contents of the image may still be modified, however, its storage requirements may not
        /// change. Such a texture is referred to as an immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage2D. Must be one of
        /// GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_TEXTURE_CUBE_MAP, GL_PROXY_TEXTURE_2D,
        /// GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_CUBE_MAP.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        public static void glTexStorage2DEXT(int target, int levels, int internalformat, int width, int height) {
            Pointers.glTexStorage2DEXT(target, levels, internalformat, width, height);
        }
        
        /// <summary>
        /// specify storage for a two-dimensional multisample texture
        /// <para>
        /// glTexStorage2DMultisample and glTextureStorage2DMultisample specify the storage requirements for a
        /// two-dimensional multisample texture. Once a texture is specified with this command, its format and
        /// dimensions become immutable unless it is a proxy texture. The contents of the image may still be
        /// modified, however, its storage requirements may not change. Such a texture is referred to as an
        /// immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage2DMultisample. Must be one
        /// of GL_TEXTURE_2D_MULTISAMPLE or GL_PROXY_TEXTURE_2D_MULTISAMPLE.
        /// </param>
        /// <param name="samples">
        /// Specify the number of samples in the texture.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        /// <param name="fixedsamplelocations">
        /// Specifies whether the image will use identical sample locations and the same number of samples for
        /// all texels in the image, and the sample locations will not depend on the internal format or size of
        /// the image.
        /// </param>
        public static void glTexStorage2DMultisample(int target, int samples, int internalformat, int width, int height, bool fixedsamplelocations) {
            Pointers.glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
        }
        
        /// <summary>
        /// simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// <para>
        /// glTexStorage3D and glTextureStorage3D specify specify the storage requirements for all levels of a
        /// three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is
        /// specified with this command, the format and dimensions of all levels become immutable unless it is a
        /// proxy texture. The contents of the image may still be modified, however, its storage requirements
        /// may not change. Such a texture is referred to as an immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of
        /// GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D,
        /// GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture, in texels.
        /// </param>
        public static void glTexStorage3D(int target, int levels, int internalformat, int width, int height, int depth) {
            Pointers.glTexStorage3D(target, levels, internalformat, width, height, depth);
        }
        
        /// <summary>
        /// simultaneously specify storage for all levels of a three-dimensional, two-dimensional array or cube-map array texture
        /// <para>
        /// glTexStorage3D and glTextureStorage3D specify specify the storage requirements for all levels of a
        /// three-dimensional, two-dimensional array or cube-map array texture simultaneously. Once a texture is
        /// specified with this command, the format and dimensions of all levels become immutable unless it is a
        /// proxy texture. The contents of the image may still be modified, however, its storage requirements
        /// may not change. Such a texture is referred to as an immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage3D. Must be one of
        /// GL_TEXTURE_3D, GL_TEXTURE_2D_ARRAY, GL_TEXTURE_CUBE_MAP_ARRAY, GL_PROXY_TEXTURE_3D,
        /// GL_PROXY_TEXTURE_2D_ARRAY or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY.
        /// </param>
        /// <param name="levels">
        /// Specify the number of texture levels.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture, in texels.
        /// </param>
        public static void glTexStorage3DEXT(int target, int levels, int internalformat, int width, int height, int depth) {
            Pointers.glTexStorage3DEXT(target, levels, internalformat, width, height, depth);
        }
        
        /// <summary>
        /// specify storage for a two-dimensional multisample array texture
        /// <para>
        /// glTexStorage3DMultisample and glTextureStorage3DMultisample specify the storage requirements for a
        /// two-dimensional multisample array texture. Once a texture is specified with this command, its format
        /// and dimensions become immutable unless it is a proxy texture. The contents of the image may still be
        /// modified, however, its storage requirements may not change. Such a texture is referred to as an
        /// immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one
        /// of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </param>
        /// <param name="samples">
        /// Specify the number of samples in the texture.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture, in layers.
        /// </param>
        /// <param name="fixedsamplelocations">
        /// Specifies whether the image will use identical sample locations and the same number of samples for
        /// all texels in the image, and the sample locations will not depend on the internal format or size of
        /// the image.
        /// </param>
        public static void glTexStorage3DMultisample(int target, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            Pointers.glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        /// <summary>
        /// specify storage for a two-dimensional multisample array texture
        /// <para>
        /// glTexStorage3DMultisample and glTextureStorage3DMultisample specify the storage requirements for a
        /// two-dimensional multisample array texture. Once a texture is specified with this command, its format
        /// and dimensions become immutable unless it is a proxy texture. The contents of the image may still be
        /// modified, however, its storage requirements may not change. Such a texture is referred to as an
        /// immutable-format texture
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture object is bound for glTexStorage3DMultisample. Must be one
        /// of GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_PROXY_TEXTURE_2D_MULTISAMPLE_ARRAY.
        /// </param>
        /// <param name="samples">
        /// Specify the number of samples in the texture.
        /// </param>
        /// <param name="internalformat">
        /// Specifies the sized internal format to be used to store texture image data.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture, in texels.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture, in texels.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture, in layers.
        /// </param>
        /// <param name="fixedsamplelocations">
        /// Specifies whether the image will use identical sample locations and the same number of samples for
        /// all texels in the image, and the sample locations will not depend on the internal format or size of
        /// the image.
        /// </param>
        public static void glTexStorage3DMultisampleOES(int target, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            Pointers.glTexStorage3DMultisampleOES(target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        public static void glTexStorageMem1DEXT(int target, int levels, int internalFormat, int width, uint memory, ulong offset) {
            Pointers.glTexStorageMem1DEXT(target, levels, internalFormat, width, memory, offset);
        }
        
        public static void glTexStorageMem2DEXT(int target, int levels, int internalFormat, int width, int height, uint memory, ulong offset) {
            Pointers.glTexStorageMem2DEXT(target, levels, internalFormat, width, height, memory, offset);
        }
        
        public static void glTexStorageMem2DMultisampleEXT(int target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) {
            Pointers.glTexStorageMem2DMultisampleEXT(target, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
        }
        
        public static void glTexStorageMem3DEXT(int target, int levels, int internalFormat, int width, int height, int depth, uint memory, ulong offset) {
            Pointers.glTexStorageMem3DEXT(target, levels, internalFormat, width, height, depth, memory, offset);
        }
        
        public static void glTexStorageMem3DMultisampleEXT(int target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) {
            Pointers.glTexStorageMem3DMultisampleEXT(target, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
        }
        
        public static void glTexStorageSparseAMD(int target, int internalFormat, int width, int height, int depth, int layers, uint flags) {
            Pointers.glTexStorageSparseAMD(target, internalFormat, width, height, depth, layers, flags);
        }
        
        public static void glTexStorageSparseAMD(int target, int internalFormat, int width, int height, int depth, int layers, Enums.TextureStorageMaskAMD flags) {
            Pointers.glTexStorageSparseAMD(target, internalFormat, width, height, depth, layers, (uint)flags);
        }
        
        /// <summary>
        /// specify a one-dimensional texture subimage
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled. To enable or disable one-dimensional texturing, call glEnable and glDisable
        /// with argument GL_TEXTURE_1D
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexSubImage1D. Must be GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexSubImage1D(int target, int level, int xoffset, int width, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
        }
        
        /// <summary>
        /// specify a one-dimensional texture subimage
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled. To enable or disable one-dimensional texturing, call glEnable and glDisable
        /// with argument GL_TEXTURE_1D
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexSubImage1D. Must be GL_TEXTURE_1D.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexSubImage1DEXT(int target, int level, int xoffset, int width, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage1DEXT(target, level, xoffset, width, format, type, pixels);
        }
        
        /// <summary>
        /// specify a two-dimensional texture subimage
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexSubImage2D. Must be GL_TEXTURE_2D,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
        /// GL_TEXTURE_1D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        
        /// <summary>
        /// specify a two-dimensional texture subimage
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexSubImage2D. Must be GL_TEXTURE_2D,
        /// GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y,
        /// GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or
        /// GL_TEXTURE_1D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_BGRA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexSubImage2DEXT(int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage2DEXT(target, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        
        /// <summary>
        /// specify a three-dimensional texture subimage
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexSubImage3D. Must be GL_TEXTURE_3D or
        /// GL_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexSubImage3D(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        /// <summary>
        /// specify a three-dimensional texture subimage
        /// <para>
        /// Texturing maps a portion of a specified texture image onto each graphical primitive for which
        /// texturing is enabled
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the texture is bound for glTexSubImage3D. Must be GL_TEXTURE_3D or
        /// GL_TEXTURE_2D_ARRAY.
        /// </param>
        /// <param name="level">
        /// Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap
        /// reduction image.
        /// </param>
        /// <param name="xoffset">
        /// Specifies a texel offset in the x direction within the texture array.
        /// </param>
        /// <param name="yoffset">
        /// Specifies a texel offset in the y direction within the texture array.
        /// </param>
        /// <param name="zoffset">
        /// Specifies a texel offset in the z direction within the texture array.
        /// </param>
        /// <param name="width">
        /// Specifies the width of the texture subimage.
        /// </param>
        /// <param name="height">
        /// Specifies the height of the texture subimage.
        /// </param>
        /// <param name="depth">
        /// Specifies the depth of the texture subimage.
        /// </param>
        /// <param name="format">
        /// Specifies the format of the pixel data. The following symbolic values are accepted: GL_RED, GL_RG,
        /// GL_RGB, GL_BGR, GL_RGBA, GL_DEPTH_COMPONENT, and GL_STENCIL_INDEX.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of the pixel data. The following symbolic values are accepted:
        /// GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT, GL_UNSIGNED_INT, GL_INT, GL_FLOAT,
        /// GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5,
        /// GL_UNSIGNED_SHORT_5_6_5_REV, GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV,
        /// GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8,
        /// GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, and GL_UNSIGNED_INT_2_10_10_10_REV.
        /// </param>
        /// <param name="pixels">
        /// Specifies a pointer to the image data in memory.
        /// </param>
        public static void glTexSubImage3DEXT(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage3DEXT(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        public static void glTexSubImage3DOES(int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        public static void glTexSubImage4DSGIS(int target, int level, int xoffset, int yoffset, int zoffset, int woffset, int width, int height, int depth, int size4d, int format, int type, IntPtr pixels) {
            Pointers.glTexSubImage4DSGIS(target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels);
        }
        
        /// <summary>
        /// controls the ordering of reads and writes to rendered fragments across drawing commands
        /// <para>
        /// The values of rendered fragments are undefined when a shader stage fetches texels and the same
        /// texels are written via fragment shader outputs, even if the reads and writes are not in the same
        /// drawing command. To safely read the result of a written texel via a texel fetch in a subsequent
        /// drawing command, call glTextureBarrier between the two drawing commands to guarantee that writes
        /// have completed and caches have been invalidated before subsequent drawing commands are executed
        /// </para>
        /// </summary>
        public static void glTextureBarrier() {
            Pointers.glTextureBarrier();
        }
        
        public static void glTextureBarrierNV() {
            Pointers.glTextureBarrierNV();
        }
        
        public static void glTextureBuffer(uint texture, int internalformat, uint buffer) {
            Pointers.glTextureBuffer(texture, internalformat, buffer);
        }
        
        public static void glTextureBufferEXT(uint texture, int target, int internalformat, uint buffer) {
            Pointers.glTextureBufferEXT(texture, target, internalformat, buffer);
        }
        
        public static void glTextureBufferRange(uint texture, int internalformat, uint buffer, uint offset, uint size) {
            Pointers.glTextureBufferRange(texture, internalformat, buffer, offset, size);
        }
        
        public static void glTextureBufferRangeEXT(uint texture, int target, int internalformat, uint buffer, uint offset, uint size) {
            Pointers.glTextureBufferRangeEXT(texture, target, internalformat, buffer, offset, size);
        }
        
        public static void glTextureColorMaskSGIS(bool red, bool green, bool blue, bool alpha) {
            Pointers.glTextureColorMaskSGIS(red, green, blue, alpha);
        }
        
        public static void glTextureFoveationParametersQCOM(uint texture, uint layer, uint focalPoint, float focalX, float focalY, float gainX, float gainY, float foveaArea) {
            Pointers.glTextureFoveationParametersQCOM(texture, layer, focalPoint, focalX, focalY, gainX, gainY, foveaArea);
        }
        
        public static void glTextureImage1DEXT(uint texture, int target, int level, int internalformat, int width, int border, int format, int type, IntPtr pixels) {
            Pointers.glTextureImage1DEXT(texture, target, level, internalformat, width, border, format, type, pixels);
        }
        
        public static void glTextureImage2DEXT(uint texture, int target, int level, int internalformat, int width, int height, int border, int format, int type, IntPtr pixels) {
            Pointers.glTextureImage2DEXT(texture, target, level, internalformat, width, height, border, format, type, pixels);
        }
        
        public static void glTextureImage2DMultisampleCoverageNV(uint texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            Pointers.glTextureImage2DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations);
        }
        
        public static void glTextureImage2DMultisampleNV(uint texture, int target, int samples, int internalFormat, int width, int height, bool fixedSampleLocations) {
            Pointers.glTextureImage2DMultisampleNV(texture, target, samples, internalFormat, width, height, fixedSampleLocations);
        }
        
        public static void glTextureImage3DEXT(uint texture, int target, int level, int internalformat, int width, int height, int depth, int border, int format, int type, IntPtr pixels) {
            Pointers.glTextureImage3DEXT(texture, target, level, internalformat, width, height, depth, border, format, type, pixels);
        }
        
        public static void glTextureImage3DMultisampleCoverageNV(uint texture, int target, int coverageSamples, int colorSamples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            Pointers.glTextureImage3DMultisampleCoverageNV(texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations);
        }
        
        public static void glTextureImage3DMultisampleNV(uint texture, int target, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations) {
            Pointers.glTextureImage3DMultisampleNV(texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations);
        }
        
        public static void glTextureLightEXT(int pname) {
            Pointers.glTextureLightEXT(pname);
        }
        
        public static void glTextureMaterialEXT(int face, int mode) {
            Pointers.glTextureMaterialEXT(face, mode);
        }
        
        public static void glTextureNormalEXT(int mode) {
            Pointers.glTextureNormalEXT(mode);
        }
        
        public static void glTexturePageCommitmentEXT(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, bool commit) {
            Pointers.glTexturePageCommitmentEXT(texture, level, xoffset, yoffset, zoffset, width, height, depth, commit);
        }
        
        public static void glTextureParameterIiv(uint texture, int pname, int* _params) {
            Pointers.glTextureParameterIiv(texture, pname, _params);
        }
        
        public static void glTextureParameterIiv(uint texture, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTextureParameterIiv(texture, pname, _params_);
        }
        
        public static void glTextureParameterIivEXT(uint texture, int target, int pname, int* _params) {
            Pointers.glTextureParameterIivEXT(texture, target, pname, _params);
        }
        
        public static void glTextureParameterIivEXT(uint texture, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTextureParameterIivEXT(texture, target, pname, _params_);
        }
        
        public static void glTextureParameterIuiv(uint texture, int pname, uint* _params) {
            Pointers.glTextureParameterIuiv(texture, pname, _params);
        }
        
        public static void glTextureParameterIuiv(uint texture, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glTextureParameterIuiv(texture, pname, _params_);
        }
        
        public static void glTextureParameterIuivEXT(uint texture, int target, int pname, uint* _params) {
            Pointers.glTextureParameterIuivEXT(texture, target, pname, _params);
        }
        
        public static void glTextureParameterIuivEXT(uint texture, int target, int pname, uint[] _params) {
            fixed(uint* _params_ = &_params[0])
                Pointers.glTextureParameterIuivEXT(texture, target, pname, _params_);
        }
        
        /// <summary>
        /// set texture parameters
        /// </summary>
        /// <param name="texture">
        /// Specifies the texture object name for glTextureParameter functions.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following:
        /// GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S,
        /// GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </param>
        /// <param name="param">
        /// For the scalar commands, specifies the value of pname.
        /// </param>
        public static void glTextureParameterf(uint texture, int pname, float param) {
            Pointers.glTextureParameterf(texture, pname, param);
        }
        
        public static void glTextureParameterfEXT(uint texture, int target, int pname, float param) {
            Pointers.glTextureParameterfEXT(texture, target, pname, param);
        }
        
        /// <summary>
        /// set texture parameters
        /// </summary>
        /// <param name="texture">
        /// Specifies the texture object name for glTextureParameter functions.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following:
        /// GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S,
        /// GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </param>
        /// <param name="param">
        /// Specifies the texture object name for glTextureParameter functions.
        /// </param>
        public static void glTextureParameterfv(uint texture, int pname, float* param) {
            Pointers.glTextureParameterfv(texture, pname, param);
        }
        
        /// <summary>
        /// set texture parameters
        /// </summary>
        /// <param name="texture">
        /// Specifies the texture object name for glTextureParameter functions.
        /// </param>
        /// <param name="pname">
        /// Specifies the symbolic name of a single-valued texture parameter. pname can be one of the following:
        /// GL_DEPTH_STENCIL_TEXTURE_MODE, GL_TEXTURE_BASE_LEVEL, GL_TEXTURE_COMPARE_FUNC,
        /// GL_TEXTURE_COMPARE_MODE, GL_TEXTURE_LOD_BIAS, GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER,
        /// GL_TEXTURE_MIN_LOD, GL_TEXTURE_MAX_LOD, GL_TEXTURE_MAX_LEVEL, GL_TEXTURE_SWIZZLE_R,
        /// GL_TEXTURE_SWIZZLE_G, GL_TEXTURE_SWIZZLE_B, GL_TEXTURE_SWIZZLE_A, GL_TEXTURE_WRAP_S,
        /// GL_TEXTURE_WRAP_T, or GL_TEXTURE_WRAP_R.
        /// </param>
        /// <param name="param">
        /// Specifies the texture object name for glTextureParameter functions.
        /// </param>
        public static void glTextureParameterfv(uint texture, int pname, float[] param) {
            fixed(float* param_ = &param[0])
                Pointers.glTextureParameterfv(texture, pname, param_);
        }
        
        public static void glTextureParameterfvEXT(uint texture, int target, int pname, float* _params) {
            Pointers.glTextureParameterfvEXT(texture, target, pname, _params);
        }
        
        public static void glTextureParameterfvEXT(uint texture, int target, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glTextureParameterfvEXT(texture, target, pname, _params_);
        }
        
        public static void glTextureParameteri(uint texture, int pname, int param) {
            Pointers.glTextureParameteri(texture, pname, param);
        }
        
        public static void glTextureParameteriEXT(uint texture, int target, int pname, int param) {
            Pointers.glTextureParameteriEXT(texture, target, pname, param);
        }
        
        public static void glTextureParameteriv(uint texture, int pname, int* param) {
            Pointers.glTextureParameteriv(texture, pname, param);
        }
        
        public static void glTextureParameteriv(uint texture, int pname, int[] param) {
            fixed(int* param_ = &param[0])
                Pointers.glTextureParameteriv(texture, pname, param_);
        }
        
        public static void glTextureParameterivEXT(uint texture, int target, int pname, int* _params) {
            Pointers.glTextureParameterivEXT(texture, target, pname, _params);
        }
        
        public static void glTextureParameterivEXT(uint texture, int target, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glTextureParameterivEXT(texture, target, pname, _params_);
        }
        
        public static void glTextureRangeAPPLE(int target, int length, IntPtr pointer) {
            Pointers.glTextureRangeAPPLE(target, length, pointer);
        }
        
        public static void glTextureRenderbufferEXT(uint texture, int target, uint renderbuffer) {
            Pointers.glTextureRenderbufferEXT(texture, target, renderbuffer);
        }
        
        public static void glTextureStorage1D(uint texture, int levels, int internalformat, int width) {
            Pointers.glTextureStorage1D(texture, levels, internalformat, width);
        }
        
        public static void glTextureStorage1DEXT(uint texture, int target, int levels, int internalformat, int width) {
            Pointers.glTextureStorage1DEXT(texture, target, levels, internalformat, width);
        }
        
        public static void glTextureStorage2D(uint texture, int levels, int internalformat, int width, int height) {
            Pointers.glTextureStorage2D(texture, levels, internalformat, width, height);
        }
        
        public static void glTextureStorage2DEXT(uint texture, int target, int levels, int internalformat, int width, int height) {
            Pointers.glTextureStorage2DEXT(texture, target, levels, internalformat, width, height);
        }
        
        public static void glTextureStorage2DMultisample(uint texture, int samples, int internalformat, int width, int height, bool fixedsamplelocations) {
            Pointers.glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
        }
        
        public static void glTextureStorage2DMultisampleEXT(uint texture, int target, int samples, int internalformat, int width, int height, bool fixedsamplelocations) {
            Pointers.glTextureStorage2DMultisampleEXT(texture, target, samples, internalformat, width, height, fixedsamplelocations);
        }
        
        public static void glTextureStorage3D(uint texture, int levels, int internalformat, int width, int height, int depth) {
            Pointers.glTextureStorage3D(texture, levels, internalformat, width, height, depth);
        }
        
        public static void glTextureStorage3DEXT(uint texture, int target, int levels, int internalformat, int width, int height, int depth) {
            Pointers.glTextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
        }
        
        public static void glTextureStorage3DMultisample(uint texture, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            Pointers.glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        public static void glTextureStorage3DMultisampleEXT(uint texture, int target, int samples, int internalformat, int width, int height, int depth, bool fixedsamplelocations) {
            Pointers.glTextureStorage3DMultisampleEXT(texture, target, samples, internalformat, width, height, depth, fixedsamplelocations);
        }
        
        public static void glTextureStorageMem1DEXT(uint texture, int levels, int internalFormat, int width, uint memory, ulong offset) {
            Pointers.glTextureStorageMem1DEXT(texture, levels, internalFormat, width, memory, offset);
        }
        
        public static void glTextureStorageMem2DEXT(uint texture, int levels, int internalFormat, int width, int height, uint memory, ulong offset) {
            Pointers.glTextureStorageMem2DEXT(texture, levels, internalFormat, width, height, memory, offset);
        }
        
        public static void glTextureStorageMem2DMultisampleEXT(uint texture, int samples, int internalFormat, int width, int height, bool fixedSampleLocations, uint memory, ulong offset) {
            Pointers.glTextureStorageMem2DMultisampleEXT(texture, samples, internalFormat, width, height, fixedSampleLocations, memory, offset);
        }
        
        public static void glTextureStorageMem3DEXT(uint texture, int levels, int internalFormat, int width, int height, int depth, uint memory, ulong offset) {
            Pointers.glTextureStorageMem3DEXT(texture, levels, internalFormat, width, height, depth, memory, offset);
        }
        
        public static void glTextureStorageMem3DMultisampleEXT(uint texture, int samples, int internalFormat, int width, int height, int depth, bool fixedSampleLocations, uint memory, ulong offset) {
            Pointers.glTextureStorageMem3DMultisampleEXT(texture, samples, internalFormat, width, height, depth, fixedSampleLocations, memory, offset);
        }
        
        public static void glTextureStorageSparseAMD(uint texture, int target, int internalFormat, int width, int height, int depth, int layers, uint flags) {
            Pointers.glTextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, flags);
        }
        
        public static void glTextureStorageSparseAMD(uint texture, int target, int internalFormat, int width, int height, int depth, int layers, Enums.TextureStorageMaskAMD flags) {
            Pointers.glTextureStorageSparseAMD(texture, target, internalFormat, width, height, depth, layers, (uint)flags);
        }
        
        public static void glTextureSubImage1D(uint texture, int level, int xoffset, int width, int format, int type, IntPtr pixels) {
            Pointers.glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels);
        }
        
        public static void glTextureSubImage1DEXT(uint texture, int target, int level, int xoffset, int width, int format, int type, IntPtr pixels) {
            Pointers.glTextureSubImage1DEXT(texture, target, level, xoffset, width, format, type, pixels);
        }
        
        public static void glTextureSubImage2D(uint texture, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels) {
            Pointers.glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        
        public static void glTextureSubImage2DEXT(uint texture, int target, int level, int xoffset, int yoffset, int width, int height, int format, int type, IntPtr pixels) {
            Pointers.glTextureSubImage2DEXT(texture, target, level, xoffset, yoffset, width, height, format, type, pixels);
        }
        
        public static void glTextureSubImage3D(uint texture, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels) {
            Pointers.glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        public static void glTextureSubImage3DEXT(uint texture, int target, int level, int xoffset, int yoffset, int zoffset, int width, int height, int depth, int format, int type, IntPtr pixels) {
            Pointers.glTextureSubImage3DEXT(texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
        }
        
        /// <summary>
        /// initialize a texture as a data alias of another texture's data store
        /// <para>
        /// glTextureView initializes a texture object as an alias, or view of another texture object, sharing
        /// some or all of the parent texture's data store with the initialized texture. texture specifies a
        /// name previously reserved by a successful call to glGenTextures but that has not yet been bound or
        /// given a target. target specifies the target for the newly initialized texture and must be compatible
        /// with the target of the parent texture, given in origtexture as specified in the following table:
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies the texture object to be initialized as a view.
        /// </param>
        /// <param name="target">
        /// Specifies the target to be used for the newly initialized texture.
        /// </param>
        /// <param name="origtexture">
        /// Specifies the name of a texture object of which to make a view.
        /// </param>
        /// <param name="internalformat"> </param>
        /// <param name="minlevel">
        /// Specifies lowest level of detail of the view.
        /// </param>
        /// <param name="numlevels">
        /// Specifies the number of levels of detail to include in the view.
        /// </param>
        /// <param name="minlayer">
        /// Specifies the index of the first layer to include in the view.
        /// </param>
        /// <param name="numlayers">
        /// Specifies the number of layers to include in the view.
        /// </param>
        public static void glTextureView(uint texture, int target, uint origtexture, int internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) {
            Pointers.glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
        }
        
        /// <summary>
        /// initialize a texture as a data alias of another texture's data store
        /// <para>
        /// glTextureView initializes a texture object as an alias, or view of another texture object, sharing
        /// some or all of the parent texture's data store with the initialized texture. texture specifies a
        /// name previously reserved by a successful call to glGenTextures but that has not yet been bound or
        /// given a target. target specifies the target for the newly initialized texture and must be compatible
        /// with the target of the parent texture, given in origtexture as specified in the following table:
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies the texture object to be initialized as a view.
        /// </param>
        /// <param name="target">
        /// Specifies the target to be used for the newly initialized texture.
        /// </param>
        /// <param name="origtexture">
        /// Specifies the name of a texture object of which to make a view.
        /// </param>
        /// <param name="internalformat"> </param>
        /// <param name="minlevel">
        /// Specifies lowest level of detail of the view.
        /// </param>
        /// <param name="numlevels">
        /// Specifies the number of levels of detail to include in the view.
        /// </param>
        /// <param name="minlayer">
        /// Specifies the index of the first layer to include in the view.
        /// </param>
        /// <param name="numlayers">
        /// Specifies the number of layers to include in the view.
        /// </param>
        public static void glTextureViewEXT(uint texture, int target, uint origtexture, int internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) {
            Pointers.glTextureViewEXT(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
        }
        
        /// <summary>
        /// initialize a texture as a data alias of another texture's data store
        /// <para>
        /// glTextureView initializes a texture object as an alias, or view of another texture object, sharing
        /// some or all of the parent texture's data store with the initialized texture. texture specifies a
        /// name previously reserved by a successful call to glGenTextures but that has not yet been bound or
        /// given a target. target specifies the target for the newly initialized texture and must be compatible
        /// with the target of the parent texture, given in origtexture as specified in the following table:
        /// </para>
        /// </summary>
        /// <param name="texture">
        /// Specifies the texture object to be initialized as a view.
        /// </param>
        /// <param name="target">
        /// Specifies the target to be used for the newly initialized texture.
        /// </param>
        /// <param name="origtexture">
        /// Specifies the name of a texture object of which to make a view.
        /// </param>
        /// <param name="internalformat"> </param>
        /// <param name="minlevel">
        /// Specifies lowest level of detail of the view.
        /// </param>
        /// <param name="numlevels">
        /// Specifies the number of levels of detail to include in the view.
        /// </param>
        /// <param name="minlayer">
        /// Specifies the index of the first layer to include in the view.
        /// </param>
        /// <param name="numlayers">
        /// Specifies the number of layers to include in the view.
        /// </param>
        public static void glTextureViewOES(uint texture, int target, uint origtexture, int internalformat, uint minlevel, uint numlevels, uint minlayer, uint numlayers) {
            Pointers.glTextureViewOES(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
        }
        
        public static void glTrackMatrixNV(int target, uint address, int matrix, int transform) {
            Pointers.glTrackMatrixNV(target, address, matrix, transform);
        }
        
        public static void glTransformFeedbackAttribsNV(int count, int* attribs, int bufferMode) {
            Pointers.glTransformFeedbackAttribsNV(count, attribs, bufferMode);
        }
        
        public static void glTransformFeedbackAttribsNV(int count, int[] attribs, int bufferMode) {
            fixed(int* attribs_ = &attribs[0])
                Pointers.glTransformFeedbackAttribsNV(count, attribs_, bufferMode);
        }
        
        /// <summary>
        /// bind a buffer object to a transform feedback buffer object
        /// <para>
        /// glTransformFeedbackBufferBase binds the buffer object buffer to the binding point at index index of
        /// the transform feedback object xfb
        /// </para>
        /// </summary>
        /// <param name="xfb">
        /// Name of the transform feedback buffer object.
        /// </param>
        /// <param name="index">
        /// Index of the binding point within xfb.
        /// </param>
        /// <param name="buffer">
        /// Name of the buffer object to bind to the specified binding point.
        /// </param>
        public static void glTransformFeedbackBufferBase(uint xfb, uint index, uint buffer) {
            Pointers.glTransformFeedbackBufferBase(xfb, index, buffer);
        }
        
        /// <summary>
        /// bind a range within a buffer object to a transform feedback buffer object
        /// <para>
        /// glTransformFeedbackBufferRange binds a range of the buffer object buffer represented by offset and
        /// size to the binding point at index index of the transform feedback object xfb
        /// </para>
        /// </summary>
        /// <param name="xfb">
        /// Name of the transform feedback buffer object.
        /// </param>
        /// <param name="index">
        /// Index of the binding point within xfb.
        /// </param>
        /// <param name="buffer">
        /// Name of the buffer object to bind to the specified binding point.
        /// </param>
        /// <param name="offset">
        /// The starting offset in basic machine units into the buffer object.
        /// </param>
        /// <param name="size">
        /// The amount of data in basic machine units that can be read from or written to the buffer object
        /// while used as an indexed target.
        /// </param>
        public static void glTransformFeedbackBufferRange(uint xfb, uint index, uint buffer, uint offset, uint size) {
            Pointers.glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
        }
        
        public static void glTransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int* bufstreams, int bufferMode) {
            Pointers.glTransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams, bufferMode);
        }
        
        public static void glTransformFeedbackStreamAttribsNV(int count, int* attribs, int nbuffers, int[] bufstreams, int bufferMode) {
            fixed(int* bufstreams_ = &bufstreams[0])
                Pointers.glTransformFeedbackStreamAttribsNV(count, attribs, nbuffers, bufstreams_, bufferMode);
        }
        
        public static void glTransformFeedbackStreamAttribsNV(int count, int[] attribs, int nbuffers, int* bufstreams, int bufferMode) {
            fixed(int* attribs_ = &attribs[0])
                Pointers.glTransformFeedbackStreamAttribsNV(count, attribs_, nbuffers, bufstreams, bufferMode);
        }
        
        public static void glTransformFeedbackStreamAttribsNV(int count, int[] attribs, int nbuffers, int[] bufstreams, int bufferMode) {
            fixed(int* attribs_ = &attribs[0])
            fixed(int* bufstreams_ = &bufstreams[0])
                Pointers.glTransformFeedbackStreamAttribsNV(count, attribs_, nbuffers, bufstreams_, bufferMode);
        }
        
        /// <summary>
        /// specify values to record in transform feedback buffers
        /// <para>
        /// The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are
        /// specified using glTransformFeedbackVaryings. When a geometry shader is active, transform feedback
        /// records the values of selected geometry shader output variables from the emitted vertices.
        /// Otherwise, the values of the selected vertex shader outputs are recorded
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="count">
        /// The number of varying variables used for transform feedback.
        /// </param>
        /// <param name="varyings">
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for
        /// transform feedback.
        /// </param>
        /// <param name="bufferMode">
        /// Identifies the mode used to capture the varying variables when transform feedback is active.
        /// bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.
        /// </param>
        public static void glTransformFeedbackVaryings(uint program, int count, string[] varyings, int bufferMode) {
            Pointers.glTransformFeedbackVaryings(program, count, varyings, bufferMode);
        }
        
        /// <summary>
        /// specify values to record in transform feedback buffers
        /// <para>
        /// The names of the vertex or geometry shader outputs to be recorded in transform feedback mode are
        /// specified using glTransformFeedbackVaryings. When a geometry shader is active, transform feedback
        /// records the values of selected geometry shader output variables from the emitted vertices.
        /// Otherwise, the values of the selected vertex shader outputs are recorded
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of the target program object.
        /// </param>
        /// <param name="count">
        /// The number of varying variables used for transform feedback.
        /// </param>
        /// <param name="varyings">
        /// An array of count zero-terminated strings specifying the names of the varying variables to use for
        /// transform feedback.
        /// </param>
        /// <param name="bufferMode">
        /// Identifies the mode used to capture the varying variables when transform feedback is active.
        /// bufferMode must be GL_INTERLEAVED_ATTRIBS or GL_SEPARATE_ATTRIBS.
        /// </param>
        public static void glTransformFeedbackVaryingsEXT(uint program, int count, string[] varyings, int bufferMode) {
            Pointers.glTransformFeedbackVaryingsEXT(program, count, varyings, bufferMode);
        }
        
        public static void glTransformFeedbackVaryingsNV(uint program, int count, int* locations, int bufferMode) {
            Pointers.glTransformFeedbackVaryingsNV(program, count, locations, bufferMode);
        }
        
        public static void glTransformFeedbackVaryingsNV(uint program, int count, int[] locations, int bufferMode) {
            fixed(int* locations_ = &locations[0])
                Pointers.glTransformFeedbackVaryingsNV(program, count, locations_, bufferMode);
        }
        
        public static void glTransformPathNV(uint resultPath, uint srcPath, int transformType, float* transformValues) {
            Pointers.glTransformPathNV(resultPath, srcPath, transformType, transformValues);
        }
        
        public static void glTransformPathNV(uint resultPath, uint srcPath, int transformType, float[] transformValues) {
            fixed(float* transformValues_ = &transformValues[0])
                Pointers.glTransformPathNV(resultPath, srcPath, transformType, transformValues_);
        }
        
        /// <summary>
        /// multiply the current matrix by a translation matrix
        /// <para>
        /// glTranslate produces a translation by x y z . The current matrix (see glMatrixMode) is multiplied by
        /// this translation matrix, with the product replacing the current matrix, as if glMultMatrix were
        /// called with the following matrix for its argument:
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </param>
        public static void glTranslated(double x, double y, double z) {
            Pointers.glTranslated(x, y, z);
        }
        
        /// <summary>
        /// multiply the current matrix by a translation matrix
        /// <para>
        /// glTranslate produces a translation by x y z . The current matrix (see glMatrixMode) is multiplied by
        /// this translation matrix, with the product replacing the current matrix, as if glMultMatrix were
        /// called with the following matrix for its argument:
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, and z coordinates of a translation vector.
        /// </param>
        public static void glTranslatef(float x, float y, float z) {
            Pointers.glTranslatef(x, y, z);
        }
        
        public static void glTranslatex(IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glTranslatex(x, y, z);
        }
        
        public static void glTranslatexOES(IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glTranslatexOES(x, y, z);
        }
        
        public static void glUniform1d(int location, double x) {
            Pointers.glUniform1d(location, x);
        }
        
        public static void glUniform1dv(int location, int count, double* value) {
            Pointers.glUniform1dv(location, count, value);
        }
        
        public static void glUniform1dv(int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniform1dv(location, count, value_);
        }
        
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>
        /// glUniform modifies the value of a uniform variable or a uniform variable array. The location of the
        /// uniform variable to be modified is specified by location, which should be a value returned by
        /// glGetUniformLocation. glUniform operates on the program object that was made part of current state
        /// by calling glUseProgram
        /// </para>
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        public static void glUniform1f(int location, float v0) {
            Pointers.glUniform1f(location, v0);
        }
        
        /// <summary>
        /// Specify the value of a uniform variable for the current program object
        /// <para>
        /// glUniform modifies the value of a uniform variable or a uniform variable array. The location of the
        /// uniform variable to be modified is specified by location, which should be a value returned by
        /// glGetUniformLocation. glUniform operates on the program object that was made part of current state
        /// by calling glUseProgram
        /// </para>
        /// </summary>
        /// <param name="location">
        /// Specifies the location of the uniform variable to be modified.
        /// </param>
        /// <param name="v0">
        /// For the scalar commands, specifies the new values to be used for the specified uniform variable.
        /// </param>
        public static void glUniform1fARB(int location, float v0) {
            Pointers.glUniform1fARB(location, v0);
        }
        
        public static void glUniform1fv(int location, int count, float* value) {
            Pointers.glUniform1fv(location, count, value);
        }
        
        public static void glUniform1fv(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform1fv(location, count, value_);
        }
        
        public static void glUniform1fvARB(int location, int count, float* value) {
            Pointers.glUniform1fvARB(location, count, value);
        }
        
        public static void glUniform1fvARB(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform1fvARB(location, count, value_);
        }
        
        public static void glUniform1i(int location, int v0) {
            Pointers.glUniform1i(location, v0);
        }
        
        public static void glUniform1i64ARB(int location, long x) {
            Pointers.glUniform1i64ARB(location, x);
        }
        
        public static void glUniform1i64NV(int location, long x) {
            Pointers.glUniform1i64NV(location, x);
        }
        
        public static void glUniform1i64vARB(int location, int count, long* value) {
            Pointers.glUniform1i64vARB(location, count, value);
        }
        
        public static void glUniform1i64vARB(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform1i64vARB(location, count, value_);
        }
        
        public static void glUniform1i64vNV(int location, int count, long* value) {
            Pointers.glUniform1i64vNV(location, count, value);
        }
        
        public static void glUniform1i64vNV(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform1i64vNV(location, count, value_);
        }
        
        public static void glUniform1iARB(int location, int v0) {
            Pointers.glUniform1iARB(location, v0);
        }
        
        public static void glUniform1iv(int location, int count, int* value) {
            Pointers.glUniform1iv(location, count, value);
        }
        
        public static void glUniform1iv(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform1iv(location, count, value_);
        }
        
        public static void glUniform1ivARB(int location, int count, int* value) {
            Pointers.glUniform1ivARB(location, count, value);
        }
        
        public static void glUniform1ivARB(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform1ivARB(location, count, value_);
        }
        
        public static void glUniform1ui(int location, uint v0) {
            Pointers.glUniform1ui(location, v0);
        }
        
        public static void glUniform1ui64ARB(int location, ulong x) {
            Pointers.glUniform1ui64ARB(location, x);
        }
        
        public static void glUniform1ui64NV(int location, ulong x) {
            Pointers.glUniform1ui64NV(location, x);
        }
        
        public static void glUniform1ui64vARB(int location, int count, ulong* value) {
            Pointers.glUniform1ui64vARB(location, count, value);
        }
        
        public static void glUniform1ui64vARB(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform1ui64vARB(location, count, value_);
        }
        
        public static void glUniform1ui64vNV(int location, int count, ulong* value) {
            Pointers.glUniform1ui64vNV(location, count, value);
        }
        
        public static void glUniform1ui64vNV(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform1ui64vNV(location, count, value_);
        }
        
        public static void glUniform1uiEXT(int location, uint v0) {
            Pointers.glUniform1uiEXT(location, v0);
        }
        
        public static void glUniform1uiv(int location, int count, uint* value) {
            Pointers.glUniform1uiv(location, count, value);
        }
        
        public static void glUniform1uiv(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform1uiv(location, count, value_);
        }
        
        public static void glUniform1uivEXT(int location, int count, uint* value) {
            Pointers.glUniform1uivEXT(location, count, value);
        }
        
        public static void glUniform1uivEXT(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform1uivEXT(location, count, value_);
        }
        
        public static void glUniform2d(int location, double x, double y) {
            Pointers.glUniform2d(location, x, y);
        }
        
        public static void glUniform2dv(int location, int count, double* value) {
            Pointers.glUniform2dv(location, count, value);
        }
        
        public static void glUniform2dv(int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniform2dv(location, count, value_);
        }
        
        public static void glUniform2f(int location, float v0, float v1) {
            Pointers.glUniform2f(location, v0, v1);
        }
        
        public static void glUniform2fARB(int location, float v0, float v1) {
            Pointers.glUniform2fARB(location, v0, v1);
        }
        
        public static void glUniform2fv(int location, int count, float* value) {
            Pointers.glUniform2fv(location, count, value);
        }
        
        public static void glUniform2fv(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform2fv(location, count, value_);
        }
        
        public static void glUniform2fvARB(int location, int count, float* value) {
            Pointers.glUniform2fvARB(location, count, value);
        }
        
        public static void glUniform2fvARB(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform2fvARB(location, count, value_);
        }
        
        public static void glUniform2i(int location, int v0, int v1) {
            Pointers.glUniform2i(location, v0, v1);
        }
        
        public static void glUniform2i64ARB(int location, long x, long y) {
            Pointers.glUniform2i64ARB(location, x, y);
        }
        
        public static void glUniform2i64NV(int location, long x, long y) {
            Pointers.glUniform2i64NV(location, x, y);
        }
        
        public static void glUniform2i64vARB(int location, int count, long* value) {
            Pointers.glUniform2i64vARB(location, count, value);
        }
        
        public static void glUniform2i64vARB(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform2i64vARB(location, count, value_);
        }
        
        public static void glUniform2i64vNV(int location, int count, long* value) {
            Pointers.glUniform2i64vNV(location, count, value);
        }
        
        public static void glUniform2i64vNV(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform2i64vNV(location, count, value_);
        }
        
        public static void glUniform2iARB(int location, int v0, int v1) {
            Pointers.glUniform2iARB(location, v0, v1);
        }
        
        public static void glUniform2iv(int location, int count, int* value) {
            Pointers.glUniform2iv(location, count, value);
        }
        
        public static void glUniform2iv(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform2iv(location, count, value_);
        }
        
        public static void glUniform2ivARB(int location, int count, int* value) {
            Pointers.glUniform2ivARB(location, count, value);
        }
        
        public static void glUniform2ivARB(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform2ivARB(location, count, value_);
        }
        
        public static void glUniform2ui(int location, uint v0, uint v1) {
            Pointers.glUniform2ui(location, v0, v1);
        }
        
        public static void glUniform2ui64ARB(int location, ulong x, ulong y) {
            Pointers.glUniform2ui64ARB(location, x, y);
        }
        
        public static void glUniform2ui64NV(int location, ulong x, ulong y) {
            Pointers.glUniform2ui64NV(location, x, y);
        }
        
        public static void glUniform2ui64vARB(int location, int count, ulong* value) {
            Pointers.glUniform2ui64vARB(location, count, value);
        }
        
        public static void glUniform2ui64vARB(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform2ui64vARB(location, count, value_);
        }
        
        public static void glUniform2ui64vNV(int location, int count, ulong* value) {
            Pointers.glUniform2ui64vNV(location, count, value);
        }
        
        public static void glUniform2ui64vNV(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform2ui64vNV(location, count, value_);
        }
        
        public static void glUniform2uiEXT(int location, uint v0, uint v1) {
            Pointers.glUniform2uiEXT(location, v0, v1);
        }
        
        public static void glUniform2uiv(int location, int count, uint* value) {
            Pointers.glUniform2uiv(location, count, value);
        }
        
        public static void glUniform2uiv(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform2uiv(location, count, value_);
        }
        
        public static void glUniform2uivEXT(int location, int count, uint* value) {
            Pointers.glUniform2uivEXT(location, count, value);
        }
        
        public static void glUniform2uivEXT(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform2uivEXT(location, count, value_);
        }
        
        public static void glUniform3d(int location, double x, double y, double z) {
            Pointers.glUniform3d(location, x, y, z);
        }
        
        public static void glUniform3dv(int location, int count, double* value) {
            Pointers.glUniform3dv(location, count, value);
        }
        
        public static void glUniform3dv(int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniform3dv(location, count, value_);
        }
        
        public static void glUniform3f(int location, float v0, float v1, float v2) {
            Pointers.glUniform3f(location, v0, v1, v2);
        }
        
        public static void glUniform3fARB(int location, float v0, float v1, float v2) {
            Pointers.glUniform3fARB(location, v0, v1, v2);
        }
        
        public static void glUniform3fv(int location, int count, float* value) {
            Pointers.glUniform3fv(location, count, value);
        }
        
        public static void glUniform3fv(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform3fv(location, count, value_);
        }
        
        public static void glUniform3fvARB(int location, int count, float* value) {
            Pointers.glUniform3fvARB(location, count, value);
        }
        
        public static void glUniform3fvARB(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform3fvARB(location, count, value_);
        }
        
        public static void glUniform3i(int location, int v0, int v1, int v2) {
            Pointers.glUniform3i(location, v0, v1, v2);
        }
        
        public static void glUniform3i64ARB(int location, long x, long y, long z) {
            Pointers.glUniform3i64ARB(location, x, y, z);
        }
        
        public static void glUniform3i64NV(int location, long x, long y, long z) {
            Pointers.glUniform3i64NV(location, x, y, z);
        }
        
        public static void glUniform3i64vARB(int location, int count, long* value) {
            Pointers.glUniform3i64vARB(location, count, value);
        }
        
        public static void glUniform3i64vARB(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform3i64vARB(location, count, value_);
        }
        
        public static void glUniform3i64vNV(int location, int count, long* value) {
            Pointers.glUniform3i64vNV(location, count, value);
        }
        
        public static void glUniform3i64vNV(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform3i64vNV(location, count, value_);
        }
        
        public static void glUniform3iARB(int location, int v0, int v1, int v2) {
            Pointers.glUniform3iARB(location, v0, v1, v2);
        }
        
        public static void glUniform3iv(int location, int count, int* value) {
            Pointers.glUniform3iv(location, count, value);
        }
        
        public static void glUniform3iv(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform3iv(location, count, value_);
        }
        
        public static void glUniform3ivARB(int location, int count, int* value) {
            Pointers.glUniform3ivARB(location, count, value);
        }
        
        public static void glUniform3ivARB(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform3ivARB(location, count, value_);
        }
        
        public static void glUniform3ui(int location, uint v0, uint v1, uint v2) {
            Pointers.glUniform3ui(location, v0, v1, v2);
        }
        
        public static void glUniform3ui64ARB(int location, ulong x, ulong y, ulong z) {
            Pointers.glUniform3ui64ARB(location, x, y, z);
        }
        
        public static void glUniform3ui64NV(int location, ulong x, ulong y, ulong z) {
            Pointers.glUniform3ui64NV(location, x, y, z);
        }
        
        public static void glUniform3ui64vARB(int location, int count, ulong* value) {
            Pointers.glUniform3ui64vARB(location, count, value);
        }
        
        public static void glUniform3ui64vARB(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform3ui64vARB(location, count, value_);
        }
        
        public static void glUniform3ui64vNV(int location, int count, ulong* value) {
            Pointers.glUniform3ui64vNV(location, count, value);
        }
        
        public static void glUniform3ui64vNV(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform3ui64vNV(location, count, value_);
        }
        
        public static void glUniform3uiEXT(int location, uint v0, uint v1, uint v2) {
            Pointers.glUniform3uiEXT(location, v0, v1, v2);
        }
        
        public static void glUniform3uiv(int location, int count, uint* value) {
            Pointers.glUniform3uiv(location, count, value);
        }
        
        public static void glUniform3uiv(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform3uiv(location, count, value_);
        }
        
        public static void glUniform3uivEXT(int location, int count, uint* value) {
            Pointers.glUniform3uivEXT(location, count, value);
        }
        
        public static void glUniform3uivEXT(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform3uivEXT(location, count, value_);
        }
        
        public static void glUniform4d(int location, double x, double y, double z, double w) {
            Pointers.glUniform4d(location, x, y, z, w);
        }
        
        public static void glUniform4dv(int location, int count, double* value) {
            Pointers.glUniform4dv(location, count, value);
        }
        
        public static void glUniform4dv(int location, int count, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniform4dv(location, count, value_);
        }
        
        public static void glUniform4f(int location, float v0, float v1, float v2, float v3) {
            Pointers.glUniform4f(location, v0, v1, v2, v3);
        }
        
        public static void glUniform4fARB(int location, float v0, float v1, float v2, float v3) {
            Pointers.glUniform4fARB(location, v0, v1, v2, v3);
        }
        
        public static void glUniform4fv(int location, int count, float* value) {
            Pointers.glUniform4fv(location, count, value);
        }
        
        public static void glUniform4fv(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform4fv(location, count, value_);
        }
        
        public static void glUniform4fvARB(int location, int count, float* value) {
            Pointers.glUniform4fvARB(location, count, value);
        }
        
        public static void glUniform4fvARB(int location, int count, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniform4fvARB(location, count, value_);
        }
        
        public static void glUniform4i(int location, int v0, int v1, int v2, int v3) {
            Pointers.glUniform4i(location, v0, v1, v2, v3);
        }
        
        public static void glUniform4i64ARB(int location, long x, long y, long z, long w) {
            Pointers.glUniform4i64ARB(location, x, y, z, w);
        }
        
        public static void glUniform4i64NV(int location, long x, long y, long z, long w) {
            Pointers.glUniform4i64NV(location, x, y, z, w);
        }
        
        public static void glUniform4i64vARB(int location, int count, long* value) {
            Pointers.glUniform4i64vARB(location, count, value);
        }
        
        public static void glUniform4i64vARB(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform4i64vARB(location, count, value_);
        }
        
        public static void glUniform4i64vNV(int location, int count, long* value) {
            Pointers.glUniform4i64vNV(location, count, value);
        }
        
        public static void glUniform4i64vNV(int location, int count, long[] value) {
            fixed(long* value_ = &value[0])
                Pointers.glUniform4i64vNV(location, count, value_);
        }
        
        public static void glUniform4iARB(int location, int v0, int v1, int v2, int v3) {
            Pointers.glUniform4iARB(location, v0, v1, v2, v3);
        }
        
        public static void glUniform4iv(int location, int count, int* value) {
            Pointers.glUniform4iv(location, count, value);
        }
        
        public static void glUniform4iv(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform4iv(location, count, value_);
        }
        
        public static void glUniform4ivARB(int location, int count, int* value) {
            Pointers.glUniform4ivARB(location, count, value);
        }
        
        public static void glUniform4ivARB(int location, int count, int[] value) {
            fixed(int* value_ = &value[0])
                Pointers.glUniform4ivARB(location, count, value_);
        }
        
        public static void glUniform4ui(int location, uint v0, uint v1, uint v2, uint v3) {
            Pointers.glUniform4ui(location, v0, v1, v2, v3);
        }
        
        public static void glUniform4ui64ARB(int location, ulong x, ulong y, ulong z, ulong w) {
            Pointers.glUniform4ui64ARB(location, x, y, z, w);
        }
        
        public static void glUniform4ui64NV(int location, ulong x, ulong y, ulong z, ulong w) {
            Pointers.glUniform4ui64NV(location, x, y, z, w);
        }
        
        public static void glUniform4ui64vARB(int location, int count, ulong* value) {
            Pointers.glUniform4ui64vARB(location, count, value);
        }
        
        public static void glUniform4ui64vARB(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform4ui64vARB(location, count, value_);
        }
        
        public static void glUniform4ui64vNV(int location, int count, ulong* value) {
            Pointers.glUniform4ui64vNV(location, count, value);
        }
        
        public static void glUniform4ui64vNV(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniform4ui64vNV(location, count, value_);
        }
        
        public static void glUniform4uiEXT(int location, uint v0, uint v1, uint v2, uint v3) {
            Pointers.glUniform4uiEXT(location, v0, v1, v2, v3);
        }
        
        public static void glUniform4uiv(int location, int count, uint* value) {
            Pointers.glUniform4uiv(location, count, value);
        }
        
        public static void glUniform4uiv(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform4uiv(location, count, value_);
        }
        
        public static void glUniform4uivEXT(int location, int count, uint* value) {
            Pointers.glUniform4uivEXT(location, count, value);
        }
        
        public static void glUniform4uivEXT(int location, int count, uint[] value) {
            fixed(uint* value_ = &value[0])
                Pointers.glUniform4uivEXT(location, count, value_);
        }
        
        /// <summary>
        /// assign a binding point to an active uniform block
        /// <para>
        /// Binding points for active uniform blocks are assigned using glUniformBlockBinding. Each of a
        /// program's active uniform blocks has a corresponding uniform buffer binding point. program is the
        /// name of a program object for which the command glLinkProgram has been issued in the past
        /// </para>
        /// </summary>
        /// <param name="program">
        /// The name of a program object containing the active uniform block whose binding to assign.
        /// </param>
        /// <param name="uniformBlockIndex">
        /// The index of the active uniform block within program whose binding to assign.
        /// </param>
        /// <param name="uniformBlockBinding">
        /// Specifies the binding point to which to bind the uniform block with index uniformBlockIndex within
        /// program.
        /// </param>
        public static void glUniformBlockBinding(uint program, uint uniformBlockIndex, uint uniformBlockBinding) {
            Pointers.glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
        }
        
        public static void glUniformBufferEXT(uint program, int location, uint buffer) {
            Pointers.glUniformBufferEXT(program, location, buffer);
        }
        
        public static void glUniformHandleui64ARB(int location, ulong value) {
            Pointers.glUniformHandleui64ARB(location, value);
        }
        
        public static void glUniformHandleui64IMG(int location, ulong value) {
            Pointers.glUniformHandleui64IMG(location, value);
        }
        
        public static void glUniformHandleui64NV(int location, ulong value) {
            Pointers.glUniformHandleui64NV(location, value);
        }
        
        public static void glUniformHandleui64vARB(int location, int count, ulong* value) {
            Pointers.glUniformHandleui64vARB(location, count, value);
        }
        
        public static void glUniformHandleui64vARB(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniformHandleui64vARB(location, count, value_);
        }
        
        public static void glUniformHandleui64vIMG(int location, int count, ulong* value) {
            Pointers.glUniformHandleui64vIMG(location, count, value);
        }
        
        public static void glUniformHandleui64vIMG(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniformHandleui64vIMG(location, count, value_);
        }
        
        public static void glUniformHandleui64vNV(int location, int count, ulong* value) {
            Pointers.glUniformHandleui64vNV(location, count, value);
        }
        
        public static void glUniformHandleui64vNV(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniformHandleui64vNV(location, count, value_);
        }
        
        public static void glUniformMatrix2dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix2dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix2dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix2fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix2fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2fvARB(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix2fvARB(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2fvARB(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix2fvARB(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2x3dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix2x3dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2x3dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix2x3dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2x3fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix2x3fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2x3fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix2x3fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2x3fvNV(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix2x3fvNV(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2x3fvNV(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix2x3fvNV(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2x4dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix2x4dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2x4dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix2x4dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2x4fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix2x4fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2x4fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix2x4fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix2x4fvNV(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix2x4fvNV(location, count, transpose, value);
        }
        
        public static void glUniformMatrix2x4fvNV(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix2x4fvNV(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix3dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix3dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix3fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix3fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3fvARB(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix3fvARB(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3fvARB(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix3fvARB(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3x2dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix3x2dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3x2dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix3x2dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3x2fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix3x2fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3x2fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix3x2fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3x2fvNV(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix3x2fvNV(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3x2fvNV(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix3x2fvNV(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3x4dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix3x4dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3x4dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix3x4dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3x4fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix3x4fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3x4fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix3x4fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix3x4fvNV(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix3x4fvNV(location, count, transpose, value);
        }
        
        public static void glUniformMatrix3x4fvNV(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix3x4fvNV(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix4dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix4dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix4fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix4fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4fvARB(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix4fvARB(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4fvARB(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix4fvARB(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4x2dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix4x2dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4x2dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix4x2dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4x2fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix4x2fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4x2fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix4x2fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4x2fvNV(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix4x2fvNV(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4x2fvNV(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix4x2fvNV(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4x3dv(int location, int count, bool transpose, double* value) {
            Pointers.glUniformMatrix4x3dv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4x3dv(int location, int count, bool transpose, double[] value) {
            fixed(double* value_ = &value[0])
                Pointers.glUniformMatrix4x3dv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4x3fv(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix4x3fv(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4x3fv(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix4x3fv(location, count, transpose, value_);
        }
        
        public static void glUniformMatrix4x3fvNV(int location, int count, bool transpose, float* value) {
            Pointers.glUniformMatrix4x3fvNV(location, count, transpose, value);
        }
        
        public static void glUniformMatrix4x3fvNV(int location, int count, bool transpose, float[] value) {
            fixed(float* value_ = &value[0])
                Pointers.glUniformMatrix4x3fvNV(location, count, transpose, value_);
        }
        
        /// <summary>
        /// load active subroutine uniforms
        /// <para>
        /// glUniformSubroutines loads all active subroutine uniforms for shader stage shadertype of the current
        /// program with subroutine indices from indices, storing indices[i] into the uniform at location i.
        /// count must be equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the program currently
        /// in use at shader stage shadertype. Furthermore, all values in indices must be less than the value of
        /// GL_ACTIVE_SUBROUTINES for the shader stage
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="count">
        /// Specifies the number of uniform indices stored in indices.
        /// </param>
        /// <param name="indices">
        /// Specifies the address of an array holding the indices to load into the shader subroutine variables.
        /// </param>
        public static void glUniformSubroutinesuiv(int shadertype, int count, uint* indices) {
            Pointers.glUniformSubroutinesuiv(shadertype, count, indices);
        }
        
        /// <summary>
        /// load active subroutine uniforms
        /// <para>
        /// glUniformSubroutines loads all active subroutine uniforms for shader stage shadertype of the current
        /// program with subroutine indices from indices, storing indices[i] into the uniform at location i.
        /// count must be equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the program currently
        /// in use at shader stage shadertype. Furthermore, all values in indices must be less than the value of
        /// GL_ACTIVE_SUBROUTINES for the shader stage
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="count">
        /// Specifies the number of uniform indices stored in indices.
        /// </param>
        /// <param name="indices">
        /// Specifies the address of an array holding the indices to load into the shader subroutine variables.
        /// </param>
        public static void glUniformSubroutinesuiv(int shadertype, int count, uint[] indices) {
            fixed(uint* indices_ = &indices[0])
                Pointers.glUniformSubroutinesuiv(shadertype, count, indices_);
        }
        
        /// <summary>
        /// load active subroutine uniforms
        /// <para>
        /// glUniformSubroutines loads all active subroutine uniforms for shader stage shadertype of the current
        /// program with subroutine indices from indices, storing indices[i] into the uniform at location i.
        /// count must be equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the program currently
        /// in use at shader stage shadertype. Furthermore, all values in indices must be less than the value of
        /// GL_ACTIVE_SUBROUTINES for the shader stage
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="count">
        /// Specifies the number of uniform indices stored in indices.
        /// </param>
        /// <param name="indices">
        /// Specifies the address of an array holding the indices to load into the shader subroutine variables.
        /// </param>
        public static void glUniformSubroutinesuiv(Enums.ShaderType shadertype, int count, uint* indices) {
            Pointers.glUniformSubroutinesuiv((int)shadertype, count, indices);
        }
        
        /// <summary>
        /// load active subroutine uniforms
        /// <para>
        /// glUniformSubroutines loads all active subroutine uniforms for shader stage shadertype of the current
        /// program with subroutine indices from indices, storing indices[i] into the uniform at location i.
        /// count must be equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the program currently
        /// in use at shader stage shadertype. Furthermore, all values in indices must be less than the value of
        /// GL_ACTIVE_SUBROUTINES for the shader stage
        /// </para>
        /// </summary>
        /// <param name="shadertype">
        /// Specifies the shader stage from which to query for subroutine uniform index. shadertype must be one
        /// of GL_VERTEX_SHADER, GL_TESS_CONTROL_SHADER, GL_TESS_EVALUATION_SHADER, GL_GEOMETRY_SHADER or
        /// GL_FRAGMENT_SHADER.
        /// </param>
        /// <param name="count">
        /// Specifies the number of uniform indices stored in indices.
        /// </param>
        /// <param name="indices">
        /// Specifies the address of an array holding the indices to load into the shader subroutine variables.
        /// </param>
        public static void glUniformSubroutinesuiv(Enums.ShaderType shadertype, int count, uint[] indices) {
            fixed(uint* indices_ = &indices[0])
                Pointers.glUniformSubroutinesuiv((int)shadertype, count, indices_);
        }
        
        public static void glUniformui64NV(int location, ulong value) {
            Pointers.glUniformui64NV(location, value);
        }
        
        public static void glUniformui64vNV(int location, int count, ulong* value) {
            Pointers.glUniformui64vNV(location, count, value);
        }
        
        public static void glUniformui64vNV(int location, int count, ulong[] value) {
            fixed(ulong* value_ = &value[0])
                Pointers.glUniformui64vNV(location, count, value_);
        }
        
        public static void glUnlockArraysEXT() {
            Pointers.glUnlockArraysEXT();
        }
        
        /// <summary>
        /// release the mapping of a buffer object's data store into the client's address space
        /// <para>
        /// glUnmapBuffer and glUnmapNamedBuffer unmap (release) any mapping of a specified buffer object into
        /// the client's address space (see glMapBufferRange and glMapBuffer)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        public static bool glUnmapBuffer(int target) {
            return Pointers.glUnmapBuffer(target);
        }
        
        /// <summary>
        /// release the mapping of a buffer object's data store into the client's address space
        /// <para>
        /// glUnmapBuffer and glUnmapNamedBuffer unmap (release) any mapping of a specified buffer object into
        /// the client's address space (see glMapBufferRange and glMapBuffer)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        public static bool glUnmapBufferARB(int target) {
            return Pointers.glUnmapBufferARB(target);
        }
        
        /// <summary>
        /// release the mapping of a buffer object's data store into the client's address space
        /// <para>
        /// glUnmapBuffer and glUnmapNamedBuffer unmap (release) any mapping of a specified buffer object into
        /// the client's address space (see glMapBufferRange and glMapBuffer)
        /// </para>
        /// </summary>
        /// <param name="target">
        /// Specifies the target to which the buffer object is bound for glUnmapBuffer, which must be one of the
        /// buffer binding targets in the following table:
        /// </param>
        public static bool glUnmapBufferOES(int target) {
            return Pointers.glUnmapBufferOES(target);
        }
        
        public static bool glUnmapNamedBuffer(uint buffer) {
            return Pointers.glUnmapNamedBuffer(buffer);
        }
        
        public static bool glUnmapNamedBufferEXT(uint buffer) {
            return Pointers.glUnmapNamedBufferEXT(buffer);
        }
        
        public static void glUnmapObjectBufferATI(uint buffer) {
            Pointers.glUnmapObjectBufferATI(buffer);
        }
        
        public static void glUnmapTexture2DINTEL(uint texture, int level) {
            Pointers.glUnmapTexture2DINTEL(texture, level);
        }
        
        public static void glUpdateObjectBufferATI(uint buffer, uint offset, int size, IntPtr pointer, int preserve) {
            Pointers.glUpdateObjectBufferATI(buffer, offset, size, pointer, preserve);
        }
        
        /// <summary>
        /// Installs a program object as part of current rendering state
        /// <para>
        /// glUseProgram installs the program object specified by program as part of current rendering state.
        /// One or more executables are created in a program object by successfully attaching shader objects to
        /// it with glAttachShader, successfully compiling the shader objects with glCompileShader, and
        /// successfully linking the program object with glLinkProgram
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object whose executables are to be used as part of current
        /// rendering state.
        /// </param>
        public static void glUseProgram(uint program) {
            Pointers.glUseProgram(program);
        }
        
        /// <summary>
        /// Installs a program object as part of current rendering state
        /// <para>
        /// glUseProgram installs the program object specified by program as part of current rendering state.
        /// One or more executables are created in a program object by successfully attaching shader objects to
        /// it with glAttachShader, successfully compiling the shader objects with glCompileShader, and
        /// successfully linking the program object with glLinkProgram
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the handle of the program object whose executables are to be used as part of current
        /// rendering state.
        /// </param>
        public static void glUseProgramObjectARB(uint programObj) {
            Pointers.glUseProgramObjectARB(programObj);
        }
        
        /// <summary>
        /// bind stages of a program object to a program pipeline
        /// <para>
        /// glUseProgramStages binds executables from a program object associated with a specified set of shader
        /// stages to the program pipeline object given by pipeline. pipeline specifies the program pipeline
        /// object to which to bind the executables. stages contains a logical combination of bits indicating
        /// the shader stages to use within program with the program pipeline object pipeline. stages must be a
        /// logical combination of GL_VERTEX_SHADER_BIT, GL_TESS_CONTROL_SHADER_BIT,
        /// GL_TESS_EVALUATION_SHADER_BIT, GL_GEOMETRY_SHADER_BIT, GL_FRAGMENT_SHADER_BIT and
        /// GL_COMPUTE_SHADER_BIT. Additionally, the special value GL_ALL_SHADER_BITS may be specified to
        /// indicate that all executables contained in program should be installed in pipeline
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the program pipeline object to which to bind stages from program.
        /// </param>
        /// <param name="stages">
        /// Specifies a set of program stages to bind to the program pipeline object.
        /// </param>
        /// <param name="program">
        /// Specifies a set of program stages to bind to the program pipeline object.
        /// </param>
        public static void glUseProgramStages(uint pipeline, uint stages, uint program) {
            Pointers.glUseProgramStages(pipeline, stages, program);
        }
        
        /// <summary>
        /// bind stages of a program object to a program pipeline
        /// <para>
        /// glUseProgramStages binds executables from a program object associated with a specified set of shader
        /// stages to the program pipeline object given by pipeline. pipeline specifies the program pipeline
        /// object to which to bind the executables. stages contains a logical combination of bits indicating
        /// the shader stages to use within program with the program pipeline object pipeline. stages must be a
        /// logical combination of GL_VERTEX_SHADER_BIT, GL_TESS_CONTROL_SHADER_BIT,
        /// GL_TESS_EVALUATION_SHADER_BIT, GL_GEOMETRY_SHADER_BIT, GL_FRAGMENT_SHADER_BIT and
        /// GL_COMPUTE_SHADER_BIT. Additionally, the special value GL_ALL_SHADER_BITS may be specified to
        /// indicate that all executables contained in program should be installed in pipeline
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the program pipeline object to which to bind stages from program.
        /// </param>
        /// <param name="stages">
        /// Specifies a set of program stages to bind to the program pipeline object.
        /// </param>
        /// <param name="program">
        /// Specifies a set of program stages to bind to the program pipeline object.
        /// </param>
        public static void glUseProgramStages(uint pipeline, Enums.UseProgramStageMask stages, uint program) {
            Pointers.glUseProgramStages(pipeline, (uint)stages, program);
        }
        
        public static void glUseProgramStagesEXT(uint pipeline, uint stages, uint program) {
            Pointers.glUseProgramStagesEXT(pipeline, stages, program);
        }
        
        public static void glUseProgramStagesEXT(uint pipeline, Enums.UseProgramStageMask stages, uint program) {
            Pointers.glUseProgramStagesEXT(pipeline, (uint)stages, program);
        }
        
        public static void glUseShaderProgramEXT(int type, uint program) {
            Pointers.glUseShaderProgramEXT(type, program);
        }
        
        public static void glVDPAUFiniNV() {
            Pointers.glVDPAUFiniNV();
        }
        
        public static void glVDPAUGetSurfaceivNV(IntPtr surface, int pname, int bufSize, int* length, int* values) {
            Pointers.glVDPAUGetSurfaceivNV(surface, pname, bufSize, length, values);
        }
        
        public static void glVDPAUGetSurfaceivNV(IntPtr surface, int pname, int bufSize, int* length, int[] values) {
            fixed(int* values_ = &values[0])
                Pointers.glVDPAUGetSurfaceivNV(surface, pname, bufSize, length, values_);
        }
        
        public static void glVDPAUGetSurfaceivNV(IntPtr surface, int pname, int bufSize, int[] length, int* values) {
            fixed(int* length_ = &length[0])
                Pointers.glVDPAUGetSurfaceivNV(surface, pname, bufSize, length_, values);
        }
        
        public static void glVDPAUGetSurfaceivNV(IntPtr surface, int pname, int bufSize, int[] length, int[] values) {
            fixed(int* length_ = &length[0])
            fixed(int* values_ = &values[0])
                Pointers.glVDPAUGetSurfaceivNV(surface, pname, bufSize, length_, values_);
        }
        
        public static void glVDPAUInitNV(IntPtr vdpDevice, IntPtr getProcAddress) {
            Pointers.glVDPAUInitNV(vdpDevice, getProcAddress);
        }
        
        public static bool glVDPAUIsSurfaceNV(IntPtr surface) {
            return Pointers.glVDPAUIsSurfaceNV(surface);
        }
        
        public static void glVDPAUMapSurfacesNV(int numSurfaces, IntPtr* surfaces) {
            Pointers.glVDPAUMapSurfacesNV(numSurfaces, surfaces);
        }
        
        public static void glVDPAUMapSurfacesNV(int numSurfaces, IntPtr[] surfaces) {
            fixed(IntPtr* surfaces_ = &surfaces[0])
                Pointers.glVDPAUMapSurfacesNV(numSurfaces, surfaces_);
        }
        
        public static IntPtr glVDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, uint* textureNames) {
            return Pointers.glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
        }
        
        public static IntPtr glVDPAURegisterOutputSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, uint[] textureNames) {
            fixed(uint* textureNames_ = &textureNames[0])
                return Pointers.glVDPAURegisterOutputSurfaceNV(vdpSurface, target, numTextureNames, textureNames_);
        }
        
        public static IntPtr glVDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, uint* textureNames) {
            return Pointers.glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames);
        }
        
        public static IntPtr glVDPAURegisterVideoSurfaceNV(IntPtr vdpSurface, int target, int numTextureNames, uint[] textureNames) {
            fixed(uint* textureNames_ = &textureNames[0])
                return Pointers.glVDPAURegisterVideoSurfaceNV(vdpSurface, target, numTextureNames, textureNames_);
        }
        
        public static void glVDPAUSurfaceAccessNV(IntPtr surface, int access) {
            Pointers.glVDPAUSurfaceAccessNV(surface, access);
        }
        
        public static void glVDPAUUnmapSurfacesNV(int numSurface, IntPtr* surfaces) {
            Pointers.glVDPAUUnmapSurfacesNV(numSurface, surfaces);
        }
        
        public static void glVDPAUUnmapSurfacesNV(int numSurface, IntPtr[] surfaces) {
            fixed(IntPtr* surfaces_ = &surfaces[0])
                Pointers.glVDPAUUnmapSurfacesNV(numSurface, surfaces_);
        }
        
        public static void glVDPAUUnregisterSurfaceNV(IntPtr surface) {
            Pointers.glVDPAUUnregisterSurfaceNV(surface);
        }
        
        /// <summary>
        /// Validates a program object
        /// <para>
        /// glValidateProgram checks to see whether the executables contained in program can execute given the
        /// current OpenGL state. The information generated by the validation process will be stored in
        /// program's information log. The validation information may consist of an empty string, or it may be a
        /// string containing information about how the current program object interacts with the rest of
        /// current OpenGL state. This provides a way for OpenGL implementers to convey more information about
        /// why the current program is inefficient, suboptimal, failing to execute, and so on
        /// </para>
        /// </summary>
        /// <param name="program">
        /// Specifies the handle of the program object to be validated.
        /// </param>
        public static void glValidateProgram(uint program) {
            Pointers.glValidateProgram(program);
        }
        
        /// <summary>
        /// Validates a program object
        /// <para>
        /// glValidateProgram checks to see whether the executables contained in program can execute given the
        /// current OpenGL state. The information generated by the validation process will be stored in
        /// program's information log. The validation information may consist of an empty string, or it may be a
        /// string containing information about how the current program object interacts with the rest of
        /// current OpenGL state. This provides a way for OpenGL implementers to convey more information about
        /// why the current program is inefficient, suboptimal, failing to execute, and so on
        /// </para>
        /// </summary>
        /// <param name="programObj">
        /// Specifies the handle of the program object to be validated.
        /// </param>
        public static void glValidateProgramARB(uint programObj) {
            Pointers.glValidateProgramARB(programObj);
        }
        
        /// <summary>
        /// validate a program pipeline object against current GL state
        /// <para>
        /// glValidateProgramPipeline instructs the implementation to validate the shader executables contained
        /// in pipeline against the current GL state. The implementation may use this as an opportunity to
        /// perform any internal shader modifications that may be required to ensure correct operation of the
        /// installed shaders given the current GL state
        /// </para>
        /// </summary>
        /// <param name="pipeline">
        /// Specifies the name of a program pipeline object to validate.
        /// </param>
        public static void glValidateProgramPipeline(uint pipeline) {
            Pointers.glValidateProgramPipeline(pipeline);
        }
        
        public static void glValidateProgramPipelineEXT(uint pipeline) {
            Pointers.glValidateProgramPipelineEXT(pipeline);
        }
        
        public static void glVariantArrayObjectATI(uint id, int type, int stride, uint buffer, uint offset) {
            Pointers.glVariantArrayObjectATI(id, type, stride, buffer, offset);
        }
        
        public static void glVariantPointerEXT(uint id, int type, uint stride, IntPtr addr) {
            Pointers.glVariantPointerEXT(id, type, stride, addr);
        }
        
        public static void glVariantbvEXT(uint id, sbyte* addr) {
            Pointers.glVariantbvEXT(id, addr);
        }
        
        public static void glVariantbvEXT(uint id, sbyte[] addr) {
            fixed(sbyte* addr_ = &addr[0])
                Pointers.glVariantbvEXT(id, addr_);
        }
        
        public static void glVariantdvEXT(uint id, double* addr) {
            Pointers.glVariantdvEXT(id, addr);
        }
        
        public static void glVariantdvEXT(uint id, double[] addr) {
            fixed(double* addr_ = &addr[0])
                Pointers.glVariantdvEXT(id, addr_);
        }
        
        public static void glVariantfvEXT(uint id, float* addr) {
            Pointers.glVariantfvEXT(id, addr);
        }
        
        public static void glVariantfvEXT(uint id, float[] addr) {
            fixed(float* addr_ = &addr[0])
                Pointers.glVariantfvEXT(id, addr_);
        }
        
        public static void glVariantivEXT(uint id, int* addr) {
            Pointers.glVariantivEXT(id, addr);
        }
        
        public static void glVariantivEXT(uint id, int[] addr) {
            fixed(int* addr_ = &addr[0])
                Pointers.glVariantivEXT(id, addr_);
        }
        
        public static void glVariantsvEXT(uint id, short* addr) {
            Pointers.glVariantsvEXT(id, addr);
        }
        
        public static void glVariantsvEXT(uint id, short[] addr) {
            fixed(short* addr_ = &addr[0])
                Pointers.glVariantsvEXT(id, addr_);
        }
        
        public static void glVariantubvEXT(uint id, byte* addr) {
            Pointers.glVariantubvEXT(id, addr);
        }
        
        public static void glVariantubvEXT(uint id, byte[] addr) {
            fixed(byte* addr_ = &addr[0])
                Pointers.glVariantubvEXT(id, addr_);
        }
        
        public static void glVariantuivEXT(uint id, uint* addr) {
            Pointers.glVariantuivEXT(id, addr);
        }
        
        public static void glVariantuivEXT(uint id, uint[] addr) {
            fixed(uint* addr_ = &addr[0])
                Pointers.glVariantuivEXT(id, addr_);
        }
        
        public static void glVariantusvEXT(uint id, ushort* addr) {
            Pointers.glVariantusvEXT(id, addr);
        }
        
        public static void glVariantusvEXT(uint id, ushort[] addr) {
            fixed(ushort* addr_ = &addr[0])
                Pointers.glVariantusvEXT(id, addr_);
        }
        
        public static void glVertex2bOES(sbyte x, sbyte y) {
            Pointers.glVertex2bOES(x, y);
        }
        
        public static void glVertex2bvOES(sbyte* coords) {
            Pointers.glVertex2bvOES(coords);
        }
        
        public static void glVertex2bvOES(sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glVertex2bvOES(coords_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex2d(double x, double y) {
            Pointers.glVertex2d(x, y);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2dv(double* v) {
            Pointers.glVertex2dv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertex2dv(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex2f(float x, float y) {
            Pointers.glVertex2f(x, y);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2fv(float* v) {
            Pointers.glVertex2fv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertex2fv(v_);
        }
        
        public static void glVertex2hNV(short x, short y) {
            Pointers.glVertex2hNV(x, y);
        }
        
        public static void glVertex2hvNV(short* v) {
            Pointers.glVertex2hvNV(v);
        }
        
        public static void glVertex2hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertex2hvNV(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex2i(int x, int y) {
            Pointers.glVertex2i(x, y);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2iv(int* v) {
            Pointers.glVertex2iv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertex2iv(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex2s(short x, short y) {
            Pointers.glVertex2s(x, y);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2sv(short* v) {
            Pointers.glVertex2sv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex2sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertex2sv(v_);
        }
        
        public static void glVertex2xOES(IntPtr x) {
            Pointers.glVertex2xOES(x);
        }
        
        public static void glVertex2xvOES(IntPtr* coords) {
            Pointers.glVertex2xvOES(coords);
        }
        
        public static void glVertex2xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glVertex2xvOES(coords_);
        }
        
        public static void glVertex3bOES(sbyte x, sbyte y, sbyte z) {
            Pointers.glVertex3bOES(x, y, z);
        }
        
        public static void glVertex3bvOES(sbyte* coords) {
            Pointers.glVertex3bvOES(coords);
        }
        
        public static void glVertex3bvOES(sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glVertex3bvOES(coords_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex3d(double x, double y, double z) {
            Pointers.glVertex3d(x, y, z);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3dv(double* v) {
            Pointers.glVertex3dv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertex3dv(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex3f(float x, float y, float z) {
            Pointers.glVertex3f(x, y, z);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3fv(float* v) {
            Pointers.glVertex3fv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertex3fv(v_);
        }
        
        public static void glVertex3hNV(short x, short y, short z) {
            Pointers.glVertex3hNV(x, y, z);
        }
        
        public static void glVertex3hvNV(short* v) {
            Pointers.glVertex3hvNV(v);
        }
        
        public static void glVertex3hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertex3hvNV(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex3i(int x, int y, int z) {
            Pointers.glVertex3i(x, y, z);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3iv(int* v) {
            Pointers.glVertex3iv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertex3iv(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex3s(short x, short y, short z) {
            Pointers.glVertex3s(x, y, z);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3sv(short* v) {
            Pointers.glVertex3sv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex3sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertex3sv(v_);
        }
        
        public static void glVertex3xOES(IntPtr x, IntPtr y) {
            Pointers.glVertex3xOES(x, y);
        }
        
        public static void glVertex3xvOES(IntPtr* coords) {
            Pointers.glVertex3xvOES(coords);
        }
        
        public static void glVertex3xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glVertex3xvOES(coords_);
        }
        
        public static void glVertex4bOES(sbyte x, sbyte y, sbyte z, sbyte w) {
            Pointers.glVertex4bOES(x, y, z, w);
        }
        
        public static void glVertex4bvOES(sbyte* coords) {
            Pointers.glVertex4bvOES(coords);
        }
        
        public static void glVertex4bvOES(sbyte[] coords) {
            fixed(sbyte* coords_ = &coords[0])
                Pointers.glVertex4bvOES(coords_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="w">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex4d(double x, double y, double z, double w) {
            Pointers.glVertex4d(x, y, z, w);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4dv(double* v) {
            Pointers.glVertex4dv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertex4dv(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="w">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex4f(float x, float y, float z, float w) {
            Pointers.glVertex4f(x, y, z, w);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4fv(float* v) {
            Pointers.glVertex4fv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertex4fv(v_);
        }
        
        public static void glVertex4hNV(short x, short y, short z, short w) {
            Pointers.glVertex4hNV(x, y, z, w);
        }
        
        public static void glVertex4hvNV(short* v) {
            Pointers.glVertex4hvNV(v);
        }
        
        public static void glVertex4hvNV(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertex4hvNV(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="w">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex4i(int x, int y, int z, int w) {
            Pointers.glVertex4i(x, y, z, w);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4iv(int* v) {
            Pointers.glVertex4iv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertex4iv(v_);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="y">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="z">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        /// <param name="w">
        /// Specify x, y, z, and w coordinates of a vertex. Not all parameters are present in all forms of the
        /// command.
        /// </param>
        public static void glVertex4s(short x, short y, short z, short w) {
            Pointers.glVertex4s(x, y, z, w);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4sv(short* v) {
            Pointers.glVertex4sv(v);
        }
        
        /// <summary>
        /// specify a vertex
        /// <para>
        /// glVertex commands are used within glBegin/glEnd pairs to specify point, line, and polygon vertices.
        /// The current color, normal, texture coordinates, and fog coordinate are associated with the vertex
        /// when glVertex is called
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two, three, or four elements. The elements of a two-element array
        /// are x and y; of a three-element array, x, y, and z; and of a four-element array, x, y, z, and w.
        /// </param>
        public static void glVertex4sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertex4sv(v_);
        }
        
        public static void glVertex4xOES(IntPtr x, IntPtr y, IntPtr z) {
            Pointers.glVertex4xOES(x, y, z);
        }
        
        public static void glVertex4xvOES(IntPtr* coords) {
            Pointers.glVertex4xvOES(coords);
        }
        
        public static void glVertex4xvOES(IntPtr[] coords) {
            fixed(IntPtr* coords_ = &coords[0])
                Pointers.glVertex4xvOES(coords_);
        }
        
        public static void glVertexArrayAttribBinding(uint vaobj, uint attribindex, uint bindingindex) {
            Pointers.glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
        }
        
        public static void glVertexArrayAttribFormat(uint vaobj, uint attribindex, int size, int type, bool normalized, uint relativeoffset) {
            Pointers.glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);
        }
        
        public static void glVertexArrayAttribIFormat(uint vaobj, uint attribindex, int size, int type, uint relativeoffset) {
            Pointers.glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);
        }
        
        public static void glVertexArrayAttribLFormat(uint vaobj, uint attribindex, int size, int type, uint relativeoffset) {
            Pointers.glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);
        }
        
        public static void glVertexArrayBindVertexBufferEXT(uint vaobj, uint bindingindex, uint buffer, uint offset, int stride) {
            Pointers.glVertexArrayBindVertexBufferEXT(vaobj, bindingindex, buffer, offset, stride);
        }
        
        public static void glVertexArrayBindingDivisor(uint vaobj, uint bindingindex, uint divisor) {
            Pointers.glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
        }
        
        public static void glVertexArrayColorOffsetEXT(uint vaobj, uint buffer, int size, int type, int stride, uint offset) {
            Pointers.glVertexArrayColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
        }
        
        public static void glVertexArrayEdgeFlagOffsetEXT(uint vaobj, uint buffer, int stride, uint offset) {
            Pointers.glVertexArrayEdgeFlagOffsetEXT(vaobj, buffer, stride, offset);
        }
        
        /// <summary>
        /// configures element array buffer binding of a vertex array object
        /// <para>
        /// glVertexArrayElementBuffer binds a buffer object with id buffer to the element array buffer bind
        /// point of a vertex array object with id vaobj. If buffer is zero, any existing element array buffer
        /// binding to vaobj is removed
        /// </para>
        /// </summary>
        /// <param name="vaobj">
        /// Specifies the name of the vertex array object.
        /// </param>
        /// <param name="buffer">
        /// Specifies the name of the buffer object to use for the element array buffer binding.
        /// </param>
        public static void glVertexArrayElementBuffer(uint vaobj, uint buffer) {
            Pointers.glVertexArrayElementBuffer(vaobj, buffer);
        }
        
        public static void glVertexArrayFogCoordOffsetEXT(uint vaobj, uint buffer, int type, int stride, uint offset) {
            Pointers.glVertexArrayFogCoordOffsetEXT(vaobj, buffer, type, stride, offset);
        }
        
        public static void glVertexArrayIndexOffsetEXT(uint vaobj, uint buffer, int type, int stride, uint offset) {
            Pointers.glVertexArrayIndexOffsetEXT(vaobj, buffer, type, stride, offset);
        }
        
        public static void glVertexArrayMultiTexCoordOffsetEXT(uint vaobj, uint buffer, int texunit, int size, int type, int stride, uint offset) {
            Pointers.glVertexArrayMultiTexCoordOffsetEXT(vaobj, buffer, texunit, size, type, stride, offset);
        }
        
        public static void glVertexArrayNormalOffsetEXT(uint vaobj, uint buffer, int type, int stride, uint offset) {
            Pointers.glVertexArrayNormalOffsetEXT(vaobj, buffer, type, stride, offset);
        }
        
        public static void glVertexArrayParameteriAPPLE(int pname, int param) {
            Pointers.glVertexArrayParameteriAPPLE(pname, param);
        }
        
        public static void glVertexArrayRangeAPPLE(int length, IntPtr pointer) {
            Pointers.glVertexArrayRangeAPPLE(length, pointer);
        }
        
        public static void glVertexArrayRangeNV(int length, IntPtr pointer) {
            Pointers.glVertexArrayRangeNV(length, pointer);
        }
        
        public static void glVertexArraySecondaryColorOffsetEXT(uint vaobj, uint buffer, int size, int type, int stride, uint offset) {
            Pointers.glVertexArraySecondaryColorOffsetEXT(vaobj, buffer, size, type, stride, offset);
        }
        
        public static void glVertexArrayTexCoordOffsetEXT(uint vaobj, uint buffer, int size, int type, int stride, uint offset) {
            Pointers.glVertexArrayTexCoordOffsetEXT(vaobj, buffer, size, type, stride, offset);
        }
        
        public static void glVertexArrayVertexAttribBindingEXT(uint vaobj, uint attribindex, uint bindingindex) {
            Pointers.glVertexArrayVertexAttribBindingEXT(vaobj, attribindex, bindingindex);
        }
        
        public static void glVertexArrayVertexAttribDivisorEXT(uint vaobj, uint index, uint divisor) {
            Pointers.glVertexArrayVertexAttribDivisorEXT(vaobj, index, divisor);
        }
        
        public static void glVertexArrayVertexAttribFormatEXT(uint vaobj, uint attribindex, int size, int type, bool normalized, uint relativeoffset) {
            Pointers.glVertexArrayVertexAttribFormatEXT(vaobj, attribindex, size, type, normalized, relativeoffset);
        }
        
        public static void glVertexArrayVertexAttribIFormatEXT(uint vaobj, uint attribindex, int size, int type, uint relativeoffset) {
            Pointers.glVertexArrayVertexAttribIFormatEXT(vaobj, attribindex, size, type, relativeoffset);
        }
        
        public static void glVertexArrayVertexAttribIOffsetEXT(uint vaobj, uint buffer, uint index, int size, int type, int stride, uint offset) {
            Pointers.glVertexArrayVertexAttribIOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
        }
        
        public static void glVertexArrayVertexAttribLFormatEXT(uint vaobj, uint attribindex, int size, int type, uint relativeoffset) {
            Pointers.glVertexArrayVertexAttribLFormatEXT(vaobj, attribindex, size, type, relativeoffset);
        }
        
        public static void glVertexArrayVertexAttribLOffsetEXT(uint vaobj, uint buffer, uint index, int size, int type, int stride, uint offset) {
            Pointers.glVertexArrayVertexAttribLOffsetEXT(vaobj, buffer, index, size, type, stride, offset);
        }
        
        public static void glVertexArrayVertexAttribOffsetEXT(uint vaobj, uint buffer, uint index, int size, int type, bool normalized, int stride, uint offset) {
            Pointers.glVertexArrayVertexAttribOffsetEXT(vaobj, buffer, index, size, type, normalized, stride, offset);
        }
        
        public static void glVertexArrayVertexBindingDivisorEXT(uint vaobj, uint bindingindex, uint divisor) {
            Pointers.glVertexArrayVertexBindingDivisorEXT(vaobj, bindingindex, divisor);
        }
        
        public static void glVertexArrayVertexBuffer(uint vaobj, uint bindingindex, uint buffer, uint offset, int stride) {
            Pointers.glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, uint* offsets, int* strides) {
            Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, uint* offsets, int[] strides) {
            fixed(int* strides_ = &strides[0])
                Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides_);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, uint[] offsets, int* strides) {
            fixed(uint* offsets_ = &offsets[0])
                Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets_, strides);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint* buffers, uint[] offsets, int[] strides) {
            fixed(uint* offsets_ = &offsets[0])
            fixed(int* strides_ = &strides[0])
                Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets_, strides_);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint[] buffers, uint* offsets, int* strides) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers_, offsets, strides);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint[] buffers, uint* offsets, int[] strides) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(int* strides_ = &strides[0])
                Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers_, offsets, strides_);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint[] buffers, uint[] offsets, int* strides) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* offsets_ = &offsets[0])
                Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers_, offsets_, strides);
        }
        
        public static void glVertexArrayVertexBuffers(uint vaobj, uint first, int count, uint[] buffers, uint[] offsets, int[] strides) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* offsets_ = &offsets[0])
            fixed(int* strides_ = &strides[0])
                Pointers.glVertexArrayVertexBuffers(vaobj, first, count, buffers_, offsets_, strides_);
        }
        
        public static void glVertexArrayVertexOffsetEXT(uint vaobj, uint buffer, int size, int type, int stride, uint offset) {
            Pointers.glVertexArrayVertexOffsetEXT(vaobj, buffer, size, type, stride, offset);
        }
        
        public static void glVertexAttrib1d(uint index, double x) {
            Pointers.glVertexAttrib1d(index, x);
        }
        
        public static void glVertexAttrib1dARB(uint index, double x) {
            Pointers.glVertexAttrib1dARB(index, x);
        }
        
        public static void glVertexAttrib1dNV(uint index, double x) {
            Pointers.glVertexAttrib1dNV(index, x);
        }
        
        public static void glVertexAttrib1dv(uint index, double* v) {
            Pointers.glVertexAttrib1dv(index, v);
        }
        
        public static void glVertexAttrib1dv(uint index, out double v) {
            fixed(double* v_ = &v)
                Pointers.glVertexAttrib1dv(index, v_);
        }
        
        public static void glVertexAttrib1dvARB(uint index, double* v) {
            Pointers.glVertexAttrib1dvARB(index, v);
        }
        
        public static void glVertexAttrib1dvARB(uint index, out double v) {
            fixed(double* v_ = &v)
                Pointers.glVertexAttrib1dvARB(index, v_);
        }
        
        public static void glVertexAttrib1dvNV(uint index, double* v) {
            Pointers.glVertexAttrib1dvNV(index, v);
        }
        
        public static void glVertexAttrib1dvNV(uint index, out double v) {
            fixed(double* v_ = &v)
                Pointers.glVertexAttrib1dvNV(index, v_);
        }
        
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>
        /// The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in
        /// numbered locations
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        public static void glVertexAttrib1f(uint index, float x) {
            Pointers.glVertexAttrib1f(index, x);
        }
        
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>
        /// The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in
        /// numbered locations
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        public static void glVertexAttrib1fARB(uint index, float x) {
            Pointers.glVertexAttrib1fARB(index, x);
        }
        
        /// <summary>
        /// Specifies the value of a generic vertex attribute
        /// <para>
        /// The glVertexAttrib family of entry points allows an application to pass generic vertex attributes in
        /// numbered locations
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="x">
        /// For the scalar commands, specifies the new values to be used for the specified vertex attribute.
        /// </param>
        public static void glVertexAttrib1fNV(uint index, float x) {
            Pointers.glVertexAttrib1fNV(index, x);
        }
        
        public static void glVertexAttrib1fv(uint index, float* v) {
            Pointers.glVertexAttrib1fv(index, v);
        }
        
        public static void glVertexAttrib1fv(uint index, out float v) {
            fixed(float* v_ = &v)
                Pointers.glVertexAttrib1fv(index, v_);
        }
        
        public static void glVertexAttrib1fvARB(uint index, float* v) {
            Pointers.glVertexAttrib1fvARB(index, v);
        }
        
        public static void glVertexAttrib1fvARB(uint index, out float v) {
            fixed(float* v_ = &v)
                Pointers.glVertexAttrib1fvARB(index, v_);
        }
        
        public static void glVertexAttrib1fvNV(uint index, float* v) {
            Pointers.glVertexAttrib1fvNV(index, v);
        }
        
        public static void glVertexAttrib1fvNV(uint index, out float v) {
            fixed(float* v_ = &v)
                Pointers.glVertexAttrib1fvNV(index, v_);
        }
        
        public static void glVertexAttrib1hNV(uint index, short x) {
            Pointers.glVertexAttrib1hNV(index, x);
        }
        
        public static void glVertexAttrib1hvNV(uint index, short* v) {
            Pointers.glVertexAttrib1hvNV(index, v);
        }
        
        public static void glVertexAttrib1hvNV(uint index, out short v) {
            fixed(short* v_ = &v)
                Pointers.glVertexAttrib1hvNV(index, v_);
        }
        
        public static void glVertexAttrib1s(uint index, short x) {
            Pointers.glVertexAttrib1s(index, x);
        }
        
        public static void glVertexAttrib1sARB(uint index, short x) {
            Pointers.glVertexAttrib1sARB(index, x);
        }
        
        public static void glVertexAttrib1sNV(uint index, short x) {
            Pointers.glVertexAttrib1sNV(index, x);
        }
        
        public static void glVertexAttrib1sv(uint index, short* v) {
            Pointers.glVertexAttrib1sv(index, v);
        }
        
        public static void glVertexAttrib1sv(uint index, out short v) {
            fixed(short* v_ = &v)
                Pointers.glVertexAttrib1sv(index, v_);
        }
        
        public static void glVertexAttrib1svARB(uint index, short* v) {
            Pointers.glVertexAttrib1svARB(index, v);
        }
        
        public static void glVertexAttrib1svARB(uint index, out short v) {
            fixed(short* v_ = &v)
                Pointers.glVertexAttrib1svARB(index, v_);
        }
        
        public static void glVertexAttrib1svNV(uint index, short* v) {
            Pointers.glVertexAttrib1svNV(index, v);
        }
        
        public static void glVertexAttrib1svNV(uint index, out short v) {
            fixed(short* v_ = &v)
                Pointers.glVertexAttrib1svNV(index, v_);
        }
        
        public static void glVertexAttrib2d(uint index, double x, double y) {
            Pointers.glVertexAttrib2d(index, x, y);
        }
        
        public static void glVertexAttrib2dARB(uint index, double x, double y) {
            Pointers.glVertexAttrib2dARB(index, x, y);
        }
        
        public static void glVertexAttrib2dNV(uint index, double x, double y) {
            Pointers.glVertexAttrib2dNV(index, x, y);
        }
        
        public static void glVertexAttrib2dv(uint index, double* v) {
            Pointers.glVertexAttrib2dv(index, v);
        }
        
        public static void glVertexAttrib2dv(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib2dv(index, v_);
        }
        
        public static void glVertexAttrib2dvARB(uint index, double* v) {
            Pointers.glVertexAttrib2dvARB(index, v);
        }
        
        public static void glVertexAttrib2dvARB(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib2dvARB(index, v_);
        }
        
        public static void glVertexAttrib2dvNV(uint index, double* v) {
            Pointers.glVertexAttrib2dvNV(index, v);
        }
        
        public static void glVertexAttrib2dvNV(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib2dvNV(index, v_);
        }
        
        public static void glVertexAttrib2f(uint index, float x, float y) {
            Pointers.glVertexAttrib2f(index, x, y);
        }
        
        public static void glVertexAttrib2fARB(uint index, float x, float y) {
            Pointers.glVertexAttrib2fARB(index, x, y);
        }
        
        public static void glVertexAttrib2fNV(uint index, float x, float y) {
            Pointers.glVertexAttrib2fNV(index, x, y);
        }
        
        public static void glVertexAttrib2fv(uint index, float* v) {
            Pointers.glVertexAttrib2fv(index, v);
        }
        
        public static void glVertexAttrib2fv(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib2fv(index, v_);
        }
        
        public static void glVertexAttrib2fvARB(uint index, float* v) {
            Pointers.glVertexAttrib2fvARB(index, v);
        }
        
        public static void glVertexAttrib2fvARB(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib2fvARB(index, v_);
        }
        
        public static void glVertexAttrib2fvNV(uint index, float* v) {
            Pointers.glVertexAttrib2fvNV(index, v);
        }
        
        public static void glVertexAttrib2fvNV(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib2fvNV(index, v_);
        }
        
        public static void glVertexAttrib2hNV(uint index, short x, short y) {
            Pointers.glVertexAttrib2hNV(index, x, y);
        }
        
        public static void glVertexAttrib2hvNV(uint index, short* v) {
            Pointers.glVertexAttrib2hvNV(index, v);
        }
        
        public static void glVertexAttrib2hvNV(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib2hvNV(index, v_);
        }
        
        public static void glVertexAttrib2s(uint index, short x, short y) {
            Pointers.glVertexAttrib2s(index, x, y);
        }
        
        public static void glVertexAttrib2sARB(uint index, short x, short y) {
            Pointers.glVertexAttrib2sARB(index, x, y);
        }
        
        public static void glVertexAttrib2sNV(uint index, short x, short y) {
            Pointers.glVertexAttrib2sNV(index, x, y);
        }
        
        public static void glVertexAttrib2sv(uint index, short* v) {
            Pointers.glVertexAttrib2sv(index, v);
        }
        
        public static void glVertexAttrib2sv(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib2sv(index, v_);
        }
        
        public static void glVertexAttrib2svARB(uint index, short* v) {
            Pointers.glVertexAttrib2svARB(index, v);
        }
        
        public static void glVertexAttrib2svARB(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib2svARB(index, v_);
        }
        
        public static void glVertexAttrib2svNV(uint index, short* v) {
            Pointers.glVertexAttrib2svNV(index, v);
        }
        
        public static void glVertexAttrib2svNV(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib2svNV(index, v_);
        }
        
        public static void glVertexAttrib3d(uint index, double x, double y, double z) {
            Pointers.glVertexAttrib3d(index, x, y, z);
        }
        
        public static void glVertexAttrib3dARB(uint index, double x, double y, double z) {
            Pointers.glVertexAttrib3dARB(index, x, y, z);
        }
        
        public static void glVertexAttrib3dNV(uint index, double x, double y, double z) {
            Pointers.glVertexAttrib3dNV(index, x, y, z);
        }
        
        public static void glVertexAttrib3dv(uint index, double* v) {
            Pointers.glVertexAttrib3dv(index, v);
        }
        
        public static void glVertexAttrib3dv(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib3dv(index, v_);
        }
        
        public static void glVertexAttrib3dvARB(uint index, double* v) {
            Pointers.glVertexAttrib3dvARB(index, v);
        }
        
        public static void glVertexAttrib3dvARB(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib3dvARB(index, v_);
        }
        
        public static void glVertexAttrib3dvNV(uint index, double* v) {
            Pointers.glVertexAttrib3dvNV(index, v);
        }
        
        public static void glVertexAttrib3dvNV(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib3dvNV(index, v_);
        }
        
        public static void glVertexAttrib3f(uint index, float x, float y, float z) {
            Pointers.glVertexAttrib3f(index, x, y, z);
        }
        
        public static void glVertexAttrib3fARB(uint index, float x, float y, float z) {
            Pointers.glVertexAttrib3fARB(index, x, y, z);
        }
        
        public static void glVertexAttrib3fNV(uint index, float x, float y, float z) {
            Pointers.glVertexAttrib3fNV(index, x, y, z);
        }
        
        public static void glVertexAttrib3fv(uint index, float* v) {
            Pointers.glVertexAttrib3fv(index, v);
        }
        
        public static void glVertexAttrib3fv(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib3fv(index, v_);
        }
        
        public static void glVertexAttrib3fvARB(uint index, float* v) {
            Pointers.glVertexAttrib3fvARB(index, v);
        }
        
        public static void glVertexAttrib3fvARB(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib3fvARB(index, v_);
        }
        
        public static void glVertexAttrib3fvNV(uint index, float* v) {
            Pointers.glVertexAttrib3fvNV(index, v);
        }
        
        public static void glVertexAttrib3fvNV(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib3fvNV(index, v_);
        }
        
        public static void glVertexAttrib3hNV(uint index, short x, short y, short z) {
            Pointers.glVertexAttrib3hNV(index, x, y, z);
        }
        
        public static void glVertexAttrib3hvNV(uint index, short* v) {
            Pointers.glVertexAttrib3hvNV(index, v);
        }
        
        public static void glVertexAttrib3hvNV(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib3hvNV(index, v_);
        }
        
        public static void glVertexAttrib3s(uint index, short x, short y, short z) {
            Pointers.glVertexAttrib3s(index, x, y, z);
        }
        
        public static void glVertexAttrib3sARB(uint index, short x, short y, short z) {
            Pointers.glVertexAttrib3sARB(index, x, y, z);
        }
        
        public static void glVertexAttrib3sNV(uint index, short x, short y, short z) {
            Pointers.glVertexAttrib3sNV(index, x, y, z);
        }
        
        public static void glVertexAttrib3sv(uint index, short* v) {
            Pointers.glVertexAttrib3sv(index, v);
        }
        
        public static void glVertexAttrib3sv(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib3sv(index, v_);
        }
        
        public static void glVertexAttrib3svARB(uint index, short* v) {
            Pointers.glVertexAttrib3svARB(index, v);
        }
        
        public static void glVertexAttrib3svARB(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib3svARB(index, v_);
        }
        
        public static void glVertexAttrib3svNV(uint index, short* v) {
            Pointers.glVertexAttrib3svNV(index, v);
        }
        
        public static void glVertexAttrib3svNV(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib3svNV(index, v_);
        }
        
        public static void glVertexAttrib4Nbv(uint index, sbyte* v) {
            Pointers.glVertexAttrib4Nbv(index, v);
        }
        
        public static void glVertexAttrib4Nbv(uint index, sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glVertexAttrib4Nbv(index, v_);
        }
        
        public static void glVertexAttrib4NbvARB(uint index, sbyte* v) {
            Pointers.glVertexAttrib4NbvARB(index, v);
        }
        
        public static void glVertexAttrib4NbvARB(uint index, sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glVertexAttrib4NbvARB(index, v_);
        }
        
        public static void glVertexAttrib4Niv(uint index, int* v) {
            Pointers.glVertexAttrib4Niv(index, v);
        }
        
        public static void glVertexAttrib4Niv(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttrib4Niv(index, v_);
        }
        
        public static void glVertexAttrib4NivARB(uint index, int* v) {
            Pointers.glVertexAttrib4NivARB(index, v);
        }
        
        public static void glVertexAttrib4NivARB(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttrib4NivARB(index, v_);
        }
        
        public static void glVertexAttrib4Nsv(uint index, short* v) {
            Pointers.glVertexAttrib4Nsv(index, v);
        }
        
        public static void glVertexAttrib4Nsv(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib4Nsv(index, v_);
        }
        
        public static void glVertexAttrib4NsvARB(uint index, short* v) {
            Pointers.glVertexAttrib4NsvARB(index, v);
        }
        
        public static void glVertexAttrib4NsvARB(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib4NsvARB(index, v_);
        }
        
        public static void glVertexAttrib4Nub(uint index, byte x, byte y, byte z, byte w) {
            Pointers.glVertexAttrib4Nub(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4NubARB(uint index, byte x, byte y, byte z, byte w) {
            Pointers.glVertexAttrib4NubARB(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4Nubv(uint index, byte* v) {
            Pointers.glVertexAttrib4Nubv(index, v);
        }
        
        public static void glVertexAttrib4Nubv(uint index, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttrib4Nubv(index, v_);
        }
        
        public static void glVertexAttrib4NubvARB(uint index, byte* v) {
            Pointers.glVertexAttrib4NubvARB(index, v);
        }
        
        public static void glVertexAttrib4NubvARB(uint index, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttrib4NubvARB(index, v_);
        }
        
        public static void glVertexAttrib4Nuiv(uint index, uint* v) {
            Pointers.glVertexAttrib4Nuiv(index, v);
        }
        
        public static void glVertexAttrib4Nuiv(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttrib4Nuiv(index, v_);
        }
        
        public static void glVertexAttrib4NuivARB(uint index, uint* v) {
            Pointers.glVertexAttrib4NuivARB(index, v);
        }
        
        public static void glVertexAttrib4NuivARB(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttrib4NuivARB(index, v_);
        }
        
        public static void glVertexAttrib4Nusv(uint index, ushort* v) {
            Pointers.glVertexAttrib4Nusv(index, v);
        }
        
        public static void glVertexAttrib4Nusv(uint index, ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glVertexAttrib4Nusv(index, v_);
        }
        
        public static void glVertexAttrib4NusvARB(uint index, ushort* v) {
            Pointers.glVertexAttrib4NusvARB(index, v);
        }
        
        public static void glVertexAttrib4NusvARB(uint index, ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glVertexAttrib4NusvARB(index, v_);
        }
        
        public static void glVertexAttrib4bv(uint index, sbyte* v) {
            Pointers.glVertexAttrib4bv(index, v);
        }
        
        public static void glVertexAttrib4bv(uint index, sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glVertexAttrib4bv(index, v_);
        }
        
        public static void glVertexAttrib4bvARB(uint index, sbyte* v) {
            Pointers.glVertexAttrib4bvARB(index, v);
        }
        
        public static void glVertexAttrib4bvARB(uint index, sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glVertexAttrib4bvARB(index, v_);
        }
        
        public static void glVertexAttrib4d(uint index, double x, double y, double z, double w) {
            Pointers.glVertexAttrib4d(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4dARB(uint index, double x, double y, double z, double w) {
            Pointers.glVertexAttrib4dARB(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4dNV(uint index, double x, double y, double z, double w) {
            Pointers.glVertexAttrib4dNV(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4dv(uint index, double* v) {
            Pointers.glVertexAttrib4dv(index, v);
        }
        
        public static void glVertexAttrib4dv(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib4dv(index, v_);
        }
        
        public static void glVertexAttrib4dvARB(uint index, double* v) {
            Pointers.glVertexAttrib4dvARB(index, v);
        }
        
        public static void glVertexAttrib4dvARB(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib4dvARB(index, v_);
        }
        
        public static void glVertexAttrib4dvNV(uint index, double* v) {
            Pointers.glVertexAttrib4dvNV(index, v);
        }
        
        public static void glVertexAttrib4dvNV(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttrib4dvNV(index, v_);
        }
        
        public static void glVertexAttrib4f(uint index, float x, float y, float z, float w) {
            Pointers.glVertexAttrib4f(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4fARB(uint index, float x, float y, float z, float w) {
            Pointers.glVertexAttrib4fARB(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4fNV(uint index, float x, float y, float z, float w) {
            Pointers.glVertexAttrib4fNV(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4fv(uint index, float* v) {
            Pointers.glVertexAttrib4fv(index, v);
        }
        
        public static void glVertexAttrib4fv(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib4fv(index, v_);
        }
        
        public static void glVertexAttrib4fvARB(uint index, float* v) {
            Pointers.glVertexAttrib4fvARB(index, v);
        }
        
        public static void glVertexAttrib4fvARB(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib4fvARB(index, v_);
        }
        
        public static void glVertexAttrib4fvNV(uint index, float* v) {
            Pointers.glVertexAttrib4fvNV(index, v);
        }
        
        public static void glVertexAttrib4fvNV(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttrib4fvNV(index, v_);
        }
        
        public static void glVertexAttrib4hNV(uint index, short x, short y, short z, short w) {
            Pointers.glVertexAttrib4hNV(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4hvNV(uint index, short* v) {
            Pointers.glVertexAttrib4hvNV(index, v);
        }
        
        public static void glVertexAttrib4hvNV(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib4hvNV(index, v_);
        }
        
        public static void glVertexAttrib4iv(uint index, int* v) {
            Pointers.glVertexAttrib4iv(index, v);
        }
        
        public static void glVertexAttrib4iv(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttrib4iv(index, v_);
        }
        
        public static void glVertexAttrib4ivARB(uint index, int* v) {
            Pointers.glVertexAttrib4ivARB(index, v);
        }
        
        public static void glVertexAttrib4ivARB(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttrib4ivARB(index, v_);
        }
        
        public static void glVertexAttrib4s(uint index, short x, short y, short z, short w) {
            Pointers.glVertexAttrib4s(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4sARB(uint index, short x, short y, short z, short w) {
            Pointers.glVertexAttrib4sARB(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4sNV(uint index, short x, short y, short z, short w) {
            Pointers.glVertexAttrib4sNV(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4sv(uint index, short* v) {
            Pointers.glVertexAttrib4sv(index, v);
        }
        
        public static void glVertexAttrib4sv(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib4sv(index, v_);
        }
        
        public static void glVertexAttrib4svARB(uint index, short* v) {
            Pointers.glVertexAttrib4svARB(index, v);
        }
        
        public static void glVertexAttrib4svARB(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib4svARB(index, v_);
        }
        
        public static void glVertexAttrib4svNV(uint index, short* v) {
            Pointers.glVertexAttrib4svNV(index, v);
        }
        
        public static void glVertexAttrib4svNV(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttrib4svNV(index, v_);
        }
        
        public static void glVertexAttrib4ubNV(uint index, byte x, byte y, byte z, byte w) {
            Pointers.glVertexAttrib4ubNV(index, x, y, z, w);
        }
        
        public static void glVertexAttrib4ubv(uint index, byte* v) {
            Pointers.glVertexAttrib4ubv(index, v);
        }
        
        public static void glVertexAttrib4ubv(uint index, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttrib4ubv(index, v_);
        }
        
        public static void glVertexAttrib4ubvARB(uint index, byte* v) {
            Pointers.glVertexAttrib4ubvARB(index, v);
        }
        
        public static void glVertexAttrib4ubvARB(uint index, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttrib4ubvARB(index, v_);
        }
        
        public static void glVertexAttrib4ubvNV(uint index, byte* v) {
            Pointers.glVertexAttrib4ubvNV(index, v);
        }
        
        public static void glVertexAttrib4ubvNV(uint index, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttrib4ubvNV(index, v_);
        }
        
        public static void glVertexAttrib4uiv(uint index, uint* v) {
            Pointers.glVertexAttrib4uiv(index, v);
        }
        
        public static void glVertexAttrib4uiv(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttrib4uiv(index, v_);
        }
        
        public static void glVertexAttrib4uivARB(uint index, uint* v) {
            Pointers.glVertexAttrib4uivARB(index, v);
        }
        
        public static void glVertexAttrib4uivARB(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttrib4uivARB(index, v_);
        }
        
        public static void glVertexAttrib4usv(uint index, ushort* v) {
            Pointers.glVertexAttrib4usv(index, v);
        }
        
        public static void glVertexAttrib4usv(uint index, ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glVertexAttrib4usv(index, v_);
        }
        
        public static void glVertexAttrib4usvARB(uint index, ushort* v) {
            Pointers.glVertexAttrib4usvARB(index, v);
        }
        
        public static void glVertexAttrib4usvARB(uint index, ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glVertexAttrib4usvARB(index, v_);
        }
        
        public static void glVertexAttribArrayObjectATI(uint index, int size, int type, bool normalized, int stride, uint buffer, uint offset) {
            Pointers.glVertexAttribArrayObjectATI(index, size, type, normalized, stride, buffer, offset);
        }
        
        /// <summary>
        /// associate a vertex attribute and a vertex buffer binding for a vertex array object
        /// <para>
        /// glVertexAttribBinding and glVertexArrayAttribBinding establishes an association between the generic
        /// vertex attribute of a vertex array object whose index is given by attribindex, and a vertex buffer
        /// binding whose index is given by bindingindex. For glVertexAttribBinding, the vertex array object
        /// affected is that currently bound. For glVertexArrayAttribBinding, vaobj is the name of the vertex
        /// array object
        /// </para>
        /// </summary>
        /// <param name="attribindex">
        /// The index of the attribute to associate with a vertex buffer binding.
        /// </param>
        /// <param name="bindingindex">
        /// The index of the vertex buffer binding with which to associate the generic vertex attribute.
        /// </param>
        public static void glVertexAttribBinding(uint attribindex, uint bindingindex) {
            Pointers.glVertexAttribBinding(attribindex, bindingindex);
        }
        
        /// <summary>
        /// modify the rate at which generic vertex attributes advance during instanced rendering
        /// <para>
        /// glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering
        /// multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot
        /// index advances once per vertex. If divisor is non-zero, the attribute advances once per divisor
        /// instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its
        /// GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the index of the generic vertex attribute.
        /// </param>
        /// <param name="divisor">
        /// Specify the number of instances that will pass between updates of the generic attribute at slot
        /// index.
        /// </param>
        public static void glVertexAttribDivisor(uint index, uint divisor) {
            Pointers.glVertexAttribDivisor(index, divisor);
        }
        
        /// <summary>
        /// modify the rate at which generic vertex attributes advance during instanced rendering
        /// <para>
        /// glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering
        /// multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot
        /// index advances once per vertex. If divisor is non-zero, the attribute advances once per divisor
        /// instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its
        /// GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the index of the generic vertex attribute.
        /// </param>
        /// <param name="divisor">
        /// Specify the number of instances that will pass between updates of the generic attribute at slot
        /// index.
        /// </param>
        public static void glVertexAttribDivisorANGLE(uint index, uint divisor) {
            Pointers.glVertexAttribDivisorANGLE(index, divisor);
        }
        
        /// <summary>
        /// modify the rate at which generic vertex attributes advance during instanced rendering
        /// <para>
        /// glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering
        /// multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot
        /// index advances once per vertex. If divisor is non-zero, the attribute advances once per divisor
        /// instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its
        /// GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the index of the generic vertex attribute.
        /// </param>
        /// <param name="divisor">
        /// Specify the number of instances that will pass between updates of the generic attribute at slot
        /// index.
        /// </param>
        public static void glVertexAttribDivisorARB(uint index, uint divisor) {
            Pointers.glVertexAttribDivisorARB(index, divisor);
        }
        
        /// <summary>
        /// modify the rate at which generic vertex attributes advance during instanced rendering
        /// <para>
        /// glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering
        /// multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot
        /// index advances once per vertex. If divisor is non-zero, the attribute advances once per divisor
        /// instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its
        /// GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the index of the generic vertex attribute.
        /// </param>
        /// <param name="divisor">
        /// Specify the number of instances that will pass between updates of the generic attribute at slot
        /// index.
        /// </param>
        public static void glVertexAttribDivisorEXT(uint index, uint divisor) {
            Pointers.glVertexAttribDivisorEXT(index, divisor);
        }
        
        /// <summary>
        /// modify the rate at which generic vertex attributes advance during instanced rendering
        /// <para>
        /// glVertexAttribDivisor modifies the rate at which generic vertex attributes advance when rendering
        /// multiple instances of primitives in a single draw call. If divisor is zero, the attribute at slot
        /// index advances once per vertex. If divisor is non-zero, the attribute advances once per divisor
        /// instances of the set(s) of vertices being rendered. An attribute is referred to as instanced if its
        /// GL_VERTEX_ATTRIB_ARRAY_DIVISOR value is non-zero
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the index of the generic vertex attribute.
        /// </param>
        /// <param name="divisor">
        /// Specify the number of instances that will pass between updates of the generic attribute at slot
        /// index.
        /// </param>
        public static void glVertexAttribDivisorNV(uint index, uint divisor) {
            Pointers.glVertexAttribDivisorNV(index, divisor);
        }
        
        /// <summary>
        /// specify the organization of vertex arrays
        /// </summary>
        /// <param name="attribindex">
        /// The generic vertex attribute array being described.
        /// </param>
        /// <param name="size">
        /// The number of values per vertex that are stored in the array.
        /// </param>
        /// <param name="type">
        /// The type of the data stored in the array.
        /// </param>
        /// <param name="normalized">
        /// Specifies whether fixed-point data values should be normalized (GL_TRUE) or 		 converted directly as
        /// fixed-point values (GL_FALSE) when they are accessed. This parameter is ignored if type is GL_FIXED.
        /// </param>
        /// <param name="relativeoffset">
        /// The distance between elements within the buffer.
        /// </param>
        public static void glVertexAttribFormat(uint attribindex, int size, int type, bool normalized, uint relativeoffset) {
            Pointers.glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
        }
        
        public static void glVertexAttribFormatNV(uint index, int size, int type, bool normalized, int stride) {
            Pointers.glVertexAttribFormatNV(index, size, type, normalized, stride);
        }
        
        public static void glVertexAttribI1i(uint index, int x) {
            Pointers.glVertexAttribI1i(index, x);
        }
        
        public static void glVertexAttribI1iEXT(uint index, int x) {
            Pointers.glVertexAttribI1iEXT(index, x);
        }
        
        public static void glVertexAttribI1iv(uint index, int* v) {
            Pointers.glVertexAttribI1iv(index, v);
        }
        
        public static void glVertexAttribI1iv(uint index, out int v) {
            fixed(int* v_ = &v)
                Pointers.glVertexAttribI1iv(index, v_);
        }
        
        public static void glVertexAttribI1ivEXT(uint index, int* v) {
            Pointers.glVertexAttribI1ivEXT(index, v);
        }
        
        public static void glVertexAttribI1ivEXT(uint index, out int v) {
            fixed(int* v_ = &v)
                Pointers.glVertexAttribI1ivEXT(index, v_);
        }
        
        public static void glVertexAttribI1ui(uint index, uint x) {
            Pointers.glVertexAttribI1ui(index, x);
        }
        
        public static void glVertexAttribI1uiEXT(uint index, uint x) {
            Pointers.glVertexAttribI1uiEXT(index, x);
        }
        
        public static void glVertexAttribI1uiv(uint index, uint* v) {
            Pointers.glVertexAttribI1uiv(index, v);
        }
        
        public static void glVertexAttribI1uiv(uint index, out uint v) {
            fixed(uint* v_ = &v)
                Pointers.glVertexAttribI1uiv(index, v_);
        }
        
        public static void glVertexAttribI1uivEXT(uint index, uint* v) {
            Pointers.glVertexAttribI1uivEXT(index, v);
        }
        
        public static void glVertexAttribI1uivEXT(uint index, out uint v) {
            fixed(uint* v_ = &v)
                Pointers.glVertexAttribI1uivEXT(index, v_);
        }
        
        public static void glVertexAttribI2i(uint index, int x, int y) {
            Pointers.glVertexAttribI2i(index, x, y);
        }
        
        public static void glVertexAttribI2iEXT(uint index, int x, int y) {
            Pointers.glVertexAttribI2iEXT(index, x, y);
        }
        
        public static void glVertexAttribI2iv(uint index, int* v) {
            Pointers.glVertexAttribI2iv(index, v);
        }
        
        public static void glVertexAttribI2iv(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttribI2iv(index, v_);
        }
        
        public static void glVertexAttribI2ivEXT(uint index, int* v) {
            Pointers.glVertexAttribI2ivEXT(index, v);
        }
        
        public static void glVertexAttribI2ivEXT(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttribI2ivEXT(index, v_);
        }
        
        public static void glVertexAttribI2ui(uint index, uint x, uint y) {
            Pointers.glVertexAttribI2ui(index, x, y);
        }
        
        public static void glVertexAttribI2uiEXT(uint index, uint x, uint y) {
            Pointers.glVertexAttribI2uiEXT(index, x, y);
        }
        
        public static void glVertexAttribI2uiv(uint index, uint* v) {
            Pointers.glVertexAttribI2uiv(index, v);
        }
        
        public static void glVertexAttribI2uiv(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttribI2uiv(index, v_);
        }
        
        public static void glVertexAttribI2uivEXT(uint index, uint* v) {
            Pointers.glVertexAttribI2uivEXT(index, v);
        }
        
        public static void glVertexAttribI2uivEXT(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttribI2uivEXT(index, v_);
        }
        
        public static void glVertexAttribI3i(uint index, int x, int y, int z) {
            Pointers.glVertexAttribI3i(index, x, y, z);
        }
        
        public static void glVertexAttribI3iEXT(uint index, int x, int y, int z) {
            Pointers.glVertexAttribI3iEXT(index, x, y, z);
        }
        
        public static void glVertexAttribI3iv(uint index, int* v) {
            Pointers.glVertexAttribI3iv(index, v);
        }
        
        public static void glVertexAttribI3iv(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttribI3iv(index, v_);
        }
        
        public static void glVertexAttribI3ivEXT(uint index, int* v) {
            Pointers.glVertexAttribI3ivEXT(index, v);
        }
        
        public static void glVertexAttribI3ivEXT(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttribI3ivEXT(index, v_);
        }
        
        public static void glVertexAttribI3ui(uint index, uint x, uint y, uint z) {
            Pointers.glVertexAttribI3ui(index, x, y, z);
        }
        
        public static void glVertexAttribI3uiEXT(uint index, uint x, uint y, uint z) {
            Pointers.glVertexAttribI3uiEXT(index, x, y, z);
        }
        
        public static void glVertexAttribI3uiv(uint index, uint* v) {
            Pointers.glVertexAttribI3uiv(index, v);
        }
        
        public static void glVertexAttribI3uiv(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttribI3uiv(index, v_);
        }
        
        public static void glVertexAttribI3uivEXT(uint index, uint* v) {
            Pointers.glVertexAttribI3uivEXT(index, v);
        }
        
        public static void glVertexAttribI3uivEXT(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttribI3uivEXT(index, v_);
        }
        
        public static void glVertexAttribI4bv(uint index, sbyte* v) {
            Pointers.glVertexAttribI4bv(index, v);
        }
        
        public static void glVertexAttribI4bv(uint index, sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glVertexAttribI4bv(index, v_);
        }
        
        public static void glVertexAttribI4bvEXT(uint index, sbyte* v) {
            Pointers.glVertexAttribI4bvEXT(index, v);
        }
        
        public static void glVertexAttribI4bvEXT(uint index, sbyte[] v) {
            fixed(sbyte* v_ = &v[0])
                Pointers.glVertexAttribI4bvEXT(index, v_);
        }
        
        public static void glVertexAttribI4i(uint index, int x, int y, int z, int w) {
            Pointers.glVertexAttribI4i(index, x, y, z, w);
        }
        
        public static void glVertexAttribI4iEXT(uint index, int x, int y, int z, int w) {
            Pointers.glVertexAttribI4iEXT(index, x, y, z, w);
        }
        
        public static void glVertexAttribI4iv(uint index, int* v) {
            Pointers.glVertexAttribI4iv(index, v);
        }
        
        public static void glVertexAttribI4iv(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttribI4iv(index, v_);
        }
        
        public static void glVertexAttribI4ivEXT(uint index, int* v) {
            Pointers.glVertexAttribI4ivEXT(index, v);
        }
        
        public static void glVertexAttribI4ivEXT(uint index, int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glVertexAttribI4ivEXT(index, v_);
        }
        
        public static void glVertexAttribI4sv(uint index, short* v) {
            Pointers.glVertexAttribI4sv(index, v);
        }
        
        public static void glVertexAttribI4sv(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribI4sv(index, v_);
        }
        
        public static void glVertexAttribI4svEXT(uint index, short* v) {
            Pointers.glVertexAttribI4svEXT(index, v);
        }
        
        public static void glVertexAttribI4svEXT(uint index, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribI4svEXT(index, v_);
        }
        
        public static void glVertexAttribI4ubv(uint index, byte* v) {
            Pointers.glVertexAttribI4ubv(index, v);
        }
        
        public static void glVertexAttribI4ubv(uint index, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttribI4ubv(index, v_);
        }
        
        public static void glVertexAttribI4ubvEXT(uint index, byte* v) {
            Pointers.glVertexAttribI4ubvEXT(index, v);
        }
        
        public static void glVertexAttribI4ubvEXT(uint index, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttribI4ubvEXT(index, v_);
        }
        
        public static void glVertexAttribI4ui(uint index, uint x, uint y, uint z, uint w) {
            Pointers.glVertexAttribI4ui(index, x, y, z, w);
        }
        
        public static void glVertexAttribI4uiEXT(uint index, uint x, uint y, uint z, uint w) {
            Pointers.glVertexAttribI4uiEXT(index, x, y, z, w);
        }
        
        public static void glVertexAttribI4uiv(uint index, uint* v) {
            Pointers.glVertexAttribI4uiv(index, v);
        }
        
        public static void glVertexAttribI4uiv(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttribI4uiv(index, v_);
        }
        
        public static void glVertexAttribI4uivEXT(uint index, uint* v) {
            Pointers.glVertexAttribI4uivEXT(index, v);
        }
        
        public static void glVertexAttribI4uivEXT(uint index, uint[] v) {
            fixed(uint* v_ = &v[0])
                Pointers.glVertexAttribI4uivEXT(index, v_);
        }
        
        public static void glVertexAttribI4usv(uint index, ushort* v) {
            Pointers.glVertexAttribI4usv(index, v);
        }
        
        public static void glVertexAttribI4usv(uint index, ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glVertexAttribI4usv(index, v_);
        }
        
        public static void glVertexAttribI4usvEXT(uint index, ushort* v) {
            Pointers.glVertexAttribI4usvEXT(index, v);
        }
        
        public static void glVertexAttribI4usvEXT(uint index, ushort[] v) {
            fixed(ushort* v_ = &v[0])
                Pointers.glVertexAttribI4usvEXT(index, v_);
        }
        
        public static void glVertexAttribIFormat(uint attribindex, int size, int type, uint relativeoffset) {
            Pointers.glVertexAttribIFormat(attribindex, size, type, relativeoffset);
        }
        
        public static void glVertexAttribIFormatNV(uint index, int size, int type, int stride) {
            Pointers.glVertexAttribIFormatNV(index, size, type, stride);
        }
        
        public static void glVertexAttribIPointer(uint index, int size, int type, int stride, IntPtr pointer) {
            Pointers.glVertexAttribIPointer(index, size, type, stride, pointer);
        }
        
        public static void glVertexAttribIPointerEXT(uint index, int size, int type, int stride, IntPtr pointer) {
            Pointers.glVertexAttribIPointerEXT(index, size, type, stride, pointer);
        }
        
        public static void glVertexAttribL1d(uint index, double x) {
            Pointers.glVertexAttribL1d(index, x);
        }
        
        public static void glVertexAttribL1dEXT(uint index, double x) {
            Pointers.glVertexAttribL1dEXT(index, x);
        }
        
        public static void glVertexAttribL1dv(uint index, double* v) {
            Pointers.glVertexAttribL1dv(index, v);
        }
        
        public static void glVertexAttribL1dv(uint index, out double v) {
            fixed(double* v_ = &v)
                Pointers.glVertexAttribL1dv(index, v_);
        }
        
        public static void glVertexAttribL1dvEXT(uint index, double* v) {
            Pointers.glVertexAttribL1dvEXT(index, v);
        }
        
        public static void glVertexAttribL1dvEXT(uint index, out double v) {
            fixed(double* v_ = &v)
                Pointers.glVertexAttribL1dvEXT(index, v_);
        }
        
        public static void glVertexAttribL1i64NV(uint index, long x) {
            Pointers.glVertexAttribL1i64NV(index, x);
        }
        
        public static void glVertexAttribL1i64vNV(uint index, long* v) {
            Pointers.glVertexAttribL1i64vNV(index, v);
        }
        
        public static void glVertexAttribL1i64vNV(uint index, out long v) {
            fixed(long* v_ = &v)
                Pointers.glVertexAttribL1i64vNV(index, v_);
        }
        
        public static void glVertexAttribL1ui64ARB(uint index, ulong x) {
            Pointers.glVertexAttribL1ui64ARB(index, x);
        }
        
        public static void glVertexAttribL1ui64NV(uint index, ulong x) {
            Pointers.glVertexAttribL1ui64NV(index, x);
        }
        
        public static void glVertexAttribL1ui64vARB(uint index, ulong* v) {
            Pointers.glVertexAttribL1ui64vARB(index, v);
        }
        
        public static void glVertexAttribL1ui64vARB(uint index, ulong[] v) {
            fixed(ulong* v_ = &v[0])
                Pointers.glVertexAttribL1ui64vARB(index, v_);
        }
        
        public static void glVertexAttribL1ui64vNV(uint index, ulong* v) {
            Pointers.glVertexAttribL1ui64vNV(index, v);
        }
        
        public static void glVertexAttribL1ui64vNV(uint index, out ulong v) {
            fixed(ulong* v_ = &v)
                Pointers.glVertexAttribL1ui64vNV(index, v_);
        }
        
        public static void glVertexAttribL2d(uint index, double x, double y) {
            Pointers.glVertexAttribL2d(index, x, y);
        }
        
        public static void glVertexAttribL2dEXT(uint index, double x, double y) {
            Pointers.glVertexAttribL2dEXT(index, x, y);
        }
        
        public static void glVertexAttribL2dv(uint index, double* v) {
            Pointers.glVertexAttribL2dv(index, v);
        }
        
        public static void glVertexAttribL2dv(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribL2dv(index, v_);
        }
        
        public static void glVertexAttribL2dvEXT(uint index, double* v) {
            Pointers.glVertexAttribL2dvEXT(index, v);
        }
        
        public static void glVertexAttribL2dvEXT(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribL2dvEXT(index, v_);
        }
        
        public static void glVertexAttribL2i64NV(uint index, long x, long y) {
            Pointers.glVertexAttribL2i64NV(index, x, y);
        }
        
        public static void glVertexAttribL2i64vNV(uint index, long* v) {
            Pointers.glVertexAttribL2i64vNV(index, v);
        }
        
        public static void glVertexAttribL2i64vNV(uint index, long[] v) {
            fixed(long* v_ = &v[0])
                Pointers.glVertexAttribL2i64vNV(index, v_);
        }
        
        public static void glVertexAttribL2ui64NV(uint index, ulong x, ulong y) {
            Pointers.glVertexAttribL2ui64NV(index, x, y);
        }
        
        public static void glVertexAttribL2ui64vNV(uint index, ulong* v) {
            Pointers.glVertexAttribL2ui64vNV(index, v);
        }
        
        public static void glVertexAttribL2ui64vNV(uint index, ulong[] v) {
            fixed(ulong* v_ = &v[0])
                Pointers.glVertexAttribL2ui64vNV(index, v_);
        }
        
        public static void glVertexAttribL3d(uint index, double x, double y, double z) {
            Pointers.glVertexAttribL3d(index, x, y, z);
        }
        
        public static void glVertexAttribL3dEXT(uint index, double x, double y, double z) {
            Pointers.glVertexAttribL3dEXT(index, x, y, z);
        }
        
        public static void glVertexAttribL3dv(uint index, double* v) {
            Pointers.glVertexAttribL3dv(index, v);
        }
        
        public static void glVertexAttribL3dv(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribL3dv(index, v_);
        }
        
        public static void glVertexAttribL3dvEXT(uint index, double* v) {
            Pointers.glVertexAttribL3dvEXT(index, v);
        }
        
        public static void glVertexAttribL3dvEXT(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribL3dvEXT(index, v_);
        }
        
        public static void glVertexAttribL3i64NV(uint index, long x, long y, long z) {
            Pointers.glVertexAttribL3i64NV(index, x, y, z);
        }
        
        public static void glVertexAttribL3i64vNV(uint index, long* v) {
            Pointers.glVertexAttribL3i64vNV(index, v);
        }
        
        public static void glVertexAttribL3i64vNV(uint index, long[] v) {
            fixed(long* v_ = &v[0])
                Pointers.glVertexAttribL3i64vNV(index, v_);
        }
        
        public static void glVertexAttribL3ui64NV(uint index, ulong x, ulong y, ulong z) {
            Pointers.glVertexAttribL3ui64NV(index, x, y, z);
        }
        
        public static void glVertexAttribL3ui64vNV(uint index, ulong* v) {
            Pointers.glVertexAttribL3ui64vNV(index, v);
        }
        
        public static void glVertexAttribL3ui64vNV(uint index, ulong[] v) {
            fixed(ulong* v_ = &v[0])
                Pointers.glVertexAttribL3ui64vNV(index, v_);
        }
        
        public static void glVertexAttribL4d(uint index, double x, double y, double z, double w) {
            Pointers.glVertexAttribL4d(index, x, y, z, w);
        }
        
        public static void glVertexAttribL4dEXT(uint index, double x, double y, double z, double w) {
            Pointers.glVertexAttribL4dEXT(index, x, y, z, w);
        }
        
        public static void glVertexAttribL4dv(uint index, double* v) {
            Pointers.glVertexAttribL4dv(index, v);
        }
        
        public static void glVertexAttribL4dv(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribL4dv(index, v_);
        }
        
        public static void glVertexAttribL4dvEXT(uint index, double* v) {
            Pointers.glVertexAttribL4dvEXT(index, v);
        }
        
        public static void glVertexAttribL4dvEXT(uint index, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribL4dvEXT(index, v_);
        }
        
        public static void glVertexAttribL4i64NV(uint index, long x, long y, long z, long w) {
            Pointers.glVertexAttribL4i64NV(index, x, y, z, w);
        }
        
        public static void glVertexAttribL4i64vNV(uint index, long* v) {
            Pointers.glVertexAttribL4i64vNV(index, v);
        }
        
        public static void glVertexAttribL4i64vNV(uint index, long[] v) {
            fixed(long* v_ = &v[0])
                Pointers.glVertexAttribL4i64vNV(index, v_);
        }
        
        public static void glVertexAttribL4ui64NV(uint index, ulong x, ulong y, ulong z, ulong w) {
            Pointers.glVertexAttribL4ui64NV(index, x, y, z, w);
        }
        
        public static void glVertexAttribL4ui64vNV(uint index, ulong* v) {
            Pointers.glVertexAttribL4ui64vNV(index, v);
        }
        
        public static void glVertexAttribL4ui64vNV(uint index, ulong[] v) {
            fixed(ulong* v_ = &v[0])
                Pointers.glVertexAttribL4ui64vNV(index, v_);
        }
        
        public static void glVertexAttribLFormat(uint attribindex, int size, int type, uint relativeoffset) {
            Pointers.glVertexAttribLFormat(attribindex, size, type, relativeoffset);
        }
        
        public static void glVertexAttribLFormatNV(uint index, int size, int type, int stride) {
            Pointers.glVertexAttribLFormatNV(index, size, type, stride);
        }
        
        public static void glVertexAttribLPointer(uint index, int size, int type, int stride, IntPtr pointer) {
            Pointers.glVertexAttribLPointer(index, size, type, stride, pointer);
        }
        
        public static void glVertexAttribLPointerEXT(uint index, int size, int type, int stride, IntPtr pointer) {
            Pointers.glVertexAttribLPointerEXT(index, size, type, stride, pointer);
        }
        
        public static void glVertexAttribP1ui(uint index, int type, bool normalized, uint value) {
            Pointers.glVertexAttribP1ui(index, type, normalized, value);
        }
        
        public static void glVertexAttribP1uiv(uint index, int type, bool normalized, uint* value) {
            Pointers.glVertexAttribP1uiv(index, type, normalized, value);
        }
        
        public static void glVertexAttribP1uiv(uint index, int type, bool normalized, out uint value) {
            fixed(uint* value_ = &value)
                Pointers.glVertexAttribP1uiv(index, type, normalized, value_);
        }
        
        public static void glVertexAttribP2ui(uint index, int type, bool normalized, uint value) {
            Pointers.glVertexAttribP2ui(index, type, normalized, value);
        }
        
        public static void glVertexAttribP2uiv(uint index, int type, bool normalized, uint* value) {
            Pointers.glVertexAttribP2uiv(index, type, normalized, value);
        }
        
        public static void glVertexAttribP2uiv(uint index, int type, bool normalized, out uint value) {
            fixed(uint* value_ = &value)
                Pointers.glVertexAttribP2uiv(index, type, normalized, value_);
        }
        
        public static void glVertexAttribP3ui(uint index, int type, bool normalized, uint value) {
            Pointers.glVertexAttribP3ui(index, type, normalized, value);
        }
        
        public static void glVertexAttribP3uiv(uint index, int type, bool normalized, uint* value) {
            Pointers.glVertexAttribP3uiv(index, type, normalized, value);
        }
        
        public static void glVertexAttribP3uiv(uint index, int type, bool normalized, out uint value) {
            fixed(uint* value_ = &value)
                Pointers.glVertexAttribP3uiv(index, type, normalized, value_);
        }
        
        public static void glVertexAttribP4ui(uint index, int type, bool normalized, uint value) {
            Pointers.glVertexAttribP4ui(index, type, normalized, value);
        }
        
        public static void glVertexAttribP4uiv(uint index, int type, bool normalized, uint* value) {
            Pointers.glVertexAttribP4uiv(index, type, normalized, value);
        }
        
        public static void glVertexAttribP4uiv(uint index, int type, bool normalized, out uint value) {
            fixed(uint* value_ = &value)
                Pointers.glVertexAttribP4uiv(index, type, normalized, value_);
        }
        
        public static void glVertexAttribParameteriAMD(uint index, int pname, int param) {
            Pointers.glVertexAttribParameteriAMD(index, pname, param);
        }
        
        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>
        /// glVertexAttribPointer, glVertexAttribIPointer and glVertexAttribLPointer specify the location and
        /// data format of the array of generic vertex attributes at index index to use when rendering. size
        /// specifies the number of components per attribute and must be 1, 2, 3, 4, or GL_BGRA. type specifies
        /// the data type of each component, and stride specifies the byte stride from one attribute to the
        /// next, allowing vertices and attributes to be packed into a single array or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally,
        /// the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE,
        /// GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by
        /// glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE,
        /// GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV
        /// are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is
        /// the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE)
        /// or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic
        /// vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the
        /// data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </param>
        public static void glVertexAttribPointer(uint index, int size, int type, bool normalized, int stride, IntPtr pointer) {
            Pointers.glVertexAttribPointer(index, size, type, normalized, stride, pointer);
        }
        
        /// <summary>
        /// define an array of generic vertex attribute data
        /// <para>
        /// glVertexAttribPointer, glVertexAttribIPointer and glVertexAttribLPointer specify the location and
        /// data format of the array of generic vertex attributes at index index to use when rendering. size
        /// specifies the number of components per attribute and must be 1, 2, 3, 4, or GL_BGRA. type specifies
        /// the data type of each component, and stride specifies the byte stride from one attribute to the
        /// next, allowing vertices and attributes to be packed into a single array or stored in separate arrays
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specifies the index of the generic vertex attribute to be modified.
        /// </param>
        /// <param name="size">
        /// Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally,
        /// the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each component in the array. The symbolic constants GL_BYTE,
        /// GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, and GL_UNSIGNED_INT are accepted by
        /// glVertexAttribPointer and glVertexAttribIPointer. Additionally GL_HALF_FLOAT, GL_FLOAT, GL_DOUBLE,
        /// GL_FIXED, GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV and GL_UNSIGNED_INT_10F_11F_11F_REV
        /// are accepted by glVertexAttribPointer. GL_DOUBLE is also accepted by glVertexAttribLPointer and is
        /// the only token accepted by the type parameter for that function. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="normalized">
        /// For glVertexAttribPointer, specifies whether fixed-point data values should be normalized (GL_TRUE)
        /// or converted directly as fixed-point values (GL_FALSE) when they are accessed.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive generic vertex attributes. If stride is 0, the generic
        /// vertex attributes are understood to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a offset of the first component of the first generic vertex attribute in the array in the
        /// data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0.
        /// </param>
        public static void glVertexAttribPointerARB(uint index, int size, int type, bool normalized, int stride, IntPtr pointer) {
            Pointers.glVertexAttribPointerARB(index, size, type, normalized, stride, pointer);
        }
        
        public static void glVertexAttribPointerNV(uint index, int fsize, int type, int stride, IntPtr pointer) {
            Pointers.glVertexAttribPointerNV(index, fsize, type, stride, pointer);
        }
        
        public static void glVertexAttribs1dvNV(uint index, int count, double* v) {
            Pointers.glVertexAttribs1dvNV(index, count, v);
        }
        
        public static void glVertexAttribs1dvNV(uint index, int count, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribs1dvNV(index, count, v_);
        }
        
        public static void glVertexAttribs1fvNV(uint index, int count, float* v) {
            Pointers.glVertexAttribs1fvNV(index, count, v);
        }
        
        public static void glVertexAttribs1fvNV(uint index, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttribs1fvNV(index, count, v_);
        }
        
        public static void glVertexAttribs1hvNV(uint index, int n, short* v) {
            Pointers.glVertexAttribs1hvNV(index, n, v);
        }
        
        public static void glVertexAttribs1hvNV(uint index, int n, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs1hvNV(index, n, v_);
        }
        
        public static void glVertexAttribs1svNV(uint index, int count, short* v) {
            Pointers.glVertexAttribs1svNV(index, count, v);
        }
        
        public static void glVertexAttribs1svNV(uint index, int count, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs1svNV(index, count, v_);
        }
        
        public static void glVertexAttribs2dvNV(uint index, int count, double* v) {
            Pointers.glVertexAttribs2dvNV(index, count, v);
        }
        
        public static void glVertexAttribs2dvNV(uint index, int count, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribs2dvNV(index, count, v_);
        }
        
        public static void glVertexAttribs2fvNV(uint index, int count, float* v) {
            Pointers.glVertexAttribs2fvNV(index, count, v);
        }
        
        public static void glVertexAttribs2fvNV(uint index, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttribs2fvNV(index, count, v_);
        }
        
        public static void glVertexAttribs2hvNV(uint index, int n, short* v) {
            Pointers.glVertexAttribs2hvNV(index, n, v);
        }
        
        public static void glVertexAttribs2hvNV(uint index, int n, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs2hvNV(index, n, v_);
        }
        
        public static void glVertexAttribs2svNV(uint index, int count, short* v) {
            Pointers.glVertexAttribs2svNV(index, count, v);
        }
        
        public static void glVertexAttribs2svNV(uint index, int count, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs2svNV(index, count, v_);
        }
        
        public static void glVertexAttribs3dvNV(uint index, int count, double* v) {
            Pointers.glVertexAttribs3dvNV(index, count, v);
        }
        
        public static void glVertexAttribs3dvNV(uint index, int count, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribs3dvNV(index, count, v_);
        }
        
        public static void glVertexAttribs3fvNV(uint index, int count, float* v) {
            Pointers.glVertexAttribs3fvNV(index, count, v);
        }
        
        public static void glVertexAttribs3fvNV(uint index, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttribs3fvNV(index, count, v_);
        }
        
        public static void glVertexAttribs3hvNV(uint index, int n, short* v) {
            Pointers.glVertexAttribs3hvNV(index, n, v);
        }
        
        public static void glVertexAttribs3hvNV(uint index, int n, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs3hvNV(index, n, v_);
        }
        
        public static void glVertexAttribs3svNV(uint index, int count, short* v) {
            Pointers.glVertexAttribs3svNV(index, count, v);
        }
        
        public static void glVertexAttribs3svNV(uint index, int count, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs3svNV(index, count, v_);
        }
        
        public static void glVertexAttribs4dvNV(uint index, int count, double* v) {
            Pointers.glVertexAttribs4dvNV(index, count, v);
        }
        
        public static void glVertexAttribs4dvNV(uint index, int count, double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glVertexAttribs4dvNV(index, count, v_);
        }
        
        public static void glVertexAttribs4fvNV(uint index, int count, float* v) {
            Pointers.glVertexAttribs4fvNV(index, count, v);
        }
        
        public static void glVertexAttribs4fvNV(uint index, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glVertexAttribs4fvNV(index, count, v_);
        }
        
        public static void glVertexAttribs4hvNV(uint index, int n, short* v) {
            Pointers.glVertexAttribs4hvNV(index, n, v);
        }
        
        public static void glVertexAttribs4hvNV(uint index, int n, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs4hvNV(index, n, v_);
        }
        
        public static void glVertexAttribs4svNV(uint index, int count, short* v) {
            Pointers.glVertexAttribs4svNV(index, count, v);
        }
        
        public static void glVertexAttribs4svNV(uint index, int count, short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glVertexAttribs4svNV(index, count, v_);
        }
        
        public static void glVertexAttribs4ubvNV(uint index, int count, byte* v) {
            Pointers.glVertexAttribs4ubvNV(index, count, v);
        }
        
        public static void glVertexAttribs4ubvNV(uint index, int count, byte[] v) {
            fixed(byte* v_ = &v[0])
                Pointers.glVertexAttribs4ubvNV(index, count, v_);
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="bindingindex">
        /// The index of the binding whose divisor to modify.
        /// </param>
        /// <param name="divisor">
        /// The new value for the instance step rate to apply.
        /// </param>
        public static void glVertexBindingDivisor(uint bindingindex, uint divisor) {
            Pointers.glVertexBindingDivisor(bindingindex, divisor);
        }
        
        public static void glVertexBlendARB(int count) {
            Pointers.glVertexBlendARB(count);
        }
        
        public static void glVertexBlendEnvfATI(int pname, float param) {
            Pointers.glVertexBlendEnvfATI(pname, param);
        }
        
        public static void glVertexBlendEnviATI(int pname, int param) {
            Pointers.glVertexBlendEnviATI(pname, param);
        }
        
        public static void glVertexFormatNV(int size, int type, int stride) {
            Pointers.glVertexFormatNV(size, type, stride);
        }
        
        public static void glVertexP2ui(int type, uint value) {
            Pointers.glVertexP2ui(type, value);
        }
        
        public static void glVertexP2uiv(int type, uint* value) {
            Pointers.glVertexP2uiv(type, value);
        }
        
        public static void glVertexP2uiv(int type, out uint value) {
            fixed(uint* value_ = &value)
                Pointers.glVertexP2uiv(type, value_);
        }
        
        public static void glVertexP3ui(int type, uint value) {
            Pointers.glVertexP3ui(type, value);
        }
        
        public static void glVertexP3uiv(int type, uint* value) {
            Pointers.glVertexP3uiv(type, value);
        }
        
        public static void glVertexP3uiv(int type, out uint value) {
            fixed(uint* value_ = &value)
                Pointers.glVertexP3uiv(type, value_);
        }
        
        public static void glVertexP4ui(int type, uint value) {
            Pointers.glVertexP4ui(type, value);
        }
        
        public static void glVertexP4uiv(int type, uint* value) {
            Pointers.glVertexP4uiv(type, value);
        }
        
        public static void glVertexP4uiv(int type, out uint value) {
            fixed(uint* value_ = &value)
                Pointers.glVertexP4uiv(type, value_);
        }
        
        /// <summary>
        /// define an array of vertex data
        /// <para>
        /// glVertexPointer specifies the location and data format of an array of vertex coordinates to use when
        /// rendering. size specifies the number of coordinates per vertex, and must be 2, 3, or 4. type
        /// specifies the data type of each coordinate, and stride specifies the byte stride from one vertex to
        /// the next, allowing vertices and attributes to be packed into a single array or stored in separate
        /// arrays. (Single-array storage may be more efficient on some implementations; see
        /// glInterleavedArrays.)
        /// </para>
        /// </summary>
        /// <param name="size">
        /// Specifies the number of coordinates per vertex. Must be 2, 3, or 4. The initial value is 4.
        /// </param>
        /// <param name="type">
        /// Specifies the data type of each coordinate in the array. Symbolic constants GL_SHORT, GL_INT,
        /// GL_FLOAT, or GL_DOUBLE are accepted. The initial value is GL_FLOAT.
        /// </param>
        /// <param name="stride">
        /// Specifies the byte offset between consecutive vertices. If stride is 0, the vertices are understood
        /// to be tightly packed in the array. The initial value is 0.
        /// </param>
        /// <param name="pointer">
        /// Specifies a pointer to the first coordinate of the first vertex in the array. The initial value is
        /// 0.
        /// </param>
        public static void glVertexPointer(int size, int type, int stride, IntPtr pointer) {
            Pointers.glVertexPointer(size, type, stride, pointer);
        }
        
        public static void glVertexPointerEXT(int size, int type, int stride, int count, IntPtr pointer) {
            Pointers.glVertexPointerEXT(size, type, stride, count, pointer);
        }
        
        public static void glVertexPointerListIBM(int size, int type, int stride, IntPtr* pointer, int ptrstride) {
            Pointers.glVertexPointerListIBM(size, type, stride, pointer, ptrstride);
        }
        
        public static void glVertexPointerListIBM(int size, int type, int stride, IntPtr[] pointer, int ptrstride) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glVertexPointerListIBM(size, type, stride, pointer_, ptrstride);
        }
        
        public static void glVertexPointervINTEL(int size, int type, IntPtr* pointer) {
            Pointers.glVertexPointervINTEL(size, type, pointer);
        }
        
        public static void glVertexPointervINTEL(int size, int type, IntPtr[] pointer) {
            fixed(IntPtr* pointer_ = &pointer[0])
                Pointers.glVertexPointervINTEL(size, type, pointer_);
        }
        
        public static void glVertexStream1dATI(int stream, double x) {
            Pointers.glVertexStream1dATI(stream, x);
        }
        
        public static void glVertexStream1dvATI(int stream, double* coords) {
            Pointers.glVertexStream1dvATI(stream, coords);
        }
        
        public static void glVertexStream1dvATI(int stream, out double coords) {
            fixed(double* coords_ = &coords)
                Pointers.glVertexStream1dvATI(stream, coords_);
        }
        
        public static void glVertexStream1fATI(int stream, float x) {
            Pointers.glVertexStream1fATI(stream, x);
        }
        
        public static void glVertexStream1fvATI(int stream, float* coords) {
            Pointers.glVertexStream1fvATI(stream, coords);
        }
        
        public static void glVertexStream1fvATI(int stream, out float coords) {
            fixed(float* coords_ = &coords)
                Pointers.glVertexStream1fvATI(stream, coords_);
        }
        
        public static void glVertexStream1iATI(int stream, int x) {
            Pointers.glVertexStream1iATI(stream, x);
        }
        
        public static void glVertexStream1ivATI(int stream, int* coords) {
            Pointers.glVertexStream1ivATI(stream, coords);
        }
        
        public static void glVertexStream1ivATI(int stream, out int coords) {
            fixed(int* coords_ = &coords)
                Pointers.glVertexStream1ivATI(stream, coords_);
        }
        
        public static void glVertexStream1sATI(int stream, short x) {
            Pointers.glVertexStream1sATI(stream, x);
        }
        
        public static void glVertexStream1svATI(int stream, short* coords) {
            Pointers.glVertexStream1svATI(stream, coords);
        }
        
        public static void glVertexStream1svATI(int stream, out short coords) {
            fixed(short* coords_ = &coords)
                Pointers.glVertexStream1svATI(stream, coords_);
        }
        
        public static void glVertexStream2dATI(int stream, double x, double y) {
            Pointers.glVertexStream2dATI(stream, x, y);
        }
        
        public static void glVertexStream2dvATI(int stream, double* coords) {
            Pointers.glVertexStream2dvATI(stream, coords);
        }
        
        public static void glVertexStream2dvATI(int stream, double[] coords) {
            fixed(double* coords_ = &coords[0])
                Pointers.glVertexStream2dvATI(stream, coords_);
        }
        
        public static void glVertexStream2fATI(int stream, float x, float y) {
            Pointers.glVertexStream2fATI(stream, x, y);
        }
        
        public static void glVertexStream2fvATI(int stream, float* coords) {
            Pointers.glVertexStream2fvATI(stream, coords);
        }
        
        public static void glVertexStream2fvATI(int stream, float[] coords) {
            fixed(float* coords_ = &coords[0])
                Pointers.glVertexStream2fvATI(stream, coords_);
        }
        
        public static void glVertexStream2iATI(int stream, int x, int y) {
            Pointers.glVertexStream2iATI(stream, x, y);
        }
        
        public static void glVertexStream2ivATI(int stream, int* coords) {
            Pointers.glVertexStream2ivATI(stream, coords);
        }
        
        public static void glVertexStream2ivATI(int stream, int[] coords) {
            fixed(int* coords_ = &coords[0])
                Pointers.glVertexStream2ivATI(stream, coords_);
        }
        
        public static void glVertexStream2sATI(int stream, short x, short y) {
            Pointers.glVertexStream2sATI(stream, x, y);
        }
        
        public static void glVertexStream2svATI(int stream, short* coords) {
            Pointers.glVertexStream2svATI(stream, coords);
        }
        
        public static void glVertexStream2svATI(int stream, short[] coords) {
            fixed(short* coords_ = &coords[0])
                Pointers.glVertexStream2svATI(stream, coords_);
        }
        
        public static void glVertexStream3dATI(int stream, double x, double y, double z) {
            Pointers.glVertexStream3dATI(stream, x, y, z);
        }
        
        public static void glVertexStream3dvATI(int stream, double* coords) {
            Pointers.glVertexStream3dvATI(stream, coords);
        }
        
        public static void glVertexStream3dvATI(int stream, double[] coords) {
            fixed(double* coords_ = &coords[0])
                Pointers.glVertexStream3dvATI(stream, coords_);
        }
        
        public static void glVertexStream3fATI(int stream, float x, float y, float z) {
            Pointers.glVertexStream3fATI(stream, x, y, z);
        }
        
        public static void glVertexStream3fvATI(int stream, float* coords) {
            Pointers.glVertexStream3fvATI(stream, coords);
        }
        
        public static void glVertexStream3fvATI(int stream, float[] coords) {
            fixed(float* coords_ = &coords[0])
                Pointers.glVertexStream3fvATI(stream, coords_);
        }
        
        public static void glVertexStream3iATI(int stream, int x, int y, int z) {
            Pointers.glVertexStream3iATI(stream, x, y, z);
        }
        
        public static void glVertexStream3ivATI(int stream, int* coords) {
            Pointers.glVertexStream3ivATI(stream, coords);
        }
        
        public static void glVertexStream3ivATI(int stream, int[] coords) {
            fixed(int* coords_ = &coords[0])
                Pointers.glVertexStream3ivATI(stream, coords_);
        }
        
        public static void glVertexStream3sATI(int stream, short x, short y, short z) {
            Pointers.glVertexStream3sATI(stream, x, y, z);
        }
        
        public static void glVertexStream3svATI(int stream, short* coords) {
            Pointers.glVertexStream3svATI(stream, coords);
        }
        
        public static void glVertexStream3svATI(int stream, short[] coords) {
            fixed(short* coords_ = &coords[0])
                Pointers.glVertexStream3svATI(stream, coords_);
        }
        
        public static void glVertexStream4dATI(int stream, double x, double y, double z, double w) {
            Pointers.glVertexStream4dATI(stream, x, y, z, w);
        }
        
        public static void glVertexStream4dvATI(int stream, double* coords) {
            Pointers.glVertexStream4dvATI(stream, coords);
        }
        
        public static void glVertexStream4dvATI(int stream, double[] coords) {
            fixed(double* coords_ = &coords[0])
                Pointers.glVertexStream4dvATI(stream, coords_);
        }
        
        public static void glVertexStream4fATI(int stream, float x, float y, float z, float w) {
            Pointers.glVertexStream4fATI(stream, x, y, z, w);
        }
        
        public static void glVertexStream4fvATI(int stream, float* coords) {
            Pointers.glVertexStream4fvATI(stream, coords);
        }
        
        public static void glVertexStream4fvATI(int stream, float[] coords) {
            fixed(float* coords_ = &coords[0])
                Pointers.glVertexStream4fvATI(stream, coords_);
        }
        
        public static void glVertexStream4iATI(int stream, int x, int y, int z, int w) {
            Pointers.glVertexStream4iATI(stream, x, y, z, w);
        }
        
        public static void glVertexStream4ivATI(int stream, int* coords) {
            Pointers.glVertexStream4ivATI(stream, coords);
        }
        
        public static void glVertexStream4ivATI(int stream, int[] coords) {
            fixed(int* coords_ = &coords[0])
                Pointers.glVertexStream4ivATI(stream, coords_);
        }
        
        public static void glVertexStream4sATI(int stream, short x, short y, short z, short w) {
            Pointers.glVertexStream4sATI(stream, x, y, z, w);
        }
        
        public static void glVertexStream4svATI(int stream, short* coords) {
            Pointers.glVertexStream4svATI(stream, coords);
        }
        
        public static void glVertexStream4svATI(int stream, short[] coords) {
            fixed(short* coords_ = &coords[0])
                Pointers.glVertexStream4svATI(stream, coords_);
        }
        
        public static void glVertexWeightPointerEXT(int size, int type, int stride, IntPtr pointer) {
            Pointers.glVertexWeightPointerEXT(size, type, stride, pointer);
        }
        
        public static void glVertexWeightfEXT(float weight) {
            Pointers.glVertexWeightfEXT(weight);
        }
        
        public static void glVertexWeightfvEXT(float* weight) {
            Pointers.glVertexWeightfvEXT(weight);
        }
        
        public static void glVertexWeightfvEXT(out float weight) {
            fixed(float* weight_ = &weight)
                Pointers.glVertexWeightfvEXT(weight_);
        }
        
        public static void glVertexWeighthNV(short weight) {
            Pointers.glVertexWeighthNV(weight);
        }
        
        public static void glVertexWeighthvNV(short* weight) {
            Pointers.glVertexWeighthvNV(weight);
        }
        
        public static void glVertexWeighthvNV(out short weight) {
            fixed(short* weight_ = &weight)
                Pointers.glVertexWeighthvNV(weight_);
        }
        
        public static int glVideoCaptureNV(uint video_capture_slot, uint* sequence_num, ulong* capture_time) {
            return Pointers.glVideoCaptureNV(video_capture_slot, sequence_num, capture_time);
        }
        
        public static int glVideoCaptureNV(uint video_capture_slot, uint* sequence_num, ulong[] capture_time) {
            fixed(ulong* capture_time_ = &capture_time[0])
                return Pointers.glVideoCaptureNV(video_capture_slot, sequence_num, capture_time_);
        }
        
        public static int glVideoCaptureNV(uint video_capture_slot, uint[] sequence_num, ulong* capture_time) {
            fixed(uint* sequence_num_ = &sequence_num[0])
                return Pointers.glVideoCaptureNV(video_capture_slot, sequence_num_, capture_time);
        }
        
        public static int glVideoCaptureNV(uint video_capture_slot, uint[] sequence_num, ulong[] capture_time) {
            fixed(uint* sequence_num_ = &sequence_num[0])
            fixed(ulong* capture_time_ = &capture_time[0])
                return Pointers.glVideoCaptureNV(video_capture_slot, sequence_num_, capture_time_);
        }
        
        public static void glVideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, int pname, double* _params) {
            Pointers.glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, _params);
        }
        
        public static void glVideoCaptureStreamParameterdvNV(uint video_capture_slot, uint stream, int pname, double[] _params) {
            fixed(double* _params_ = &_params[0])
                Pointers.glVideoCaptureStreamParameterdvNV(video_capture_slot, stream, pname, _params_);
        }
        
        public static void glVideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, int pname, float* _params) {
            Pointers.glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, _params);
        }
        
        public static void glVideoCaptureStreamParameterfvNV(uint video_capture_slot, uint stream, int pname, float[] _params) {
            fixed(float* _params_ = &_params[0])
                Pointers.glVideoCaptureStreamParameterfvNV(video_capture_slot, stream, pname, _params_);
        }
        
        public static void glVideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, int pname, int* _params) {
            Pointers.glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, _params);
        }
        
        public static void glVideoCaptureStreamParameterivNV(uint video_capture_slot, uint stream, int pname, int[] _params) {
            fixed(int* _params_ = &_params[0])
                Pointers.glVideoCaptureStreamParameterivNV(video_capture_slot, stream, pname, _params_);
        }
        
        /// <summary>
        /// set the viewport
        /// <para>
        /// glViewport specifies the affine transformation of x and y from normalized device coordinates to
        /// window coordinates. Let x nd y nd be normalized device coordinates. Then the window coordinates x w
        /// y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
        /// </param>
        /// <param name="y">
        /// Specify the lower left corner of the viewport rectangle, in pixels. The initial value is (0,0).
        /// </param>
        /// <param name="width">
        /// Specify the width and height of the viewport. When a GL context is first attached to a window, width
        /// and height are set to the dimensions of that window.
        /// </param>
        /// <param name="height">
        /// Specify the width and height of the viewport. When a GL context is first attached to a window, width
        /// and height are set to the dimensions of that window.
        /// </param>
        public static void glViewport(int x, int y, int width, int height) {
            Pointers.glViewport(x, y, width, height);
        }
        
        /// <summary>
        /// set multiple viewports
        /// <para>
        /// glViewportArrayv specifies the parameters for multiple viewports simulataneously. first specifies
        /// the index of the first viewport to modify and count specifies the number of viewports to modify.
        /// first must be less than the value of GL_MAX_VIEWPORTS, and first + count must be less than or equal
        /// to the value of GL_MAX_VIEWPORTS. Viewports whose indices lie outside the range [first, first +
        /// count) are not modified. v contains the address of an array of floating point values specifying the
        /// left (x), bottom (y), width (w), and height (h) of each viewport, in that order. x and y give the
        /// location of the viewport's lower left corner, and w and h give the width and height of the viewport,
        /// respectively. The viewport specifies the affine transformation of x and y from normalized device
        /// coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window
        /// coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="count">
        /// Specify the number of viewports to set.
        /// </param>
        /// <param name="v">
        /// Specify the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportArrayv(uint first, int count, float* v) {
            Pointers.glViewportArrayv(first, count, v);
        }
        
        /// <summary>
        /// set multiple viewports
        /// <para>
        /// glViewportArrayv specifies the parameters for multiple viewports simulataneously. first specifies
        /// the index of the first viewport to modify and count specifies the number of viewports to modify.
        /// first must be less than the value of GL_MAX_VIEWPORTS, and first + count must be less than or equal
        /// to the value of GL_MAX_VIEWPORTS. Viewports whose indices lie outside the range [first, first +
        /// count) are not modified. v contains the address of an array of floating point values specifying the
        /// left (x), bottom (y), width (w), and height (h) of each viewport, in that order. x and y give the
        /// location of the viewport's lower left corner, and w and h give the width and height of the viewport,
        /// respectively. The viewport specifies the affine transformation of x and y from normalized device
        /// coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window
        /// coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="count">
        /// Specify the number of viewports to set.
        /// </param>
        /// <param name="v">
        /// Specify the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportArrayv(uint first, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glViewportArrayv(first, count, v_);
        }
        
        /// <summary>
        /// set multiple viewports
        /// <para>
        /// glViewportArrayv specifies the parameters for multiple viewports simulataneously. first specifies
        /// the index of the first viewport to modify and count specifies the number of viewports to modify.
        /// first must be less than the value of GL_MAX_VIEWPORTS, and first + count must be less than or equal
        /// to the value of GL_MAX_VIEWPORTS. Viewports whose indices lie outside the range [first, first +
        /// count) are not modified. v contains the address of an array of floating point values specifying the
        /// left (x), bottom (y), width (w), and height (h) of each viewport, in that order. x and y give the
        /// location of the viewport's lower left corner, and w and h give the width and height of the viewport,
        /// respectively. The viewport specifies the affine transformation of x and y from normalized device
        /// coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window
        /// coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="count">
        /// Specify the number of viewports to set.
        /// </param>
        /// <param name="v">
        /// Specify the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportArrayvNV(uint first, int count, float* v) {
            Pointers.glViewportArrayvNV(first, count, v);
        }
        
        /// <summary>
        /// set multiple viewports
        /// <para>
        /// glViewportArrayv specifies the parameters for multiple viewports simulataneously. first specifies
        /// the index of the first viewport to modify and count specifies the number of viewports to modify.
        /// first must be less than the value of GL_MAX_VIEWPORTS, and first + count must be less than or equal
        /// to the value of GL_MAX_VIEWPORTS. Viewports whose indices lie outside the range [first, first +
        /// count) are not modified. v contains the address of an array of floating point values specifying the
        /// left (x), bottom (y), width (w), and height (h) of each viewport, in that order. x and y give the
        /// location of the viewport's lower left corner, and w and h give the width and height of the viewport,
        /// respectively. The viewport specifies the affine transformation of x and y from normalized device
        /// coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window
        /// coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="count">
        /// Specify the number of viewports to set.
        /// </param>
        /// <param name="v">
        /// Specify the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportArrayvNV(uint first, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glViewportArrayvNV(first, count, v_);
        }
        
        /// <summary>
        /// set multiple viewports
        /// <para>
        /// glViewportArrayv specifies the parameters for multiple viewports simulataneously. first specifies
        /// the index of the first viewport to modify and count specifies the number of viewports to modify.
        /// first must be less than the value of GL_MAX_VIEWPORTS, and first + count must be less than or equal
        /// to the value of GL_MAX_VIEWPORTS. Viewports whose indices lie outside the range [first, first +
        /// count) are not modified. v contains the address of an array of floating point values specifying the
        /// left (x), bottom (y), width (w), and height (h) of each viewport, in that order. x and y give the
        /// location of the viewport's lower left corner, and w and h give the width and height of the viewport,
        /// respectively. The viewport specifies the affine transformation of x and y from normalized device
        /// coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window
        /// coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="count">
        /// Specify the number of viewports to set.
        /// </param>
        /// <param name="v">
        /// Specify the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportArrayvOES(uint first, int count, float* v) {
            Pointers.glViewportArrayvOES(first, count, v);
        }
        
        /// <summary>
        /// set multiple viewports
        /// <para>
        /// glViewportArrayv specifies the parameters for multiple viewports simulataneously. first specifies
        /// the index of the first viewport to modify and count specifies the number of viewports to modify.
        /// first must be less than the value of GL_MAX_VIEWPORTS, and first + count must be less than or equal
        /// to the value of GL_MAX_VIEWPORTS. Viewports whose indices lie outside the range [first, first +
        /// count) are not modified. v contains the address of an array of floating point values specifying the
        /// left (x), bottom (y), width (w), and height (h) of each viewport, in that order. x and y give the
        /// location of the viewport's lower left corner, and w and h give the width and height of the viewport,
        /// respectively. The viewport specifies the affine transformation of x and y from normalized device
        /// coordinates to window coordinates. Let x nd y nd be normalized device coordinates. Then the window
        /// coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="first">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="count">
        /// Specify the number of viewports to set.
        /// </param>
        /// <param name="v">
        /// Specify the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportArrayvOES(uint first, int count, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glViewportArrayvOES(first, count, v_);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="x">
        /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The
        /// initial value is (0,0).
        /// </param>
        /// <param name="y">
        /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The
        /// initial value is (0,0).
        /// </param>
        /// <param name="w"> </param>
        /// <param name="h"> </param>
        public static void glViewportIndexedf(uint index, float x, float y, float w, float h) {
            Pointers.glViewportIndexedf(index, x, y, w, h);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="x">
        /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The
        /// initial value is (0,0).
        /// </param>
        /// <param name="y">
        /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The
        /// initial value is (0,0).
        /// </param>
        /// <param name="w"> </param>
        /// <param name="h"> </param>
        public static void glViewportIndexedfOES(uint index, float x, float y, float w, float h) {
            Pointers.glViewportIndexedfOES(index, x, y, w, h);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="x">
        /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The
        /// initial value is (0,0).
        /// </param>
        /// <param name="y">
        /// For glViewportIndexedf, specifies the lower left corner of the viewport rectangle, in pixels. The
        /// initial value is (0,0).
        /// </param>
        /// <param name="w"> </param>
        /// <param name="h"> </param>
        public static void glViewportIndexedfNV(uint index, float x, float y, float w, float h) {
            Pointers.glViewportIndexedfNV(index, x, y, w, h);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="v">
        /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportIndexedfv(uint index, float* v) {
            Pointers.glViewportIndexedfv(index, v);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="v">
        /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportIndexedfv(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glViewportIndexedfv(index, v_);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="v">
        /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportIndexedfvOES(uint index, float* v) {
            Pointers.glViewportIndexedfvOES(index, v);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="v">
        /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportIndexedfvOES(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glViewportIndexedfvOES(index, v_);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="v">
        /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportIndexedfvNV(uint index, float* v) {
            Pointers.glViewportIndexedfvNV(index, v);
        }
        
        /// <summary>
        /// set a specified viewport
        /// <para>
        /// glViewportIndexedf and glViewportIndexedfv specify the parameters for a single viewport. index
        /// specifies the index of the viewport to modify. index must be less than the value of
        /// GL_MAX_VIEWPORTS. For glViewportIndexedf, x, y, w, and h specify the left, bottom, width and height
        /// of the viewport in pixels, respectively. For glViewportIndexedfv, v contains the address of an array
        /// of floating point values specifying the left (x), bottom (y), width (w), and height (h) of each
        /// viewport, in that order. x and y give the location of the viewport's lower left corner, and w and h
        /// give the width and height of the viewport, respectively. The viewport specifies the affine
        /// transformation of x and y from normalized device coordinates to window coordinates. Let x nd y nd be
        /// normalized device coordinates. Then the window coordinates x w y w are computed as follows:
        /// </para>
        /// </summary>
        /// <param name="index">
        /// Specify the first viewport to set.
        /// </param>
        /// <param name="v">
        /// For glViewportIndexedfv, specifies the address of an array containing the viewport parameters.
        /// </param>
        public static void glViewportIndexedfvNV(uint index, float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glViewportIndexedfvNV(index, v_);
        }
        
        public static void glViewportPositionWScaleNV(uint index, float xcoeff, float ycoeff) {
            Pointers.glViewportPositionWScaleNV(index, xcoeff, ycoeff);
        }
        
        public static void glViewportSwizzleNV(uint index, int swizzlex, int swizzley, int swizzlez, int swizzlew) {
            Pointers.glViewportSwizzleNV(index, swizzlex, swizzley, swizzlez, swizzlew);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, uint* srcLayouts) {
            Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint* textures, uint[] srcLayouts) {
            fixed(uint* srcLayouts_ = &srcLayouts[0])
                Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures, srcLayouts_);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint[] textures, uint* srcLayouts) {
            fixed(uint* textures_ = &textures[0])
                Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures_, srcLayouts);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint* buffers, uint numTextureBarriers, uint[] textures, uint[] srcLayouts) {
            fixed(uint* textures_ = &textures[0])
            fixed(uint* srcLayouts_ = &srcLayouts[0])
                Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers, numTextureBarriers, textures_, srcLayouts_);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint* textures, uint* srcLayouts) {
            fixed(uint* buffers_ = &buffers[0])
                Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures, srcLayouts);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint* textures, uint[] srcLayouts) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* srcLayouts_ = &srcLayouts[0])
                Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures, srcLayouts_);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint[] textures, uint* srcLayouts) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* textures_ = &textures[0])
                Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures_, srcLayouts);
        }
        
        public static void glWaitSemaphoreEXT(uint semaphore, uint numBufferBarriers, uint[] buffers, uint numTextureBarriers, uint[] textures, uint[] srcLayouts) {
            fixed(uint* buffers_ = &buffers[0])
            fixed(uint* textures_ = &textures[0])
            fixed(uint* srcLayouts_ = &srcLayouts[0])
                Pointers.glWaitSemaphoreEXT(semaphore, numBufferBarriers, buffers_, numTextureBarriers, textures_, srcLayouts_);
        }
        
        /// <summary>
        /// instruct the GL server to block until the specified sync object becomes signaled
        /// <para>
        /// glWaitSync causes the GL server to block and wait until sync becomes signaled. sync is the name of
        /// an existing sync object upon which to wait. flags and timeout are currently not used and must be set
        /// to zero and the special value GL_TIMEOUT_IGNORED, respectivelyflags and timeout are placeholders for
        /// anticipated future extensions of sync object capabilities. They must have these reserved values in
        /// order that existing code calling glWaitSync operate properly in the presence of such extensions
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be zero.
        /// </param>
        /// <param name="timeout">
        /// Specifies the timeout that the server should wait before continuing. timeout must be
        /// GL_TIMEOUT_IGNORED.
        /// </param>
        public static void glWaitSync(IntPtr sync, uint flags, ulong timeout) {
            Pointers.glWaitSync(sync, flags, timeout);
        }
        
        /// <summary>
        /// instruct the GL server to block until the specified sync object becomes signaled
        /// <para>
        /// glWaitSync causes the GL server to block and wait until sync becomes signaled. sync is the name of
        /// an existing sync object upon which to wait. flags and timeout are currently not used and must be set
        /// to zero and the special value GL_TIMEOUT_IGNORED, respectivelyflags and timeout are placeholders for
        /// anticipated future extensions of sync object capabilities. They must have these reserved values in
        /// order that existing code calling glWaitSync operate properly in the presence of such extensions
        /// </para>
        /// </summary>
        /// <param name="sync">
        /// Specifies the sync object whose status to wait on.
        /// </param>
        /// <param name="flags">
        /// A bitfield controlling the command flushing behavior. flags may be zero.
        /// </param>
        /// <param name="timeout">
        /// Specifies the timeout that the server should wait before continuing. timeout must be
        /// GL_TIMEOUT_IGNORED.
        /// </param>
        public static void glWaitSyncAPPLE(IntPtr sync, uint flags, ulong timeout) {
            Pointers.glWaitSyncAPPLE(sync, flags, timeout);
        }
        
        public static void glWeightPathsNV(uint resultPath, int numPaths, uint* paths, float* weights) {
            Pointers.glWeightPathsNV(resultPath, numPaths, paths, weights);
        }
        
        public static void glWeightPathsNV(uint resultPath, int numPaths, uint* paths, float[] weights) {
            fixed(float* weights_ = &weights[0])
                Pointers.glWeightPathsNV(resultPath, numPaths, paths, weights_);
        }
        
        public static void glWeightPathsNV(uint resultPath, int numPaths, uint[] paths, float* weights) {
            fixed(uint* paths_ = &paths[0])
                Pointers.glWeightPathsNV(resultPath, numPaths, paths_, weights);
        }
        
        public static void glWeightPathsNV(uint resultPath, int numPaths, uint[] paths, float[] weights) {
            fixed(uint* paths_ = &paths[0])
            fixed(float* weights_ = &weights[0])
                Pointers.glWeightPathsNV(resultPath, numPaths, paths_, weights_);
        }
        
        public static void glWeightPointerARB(int size, int type, int stride, IntPtr pointer) {
            Pointers.glWeightPointerARB(size, type, stride, pointer);
        }
        
        public static void glWeightPointerOES(int size, int type, int stride, IntPtr pointer) {
            Pointers.glWeightPointerOES(size, type, stride, pointer);
        }
        
        public static void glWeightbvARB(int size, sbyte* weights) {
            Pointers.glWeightbvARB(size, weights);
        }
        
        public static void glWeightbvARB(int size, sbyte[] weights) {
            fixed(sbyte* weights_ = &weights[0])
                Pointers.glWeightbvARB(size, weights_);
        }
        
        public static void glWeightdvARB(int size, double* weights) {
            Pointers.glWeightdvARB(size, weights);
        }
        
        public static void glWeightdvARB(int size, double[] weights) {
            fixed(double* weights_ = &weights[0])
                Pointers.glWeightdvARB(size, weights_);
        }
        
        public static void glWeightfvARB(int size, float* weights) {
            Pointers.glWeightfvARB(size, weights);
        }
        
        public static void glWeightfvARB(int size, float[] weights) {
            fixed(float* weights_ = &weights[0])
                Pointers.glWeightfvARB(size, weights_);
        }
        
        public static void glWeightivARB(int size, int* weights) {
            Pointers.glWeightivARB(size, weights);
        }
        
        public static void glWeightivARB(int size, int[] weights) {
            fixed(int* weights_ = &weights[0])
                Pointers.glWeightivARB(size, weights_);
        }
        
        public static void glWeightsvARB(int size, short* weights) {
            Pointers.glWeightsvARB(size, weights);
        }
        
        public static void glWeightsvARB(int size, short[] weights) {
            fixed(short* weights_ = &weights[0])
                Pointers.glWeightsvARB(size, weights_);
        }
        
        public static void glWeightubvARB(int size, byte* weights) {
            Pointers.glWeightubvARB(size, weights);
        }
        
        public static void glWeightubvARB(int size, byte[] weights) {
            fixed(byte* weights_ = &weights[0])
                Pointers.glWeightubvARB(size, weights_);
        }
        
        public static void glWeightuivARB(int size, uint* weights) {
            Pointers.glWeightuivARB(size, weights);
        }
        
        public static void glWeightuivARB(int size, uint[] weights) {
            fixed(uint* weights_ = &weights[0])
                Pointers.glWeightuivARB(size, weights_);
        }
        
        public static void glWeightusvARB(int size, ushort* weights) {
            Pointers.glWeightusvARB(size, weights);
        }
        
        public static void glWeightusvARB(int size, ushort[] weights) {
            fixed(ushort* weights_ = &weights[0])
                Pointers.glWeightusvARB(size, weights_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2d(double x, double y) {
            Pointers.glWindowPos2d(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2dARB(double x, double y) {
            Pointers.glWindowPos2dARB(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2dMESA(double x, double y) {
            Pointers.glWindowPos2dMESA(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2dv(double* v) {
            Pointers.glWindowPos2dv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glWindowPos2dv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2dvARB(double* v) {
            Pointers.glWindowPos2dvARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2dvARB(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glWindowPos2dvARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2dvMESA(double* v) {
            Pointers.glWindowPos2dvMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2dvMESA(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glWindowPos2dvMESA(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2f(float x, float y) {
            Pointers.glWindowPos2f(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2fARB(float x, float y) {
            Pointers.glWindowPos2fARB(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2fMESA(float x, float y) {
            Pointers.glWindowPos2fMESA(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2fv(float* v) {
            Pointers.glWindowPos2fv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glWindowPos2fv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2fvARB(float* v) {
            Pointers.glWindowPos2fvARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2fvARB(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glWindowPos2fvARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2fvMESA(float* v) {
            Pointers.glWindowPos2fvMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2fvMESA(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glWindowPos2fvMESA(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2i(int x, int y) {
            Pointers.glWindowPos2i(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2iARB(int x, int y) {
            Pointers.glWindowPos2iARB(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2iMESA(int x, int y) {
            Pointers.glWindowPos2iMESA(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2iv(int* v) {
            Pointers.glWindowPos2iv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glWindowPos2iv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2ivARB(int* v) {
            Pointers.glWindowPos2ivARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2ivARB(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glWindowPos2ivARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2ivMESA(int* v) {
            Pointers.glWindowPos2ivMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2ivMESA(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glWindowPos2ivMESA(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2s(short x, short y) {
            Pointers.glWindowPos2s(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2sARB(short x, short y) {
            Pointers.glWindowPos2sARB(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos2sMESA(short x, short y) {
            Pointers.glWindowPos2sMESA(x, y);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2sv(short* v) {
            Pointers.glWindowPos2sv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glWindowPos2sv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2svARB(short* v) {
            Pointers.glWindowPos2svARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2svARB(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glWindowPos2svARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2svMESA(short* v) {
            Pointers.glWindowPos2svMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos2svMESA(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glWindowPos2svMESA(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3d(double x, double y, double z) {
            Pointers.glWindowPos3d(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3dARB(double x, double y, double z) {
            Pointers.glWindowPos3dARB(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3dMESA(double x, double y, double z) {
            Pointers.glWindowPos3dMESA(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3dv(double* v) {
            Pointers.glWindowPos3dv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3dv(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glWindowPos3dv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3dvARB(double* v) {
            Pointers.glWindowPos3dvARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3dvARB(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glWindowPos3dvARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3dvMESA(double* v) {
            Pointers.glWindowPos3dvMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3dvMESA(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glWindowPos3dvMESA(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3f(float x, float y, float z) {
            Pointers.glWindowPos3f(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3fARB(float x, float y, float z) {
            Pointers.glWindowPos3fARB(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3fMESA(float x, float y, float z) {
            Pointers.glWindowPos3fMESA(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3fv(float* v) {
            Pointers.glWindowPos3fv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3fv(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glWindowPos3fv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3fvARB(float* v) {
            Pointers.glWindowPos3fvARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3fvARB(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glWindowPos3fvARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3fvMESA(float* v) {
            Pointers.glWindowPos3fvMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3fvMESA(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glWindowPos3fvMESA(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3i(int x, int y, int z) {
            Pointers.glWindowPos3i(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3iARB(int x, int y, int z) {
            Pointers.glWindowPos3iARB(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3iMESA(int x, int y, int z) {
            Pointers.glWindowPos3iMESA(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3iv(int* v) {
            Pointers.glWindowPos3iv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3iv(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glWindowPos3iv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3ivARB(int* v) {
            Pointers.glWindowPos3ivARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3ivARB(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glWindowPos3ivARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3ivMESA(int* v) {
            Pointers.glWindowPos3ivMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3ivMESA(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glWindowPos3ivMESA(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3s(short x, short y, short z) {
            Pointers.glWindowPos3s(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3sARB(short x, short y, short z) {
            Pointers.glWindowPos3sARB(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="x">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="y">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        /// <param name="z">
        /// Specify the x, y, z coordinates for the raster position.
        /// </param>
        public static void glWindowPos3sMESA(short x, short y, short z) {
            Pointers.glWindowPos3sMESA(x, y, z);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3sv(short* v) {
            Pointers.glWindowPos3sv(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3sv(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glWindowPos3sv(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3svARB(short* v) {
            Pointers.glWindowPos3svARB(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3svARB(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glWindowPos3svARB(v_);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3svMESA(short* v) {
            Pointers.glWindowPos3svMESA(v);
        }
        
        /// <summary>
        /// specify the raster position in window coordinates for pixel operations
        /// <para>
        /// The GL maintains a 3D position in window coordinates. This position, called the raster position, is
        /// used to position pixel and bitmap write operations. It is maintained with subpixel accuracy. See
        /// glBitmap, glDrawPixels, and glCopyPixels
        /// </para>
        /// </summary>
        /// <param name="v">
        /// Specifies a pointer to an array of two or three elements, specifying x, y, z coordinates,
        /// respectively.
        /// </param>
        public static void glWindowPos3svMESA(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glWindowPos3svMESA(v_);
        }
        
        public static void glWindowPos4dMESA(double x, double y, double z, double w) {
            Pointers.glWindowPos4dMESA(x, y, z, w);
        }
        
        public static void glWindowPos4dvMESA(double* v) {
            Pointers.glWindowPos4dvMESA(v);
        }
        
        public static void glWindowPos4dvMESA(double[] v) {
            fixed(double* v_ = &v[0])
                Pointers.glWindowPos4dvMESA(v_);
        }
        
        public static void glWindowPos4fMESA(float x, float y, float z, float w) {
            Pointers.glWindowPos4fMESA(x, y, z, w);
        }
        
        public static void glWindowPos4fvMESA(float* v) {
            Pointers.glWindowPos4fvMESA(v);
        }
        
        public static void glWindowPos4fvMESA(float[] v) {
            fixed(float* v_ = &v[0])
                Pointers.glWindowPos4fvMESA(v_);
        }
        
        public static void glWindowPos4iMESA(int x, int y, int z, int w) {
            Pointers.glWindowPos4iMESA(x, y, z, w);
        }
        
        public static void glWindowPos4ivMESA(int* v) {
            Pointers.glWindowPos4ivMESA(v);
        }
        
        public static void glWindowPos4ivMESA(int[] v) {
            fixed(int* v_ = &v[0])
                Pointers.glWindowPos4ivMESA(v_);
        }
        
        public static void glWindowPos4sMESA(short x, short y, short z, short w) {
            Pointers.glWindowPos4sMESA(x, y, z, w);
        }
        
        public static void glWindowPos4svMESA(short* v) {
            Pointers.glWindowPos4svMESA(v);
        }
        
        public static void glWindowPos4svMESA(short[] v) {
            fixed(short* v_ = &v[0])
                Pointers.glWindowPos4svMESA(v_);
        }
        
        public static void glWindowRectanglesEXT(int mode, int count, int* box) {
            Pointers.glWindowRectanglesEXT(mode, count, box);
        }
        
        public static void glWindowRectanglesEXT(int mode, int count, int[] box) {
            fixed(int* box_ = &box[0])
                Pointers.glWindowRectanglesEXT(mode, count, box_);
        }
        
        public static void glWriteMaskEXT(uint res, uint _in, int outX, int outY, int outZ, int outW) {
            Pointers.glWriteMaskEXT(res, _in, outX, outY, outZ, outW);
        }
        
        public static void glDrawVkImageNV(ulong vkImage, uint sampler, float x0, float y0, float x1, float y1, float z, float s0, float t0, float s1, float t1) {
            Pointers.glDrawVkImageNV(vkImage, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1);
        }
        
        public static IntPtr glGetVkProcAddrNV(string name) {
            return Pointers.glGetVkProcAddrNV(name);
        }
        
        public static void glWaitVkSemaphoreNV(ulong vkSemaphore) {
            Pointers.glWaitVkSemaphoreNV(vkSemaphore);
        }
        
        public static void glSignalVkSemaphoreNV(ulong vkSemaphore) {
            Pointers.glSignalVkSemaphoreNV(vkSemaphore);
        }
        
        public static void glSignalVkFenceNV(ulong vkFence) {
            Pointers.glSignalVkFenceNV(vkFence);
        }
    }
}
